{"version":3,"file":"default~DashboardPage~SoloPanelPage~explore.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./node_modules/react-virtualized-auto-sizer/dist/index.esm.js","webpack:///webpack:///./public/app/core/components/Animations/FadeIn.tsx","webpack:///webpack:///./public/app/core/components/Select/DataSourcePicker.tsx","webpack:///webpack:///./public/app/features/explore/state/actions.ts","webpack:///webpack:///./public/app/features/explore/state/selectors.ts","webpack:///webpack:///./public/app/features/profile/state/selectors.ts"],"sourcesContent":["import { createElement, PureComponent } from 'react';\n\n/**\n * Detect Element Resize.\n * https://github.com/sdecima/javascript-detect-element-resize\n * Sebastian Decima\n *\n * Forked from version 0.5.3; includes the following modifications:\n * 1) Guard against unsafe 'window' and 'document' references (to support SSR).\n * 2) Defer initialization code via a top-level function wrapper (to support SSR).\n * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.\n * 4) Add nonce for style element.\n **/\n\nfunction createDetectElementResize(nonce) {\n  // Check `document` and `window` in case of server-side rendering\n  var _window;\n  if (typeof window !== 'undefined') {\n    _window = window;\n  } else if (typeof self !== 'undefined') {\n    _window = self;\n  } else {\n    _window = global;\n  }\n\n  var attachEvent = typeof document !== 'undefined' && document.attachEvent;\n\n  if (!attachEvent) {\n    var requestFrame = function () {\n      var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function (fn) {\n        return _window.setTimeout(fn, 20);\n      };\n      return function (fn) {\n        return raf(fn);\n      };\n    }();\n\n    var cancelFrame = function () {\n      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;\n      return function (id) {\n        return cancel(id);\n      };\n    }();\n\n    var resetTriggers = function resetTriggers(element) {\n      var triggers = element.__resizeTriggers__,\n          expand = triggers.firstElementChild,\n          contract = triggers.lastElementChild,\n          expandChild = expand.firstElementChild;\n      contract.scrollLeft = contract.scrollWidth;\n      contract.scrollTop = contract.scrollHeight;\n      expandChild.style.width = expand.offsetWidth + 1 + 'px';\n      expandChild.style.height = expand.offsetHeight + 1 + 'px';\n      expand.scrollLeft = expand.scrollWidth;\n      expand.scrollTop = expand.scrollHeight;\n    };\n\n    var checkTriggers = function checkTriggers(element) {\n      return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;\n    };\n\n    var scrollListener = function scrollListener(e) {\n      // Don't measure (which forces) reflow for scrolls that happen inside of children!\n      if (e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {\n        return;\n      }\n\n      var element = this;\n      resetTriggers(this);\n      if (this.__resizeRAF__) {\n        cancelFrame(this.__resizeRAF__);\n      }\n      this.__resizeRAF__ = requestFrame(function () {\n        if (checkTriggers(element)) {\n          element.__resizeLast__.width = element.offsetWidth;\n          element.__resizeLast__.height = element.offsetHeight;\n          element.__resizeListeners__.forEach(function (fn) {\n            fn.call(element, e);\n          });\n        }\n      });\n    };\n\n    /* Detect CSS Animations support to detect element display/re-attach */\n    var animation = false,\n        keyframeprefix = '',\n        animationstartevent = 'animationstart',\n        domPrefixes = 'Webkit Moz O ms'.split(' '),\n        startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),\n        pfx = '';\n    {\n      var elm = document.createElement('fakeelement');\n      if (elm.style.animationName !== undefined) {\n        animation = true;\n      }\n\n      if (animation === false) {\n        for (var i = 0; i < domPrefixes.length; i++) {\n          if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {\n            pfx = domPrefixes[i];\n            keyframeprefix = '-' + pfx.toLowerCase() + '-';\n            animationstartevent = startEvents[i];\n            animation = true;\n            break;\n          }\n        }\n      }\n    }\n\n    var animationName = 'resizeanim';\n    var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';\n    var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';\n  }\n\n  var createStyles = function createStyles(doc) {\n    if (!doc.getElementById('detectElementResize')) {\n      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\n      var css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n          head = doc.head || doc.getElementsByTagName('head')[0],\n          style = doc.createElement('style');\n\n      style.id = 'detectElementResize';\n      style.type = 'text/css';\n\n      if (nonce != null) {\n        style.setAttribute('nonce', nonce);\n      }\n\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(doc.createTextNode(css));\n      }\n\n      head.appendChild(style);\n    }\n  };\n\n  var addResizeListener = function addResizeListener(element, fn) {\n    if (attachEvent) {\n      element.attachEvent('onresize', fn);\n    } else {\n      if (!element.__resizeTriggers__) {\n        var doc = element.ownerDocument;\n        var elementStyle = _window.getComputedStyle(element);\n        if (elementStyle && elementStyle.position == 'static') {\n          element.style.position = 'relative';\n        }\n        createStyles(doc);\n        element.__resizeLast__ = {};\n        element.__resizeListeners__ = [];\n        (element.__resizeTriggers__ = doc.createElement('div')).className = 'resize-triggers';\n        element.__resizeTriggers__.innerHTML = '<div class=\"expand-trigger\"><div></div></div>' + '<div class=\"contract-trigger\"></div>';\n        element.appendChild(element.__resizeTriggers__);\n        resetTriggers(element);\n        element.addEventListener('scroll', scrollListener, true);\n\n        /* Listen for a css animation to detect element display/re-attach */\n        if (animationstartevent) {\n          element.__resizeTriggers__.__animationListener__ = function animationListener(e) {\n            if (e.animationName == animationName) {\n              resetTriggers(element);\n            }\n          };\n          element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);\n        }\n      }\n      element.__resizeListeners__.push(fn);\n    }\n  };\n\n  var removeResizeListener = function removeResizeListener(element, fn) {\n    if (attachEvent) {\n      element.detachEvent('onresize', fn);\n    } else {\n      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n      if (!element.__resizeListeners__.length) {\n        element.removeEventListener('scroll', scrollListener, true);\n        if (element.__resizeTriggers__.__animationListener__) {\n          element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);\n          element.__resizeTriggers__.__animationListener__ = null;\n        }\n        try {\n          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);\n        } catch (e) {\n          // Preact compat; see developit/preact-compat/issues/228\n        }\n      }\n    }\n  };\n\n  return {\n    addResizeListener: addResizeListener,\n    removeResizeListener: removeResizeListener\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar AutoSizer = function (_React$PureComponent) {\n  inherits(AutoSizer, _React$PureComponent);\n\n  function AutoSizer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AutoSizer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      height: _this.props.defaultHeight || 0,\n      width: _this.props.defaultWidth || 0\n    }, _this._onResize = function () {\n      var _this$props = _this.props,\n          disableHeight = _this$props.disableHeight,\n          disableWidth = _this$props.disableWidth,\n          onResize = _this$props.onResize;\n\n\n      if (_this._parentNode) {\n        // Guard against AutoSizer component being removed from the DOM immediately after being added.\n        // This can result in invalid style values which can result in NaN values if we don't handle them.\n        // See issue #150 for more context.\n\n        var _height = _this._parentNode.offsetHeight || 0;\n        var _width = _this._parentNode.offsetWidth || 0;\n\n        var _style = window.getComputedStyle(_this._parentNode) || {};\n        var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;\n        var paddingRight = parseInt(_style.paddingRight, 10) || 0;\n        var paddingTop = parseInt(_style.paddingTop, 10) || 0;\n        var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;\n\n        var newHeight = _height - paddingTop - paddingBottom;\n        var newWidth = _width - paddingLeft - paddingRight;\n\n        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {\n          _this.setState({\n            height: _height - paddingTop - paddingBottom,\n            width: _width - paddingLeft - paddingRight\n          });\n\n          onResize({ height: _height, width: _width });\n        }\n      }\n    }, _this._setRef = function (autoSizer) {\n      _this._autoSizer = autoSizer;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AutoSizer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var nonce = this.props.nonce;\n\n      if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {\n        // Delay access of parentNode until mount.\n        // This handles edge-cases where the component has already been unmounted before its ref has been set,\n        // As well as libraries like react-lite which have a slightly different lifecycle.\n        this._parentNode = this._autoSizer.parentNode;\n\n        // Defer requiring resize handler in order to support server-side rendering.\n        // See issue #41\n        this._detectElementResize = createDetectElementResize(nonce);\n        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);\n\n        this._onResize();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._detectElementResize && this._parentNode) {\n        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          children = _props.children,\n          className = _props.className,\n          disableHeight = _props.disableHeight,\n          disableWidth = _props.disableWidth,\n          style = _props.style;\n      var _state = this.state,\n          height = _state.height,\n          width = _state.width;\n\n      // Outer div should not force width/height since that may prevent containers from shrinking.\n      // Inner component should overflow and use calculated width/height.\n      // See issue #68 for more information.\n\n      var outerStyle = { overflow: 'visible' };\n      var childParams = {};\n\n      // Avoid rendering children before the initial measurements have been collected.\n      // At best this would just be wasting cycles.\n      var bailoutOnChildren = false;\n\n      if (!disableHeight) {\n        if (height === 0) {\n          bailoutOnChildren = true;\n        }\n        outerStyle.height = 0;\n        childParams.height = height;\n      }\n\n      if (!disableWidth) {\n        if (width === 0) {\n          bailoutOnChildren = true;\n        }\n        outerStyle.width = 0;\n        childParams.width = width;\n      }\n\n      return createElement(\n        'div',\n        {\n          className: className,\n          ref: this._setRef,\n          style: _extends({}, outerStyle, style) },\n        !bailoutOnChildren && children(childParams)\n      );\n    }\n  }]);\n  return AutoSizer;\n}(PureComponent);\n\nAutoSizer.defaultProps = {\n  onResize: function onResize() {},\n  disableHeight: false,\n  disableWidth: false,\n  style: {}\n};\n\nexport default AutoSizer;\n","import React, { FC, CSSProperties } from 'react';\r\nimport Transition, { ExitHandler } from 'react-transition-group/Transition';\r\n\r\ninterface Props {\r\n  duration: number;\r\n  children: JSX.Element;\r\n  in: boolean;\r\n  unmountOnExit?: boolean;\r\n  onExited?: ExitHandler;\r\n}\r\n\r\nexport const FadeIn: FC<Props> = props => {\r\n  const defaultStyle: CSSProperties = {\r\n    transition: `opacity ${props.duration}ms linear`,\r\n    opacity: 0,\r\n  };\r\n\r\n  const transitionStyles: { [str: string]: CSSProperties } = {\r\n    exited: { opacity: 0, display: 'none' },\r\n    entering: { opacity: 0 },\r\n    entered: { opacity: 1 },\r\n    exiting: { opacity: 0 },\r\n  };\r\n\r\n  return (\r\n    <Transition\r\n      in={props.in}\r\n      timeout={props.duration}\r\n      unmountOnExit={props.unmountOnExit || false}\r\n      onExited={props.onExited}\r\n    >\r\n      {state => (\r\n        <div\r\n          style={{\r\n            ...defaultStyle,\r\n            ...transitionStyles[state],\r\n          }}\r\n        >\r\n          {props.children}\r\n        </div>\r\n      )}\r\n    </Transition>\r\n  );\r\n};\r\n","// Libraries\r\nimport React, { PureComponent } from 'react';\r\n\r\n// Components\r\nimport { Select } from '@grafana/ui';\r\nimport { SelectableValue, DataSourceSelectItem } from '@grafana/data';\r\n\r\nexport interface Props {\r\n  onChange: (ds: DataSourceSelectItem) => void;\r\n  datasources: DataSourceSelectItem[];\r\n  current: DataSourceSelectItem;\r\n  hideTextValue?: boolean;\r\n  onBlur?: () => void;\r\n  autoFocus?: boolean;\r\n  openMenuOnFocus?: boolean;\r\n  showLoading?: boolean;\r\n}\r\n\r\nexport class DataSourcePicker extends PureComponent<Props> {\r\n  static defaultProps: Partial<Props> = {\r\n    autoFocus: false,\r\n    openMenuOnFocus: false,\r\n  };\r\n\r\n  searchInput: HTMLElement;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n  }\r\n\r\n  onChange = (item: SelectableValue<string>) => {\r\n    const ds = this.props.datasources.find(ds => ds.name === item.value);\r\n    this.props.onChange(ds);\r\n  };\r\n\r\n  render() {\r\n    const { datasources, current, autoFocus, hideTextValue, onBlur, openMenuOnFocus, showLoading } = this.props;\r\n\r\n    const options = datasources.map(ds => ({\r\n      value: ds.name,\r\n      label: ds.name,\r\n      imgUrl: ds.meta.info.logos.small,\r\n    }));\r\n\r\n    const value = current && {\r\n      label: current.name.substr(0, 37),\r\n      value: current.name,\r\n      imgUrl: current.meta.info.logos.small,\r\n      loading: showLoading,\r\n      hideText: hideTextValue,\r\n    };\r\n\r\n    return (\r\n      <div className=\"gf-form-inline\">\r\n        <Select\r\n          className=\"ds-picker\"\r\n          isMulti={false}\r\n          isClearable={false}\r\n          backspaceRemovesValue={false}\r\n          onChange={this.onChange}\r\n          options={options}\r\n          autoFocus={autoFocus}\r\n          onBlur={onBlur}\r\n          openMenuOnFocus={openMenuOnFocus}\r\n          maxMenuHeight={500}\r\n          placeholder=\"Select datasource\"\r\n          noOptionsMessage={() => 'No datasources found'}\r\n          value={value}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DataSourcePicker;\r\n","// Libraries\r\nimport { map, throttleTime } from 'rxjs/operators';\r\nimport { identity } from 'rxjs';\r\nimport { ActionCreatorWithPayload, PayloadAction } from '@reduxjs/toolkit';\r\nimport { DataSourceSrv } from '@grafana/runtime';\r\nimport { RefreshPicker } from '@grafana/ui';\r\nimport {\r\n  AbsoluteTimeRange,\r\n  DataQuery,\r\n  DataSourceApi,\r\n  dateTimeForTimeZone,\r\n  isDateTime,\r\n  LoadingState,\r\n  LogsDedupStrategy,\r\n  PanelData,\r\n  QueryFixAction,\r\n  RawTimeRange,\r\n  TimeRange,\r\n} from '@grafana/data';\r\n// Services & Utils\r\nimport store from 'app/core/store';\r\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\r\nimport { Emitter } from 'app/core/core';\r\nimport {\r\n  buildQueryTransaction,\r\n  clearQueryKeys,\r\n  ensureQueries,\r\n  generateEmptyQuery,\r\n  generateNewKeyAndAddRefIdIfMissing,\r\n  GetExploreUrlArguments,\r\n  getTimeRange,\r\n  getTimeRangeFromUrl,\r\n  hasNonEmptyQuery,\r\n  lastUsedDatasourceKeyForOrgId,\r\n  parseUrlState,\r\n  serializeStateToUrlParam,\r\n  stopQueryState,\r\n  updateHistory,\r\n} from 'app/core/utils/explore';\r\n// Types\r\nimport { ExploreItemState, ExploreUrlState, ThunkResult } from 'app/types';\r\n\r\nimport { ExploreId, ExploreMode, ExploreUIState, QueryOptions } from 'app/types/explore';\r\nimport {\r\n  addQueryRowAction,\r\n  changeModeAction,\r\n  changeQueryAction,\r\n  changeRangeAction,\r\n  changeRefreshIntervalAction,\r\n  ChangeRefreshIntervalPayload,\r\n  changeSizeAction,\r\n  ChangeSizePayload,\r\n  clearQueriesAction,\r\n  historyUpdatedAction,\r\n  initializeExploreAction,\r\n  loadDatasourceMissingAction,\r\n  loadDatasourcePendingAction,\r\n  loadDatasourceReadyAction,\r\n  LoadDatasourceReadyPayload,\r\n  modifyQueriesAction,\r\n  queriesImportedAction,\r\n  queryStoreSubscriptionAction,\r\n  queryStreamUpdatedAction,\r\n  scanStartAction,\r\n  scanStopAction,\r\n  setQueriesAction,\r\n  setUrlReplacedAction,\r\n  splitCloseAction,\r\n  splitOpenAction,\r\n  syncTimesAction,\r\n  toggleGraphAction,\r\n  ToggleGraphPayload,\r\n  toggleTableAction,\r\n  ToggleTablePayload,\r\n  updateDatasourceInstanceAction,\r\n  updateUIStateAction,\r\n} from './actionTypes';\r\nimport { getTimeZone } from 'app/features/profile/state/selectors';\r\nimport { getShiftedTimeRange } from 'app/core/utils/timePicker';\r\nimport { updateLocation } from '../../../core/actions';\r\nimport { getTimeSrv, TimeSrv } from '../../dashboard/services/TimeSrv';\r\nimport { preProcessPanelData, runRequest } from '../../dashboard/state/runRequest';\r\nimport { PanelModel } from 'app/features/dashboard/state';\r\nimport { getExploreDatasources } from './selectors';\r\n\r\n/**\r\n * Updates UI state and save it to the URL\r\n */\r\nconst updateExploreUIState = (exploreId: ExploreId, uiStateFragment: Partial<ExploreUIState>): ThunkResult<void> => {\r\n  return dispatch => {\r\n    dispatch(updateUIStateAction({ exploreId, ...uiStateFragment }));\r\n    dispatch(stateSave());\r\n  };\r\n};\r\n\r\n/**\r\n * Adds a query row after the row with the given index.\r\n */\r\nexport function addQueryRow(exploreId: ExploreId, index: number): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    const queries = getState().explore[exploreId].queries;\r\n    const query = generateEmptyQuery(queries, index);\r\n\r\n    dispatch(addQueryRowAction({ exploreId, index, query }));\r\n  };\r\n}\r\n\r\n/**\r\n * Loads a new datasource identified by the given name.\r\n */\r\nexport function changeDatasource(exploreId: ExploreId, datasource: string): ThunkResult<void> {\r\n  return async (dispatch, getState) => {\r\n    let newDataSourceInstance: DataSourceApi = null;\r\n\r\n    if (!datasource) {\r\n      newDataSourceInstance = await getDatasourceSrv().get();\r\n    } else {\r\n      newDataSourceInstance = await getDatasourceSrv().get(datasource);\r\n    }\r\n\r\n    const currentDataSourceInstance = getState().explore[exploreId].datasourceInstance;\r\n    const queries = getState().explore[exploreId].queries;\r\n    const orgId = getState().user.orgId;\r\n    const datasourceVersion = newDataSourceInstance.getVersion && (await newDataSourceInstance.getVersion());\r\n\r\n    // HACK: Switch to logs mode if coming from Prometheus to Loki\r\n    const prometheusToLoki =\r\n      currentDataSourceInstance?.meta?.name === 'Prometheus' && newDataSourceInstance?.meta?.name === 'Loki';\r\n\r\n    dispatch(\r\n      updateDatasourceInstanceAction({\r\n        exploreId,\r\n        datasourceInstance: newDataSourceInstance,\r\n        version: datasourceVersion,\r\n        mode: prometheusToLoki ? ExploreMode.Logs : undefined,\r\n      })\r\n    );\r\n\r\n    await dispatch(importQueries(exploreId, queries, currentDataSourceInstance, newDataSourceInstance));\r\n\r\n    if (getState().explore[exploreId].isLive) {\r\n      dispatch(changeRefreshInterval(exploreId, RefreshPicker.offOption.value));\r\n    }\r\n\r\n    await dispatch(loadDatasource(exploreId, newDataSourceInstance, orgId));\r\n    dispatch(runQueries(exploreId));\r\n  };\r\n}\r\n\r\n/**\r\n * Change the display mode in Explore.\r\n */\r\nexport function changeMode(exploreId: ExploreId, mode: ExploreMode): ThunkResult<void> {\r\n  return dispatch => {\r\n    dispatch(changeModeAction({ exploreId, mode }));\r\n  };\r\n}\r\n\r\n/**\r\n * Query change handler for the query row with the given index.\r\n * If `override` is reset the query modifications and run the queries. Use this to set queries via a link.\r\n */\r\nexport function changeQuery(\r\n  exploreId: ExploreId,\r\n  query: DataQuery,\r\n  index: number,\r\n  override = false\r\n): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    // Null query means reset\r\n    if (query === null) {\r\n      const queries = getState().explore[exploreId].queries;\r\n      const { refId, key } = queries[index];\r\n      query = generateNewKeyAndAddRefIdIfMissing({ refId, key }, queries, index);\r\n    }\r\n\r\n    dispatch(changeQueryAction({ exploreId, query, index, override }));\r\n    if (override) {\r\n      dispatch(runQueries(exploreId));\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Keep track of the Explore container size, in particular the width.\r\n * The width will be used to calculate graph intervals (number of datapoints).\r\n */\r\nexport function changeSize(\r\n  exploreId: ExploreId,\r\n  { height, width }: { height: number; width: number }\r\n): PayloadAction<ChangeSizePayload> {\r\n  return changeSizeAction({ exploreId, height, width });\r\n}\r\n\r\nexport const updateTimeRange = (options: {\r\n  exploreId: ExploreId;\r\n  rawRange?: RawTimeRange;\r\n  absoluteRange?: AbsoluteTimeRange;\r\n}): ThunkResult<void> => {\r\n  return (dispatch, getState) => {\r\n    const { syncedTimes } = getState().explore;\r\n    if (syncedTimes) {\r\n      dispatch(updateTime({ ...options, exploreId: ExploreId.left }));\r\n      dispatch(runQueries(ExploreId.left));\r\n      dispatch(updateTime({ ...options, exploreId: ExploreId.right }));\r\n      dispatch(runQueries(ExploreId.right));\r\n    } else {\r\n      dispatch(updateTime({ ...options }));\r\n      dispatch(runQueries(options.exploreId));\r\n    }\r\n  };\r\n};\r\n/**\r\n * Change the refresh interval of Explore. Called from the Refresh picker.\r\n */\r\nexport function changeRefreshInterval(\r\n  exploreId: ExploreId,\r\n  refreshInterval: string\r\n): PayloadAction<ChangeRefreshIntervalPayload> {\r\n  return changeRefreshIntervalAction({ exploreId, refreshInterval });\r\n}\r\n\r\n/**\r\n * Clear all queries and results.\r\n */\r\nexport function clearQueries(exploreId: ExploreId): ThunkResult<void> {\r\n  return dispatch => {\r\n    dispatch(scanStopAction({ exploreId }));\r\n    dispatch(clearQueriesAction({ exploreId }));\r\n    dispatch(stateSave());\r\n  };\r\n}\r\n\r\n/**\r\n * Loads all explore data sources and sets the chosen datasource.\r\n * If there are no datasources a missing datasource action is dispatched.\r\n */\r\nexport function loadExploreDatasourcesAndSetDatasource(\r\n  exploreId: ExploreId,\r\n  datasourceName: string\r\n): ThunkResult<void> {\r\n  return dispatch => {\r\n    const exploreDatasources = getExploreDatasources();\r\n\r\n    if (exploreDatasources.length >= 1) {\r\n      dispatch(changeDatasource(exploreId, datasourceName));\r\n    } else {\r\n      dispatch(loadDatasourceMissingAction({ exploreId }));\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize Explore state with state from the URL and the React component.\r\n * Call this only on components for with the Explore state has not been initialized.\r\n */\r\nexport function initializeExplore(\r\n  exploreId: ExploreId,\r\n  datasourceName: string,\r\n  queries: DataQuery[],\r\n  range: TimeRange,\r\n  mode: ExploreMode,\r\n  containerWidth: number,\r\n  eventBridge: Emitter,\r\n  ui: ExploreUIState,\r\n  originPanelId: number\r\n): ThunkResult<void> {\r\n  return async (dispatch, getState) => {\r\n    dispatch(loadExploreDatasourcesAndSetDatasource(exploreId, datasourceName));\r\n    dispatch(\r\n      initializeExploreAction({\r\n        exploreId,\r\n        containerWidth,\r\n        eventBridge,\r\n        queries,\r\n        range,\r\n        mode,\r\n        ui,\r\n        originPanelId,\r\n      })\r\n    );\r\n    dispatch(updateTime({ exploreId }));\r\n  };\r\n}\r\n\r\n/**\r\n * Datasource loading was successfully completed.\r\n */\r\nexport const loadDatasourceReady = (\r\n  exploreId: ExploreId,\r\n  instance: DataSourceApi,\r\n  orgId: number\r\n): PayloadAction<LoadDatasourceReadyPayload> => {\r\n  const historyKey = `grafana.explore.history.${instance.meta.id}`;\r\n  const history = store.getObject(historyKey, []);\r\n  // Save last-used datasource\r\n\r\n  store.set(lastUsedDatasourceKeyForOrgId(orgId), instance.name);\r\n\r\n  return loadDatasourceReadyAction({\r\n    exploreId,\r\n    history,\r\n  });\r\n};\r\n\r\n/**\r\n * Import queries from previous datasource if possible eg Loki and Prometheus have similar query language so the\r\n * labels part can be reused to get similar data.\r\n * @param exploreId\r\n * @param queries\r\n * @param sourceDataSource\r\n * @param targetDataSource\r\n */\r\nexport const importQueries = (\r\n  exploreId: ExploreId,\r\n  queries: DataQuery[],\r\n  sourceDataSource: DataSourceApi,\r\n  targetDataSource: DataSourceApi\r\n): ThunkResult<void> => {\r\n  return async dispatch => {\r\n    if (!sourceDataSource) {\r\n      // explore not initialized\r\n      dispatch(queriesImportedAction({ exploreId, queries }));\r\n      return;\r\n    }\r\n\r\n    let importedQueries = queries;\r\n    // Check if queries can be imported from previously selected datasource\r\n    if (sourceDataSource.meta.id === targetDataSource.meta.id) {\r\n      // Keep same queries if same type of datasource\r\n      importedQueries = [...queries];\r\n    } else if (targetDataSource.importQueries) {\r\n      // Datasource-specific importers\r\n      importedQueries = await targetDataSource.importQueries(queries, sourceDataSource.meta);\r\n    } else {\r\n      // Default is blank queries\r\n      importedQueries = ensureQueries();\r\n    }\r\n\r\n    const nextQueries = ensureQueries(importedQueries);\r\n\r\n    dispatch(queriesImportedAction({ exploreId, queries: nextQueries }));\r\n  };\r\n};\r\n\r\n/**\r\n * Main action to asynchronously load a datasource. Dispatches lots of smaller actions for feedback.\r\n */\r\nexport const loadDatasource = (exploreId: ExploreId, instance: DataSourceApi, orgId: number): ThunkResult<void> => {\r\n  return async (dispatch, getState) => {\r\n    const datasourceName = instance.name;\r\n\r\n    // Keep ID to track selection\r\n    dispatch(loadDatasourcePendingAction({ exploreId, requestedDatasourceName: datasourceName }));\r\n\r\n    if (instance.init) {\r\n      try {\r\n        instance.init();\r\n      } catch (err) {\r\n        console.log(err);\r\n      }\r\n    }\r\n\r\n    if (datasourceName !== getState().explore[exploreId].requestedDatasourceName) {\r\n      // User already changed datasource, discard results\r\n      return;\r\n    }\r\n\r\n    dispatch(loadDatasourceReady(exploreId, instance, orgId));\r\n  };\r\n};\r\n\r\n/**\r\n * Action to modify a query given a datasource-specific modifier action.\r\n * @param exploreId Explore area\r\n * @param modification Action object with a type, e.g., ADD_FILTER\r\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\r\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\r\n */\r\nexport function modifyQueries(\r\n  exploreId: ExploreId,\r\n  modification: QueryFixAction,\r\n  modifier: any,\r\n  index?: number\r\n): ThunkResult<void> {\r\n  return dispatch => {\r\n    dispatch(modifyQueriesAction({ exploreId, modification, index, modifier }));\r\n    if (!modification.preventSubmit) {\r\n      dispatch(runQueries(exploreId));\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Main action to run queries and dispatches sub-actions based on which result viewers are active\r\n */\r\nexport const runQueries = (exploreId: ExploreId): ThunkResult<void> => {\r\n  return (dispatch, getState) => {\r\n    dispatch(updateTime({ exploreId }));\r\n\r\n    const exploreItemState = getState().explore[exploreId];\r\n    const {\r\n      datasourceInstance,\r\n      queries,\r\n      containerWidth,\r\n      isLive: live,\r\n      range,\r\n      scanning,\r\n      queryResponse,\r\n      querySubscription,\r\n      history,\r\n      mode,\r\n      showingGraph,\r\n      showingTable,\r\n    } = exploreItemState;\r\n\r\n    if (!hasNonEmptyQuery(queries)) {\r\n      dispatch(clearQueriesAction({ exploreId }));\r\n      dispatch(stateSave()); // Remember to save to state and update location\r\n      return;\r\n    }\r\n\r\n    // Some datasource's query builders allow per-query interval limits,\r\n    // but we're using the datasource interval limit for now\r\n    const minInterval = datasourceInstance.interval;\r\n\r\n    stopQueryState(querySubscription);\r\n\r\n    const queryOptions: QueryOptions = {\r\n      minInterval,\r\n      // This is used for logs streaming for buffer size, with undefined it falls back to datasource config if it\r\n      // supports that.\r\n      maxDataPoints: mode === ExploreMode.Logs ? undefined : containerWidth,\r\n      liveStreaming: live,\r\n      showingGraph,\r\n      showingTable,\r\n      mode,\r\n    };\r\n\r\n    const datasourceId = datasourceInstance.meta.id;\r\n    const transaction = buildQueryTransaction(queries, queryOptions, range, scanning);\r\n\r\n    let firstResponse = true;\r\n\r\n    const newQuerySub = runRequest(datasourceInstance, transaction.request)\r\n      .pipe(\r\n        // Simple throttle for live tailing, in case of > 1000 rows per interval we spend about 200ms on processing and\r\n        // rendering. In case this is optimized this can be tweaked, but also it should be only as fast as user\r\n        // actually can see what is happening.\r\n        live ? throttleTime(500) : identity,\r\n        map((data: PanelData) => preProcessPanelData(data, queryResponse))\r\n      )\r\n      .subscribe((data: PanelData) => {\r\n        if (!data.error && firstResponse) {\r\n          // Side-effect: Saving history in localstorage\r\n          const nextHistory = updateHistory(history, datasourceId, queries);\r\n          dispatch(historyUpdatedAction({ exploreId, history: nextHistory }));\r\n\r\n          // We save queries to the URL here so that only successfully run queries change the URL.\r\n          dispatch(stateSave());\r\n        }\r\n\r\n        firstResponse = false;\r\n\r\n        dispatch(queryStreamUpdatedAction({ exploreId, response: data }));\r\n\r\n        // Keep scanning for results if this was the last scanning transaction\r\n        if (getState().explore[exploreId].scanning) {\r\n          if (data.state === LoadingState.Done && data.series.length === 0) {\r\n            const range = getShiftedTimeRange(-1, getState().explore[exploreId].range);\r\n            dispatch(updateTime({ exploreId, absoluteRange: range }));\r\n            dispatch(runQueries(exploreId));\r\n          } else {\r\n            // We can stop scanning if we have a result\r\n            dispatch(scanStopAction({ exploreId }));\r\n          }\r\n        }\r\n      });\r\n\r\n    dispatch(queryStoreSubscriptionAction({ exploreId, querySubscription: newQuerySub }));\r\n  };\r\n};\r\n\r\nconst toRawTimeRange = (range: TimeRange): RawTimeRange => {\r\n  let from = range.raw.from;\r\n  if (isDateTime(from)) {\r\n    from = from.valueOf().toString(10);\r\n  }\r\n\r\n  let to = range.raw.to;\r\n  if (isDateTime(to)) {\r\n    to = to.valueOf().toString(10);\r\n  }\r\n\r\n  return {\r\n    from,\r\n    to,\r\n  };\r\n};\r\n\r\n/**\r\n * Save local redux state back to the URL. Should be called when there is some change that should affect the URL.\r\n * Not all of the redux state is reflected in URL though.\r\n */\r\nexport const stateSave = (): ThunkResult<void> => {\r\n  return (dispatch, getState) => {\r\n    const { left, right, split } = getState().explore;\r\n    const orgId = getState().user.orgId.toString();\r\n    const replace = left && left.urlReplaced === false;\r\n    const urlStates: { [index: string]: string } = { orgId };\r\n    const leftUrlState: ExploreUrlState = {\r\n      datasource: left.datasourceInstance.name,\r\n      queries: left.queries.map(clearQueryKeys),\r\n      range: toRawTimeRange(left.range),\r\n      mode: left.mode,\r\n      ui: {\r\n        showingGraph: left.showingGraph,\r\n        showingLogs: true,\r\n        showingTable: left.showingTable,\r\n        dedupStrategy: left.dedupStrategy,\r\n      },\r\n    };\r\n    urlStates.left = serializeStateToUrlParam(leftUrlState, true);\r\n    if (split) {\r\n      const rightUrlState: ExploreUrlState = {\r\n        datasource: right.datasourceInstance.name,\r\n        queries: right.queries.map(clearQueryKeys),\r\n        range: toRawTimeRange(right.range),\r\n        mode: right.mode,\r\n        ui: {\r\n          showingGraph: right.showingGraph,\r\n          showingLogs: true,\r\n          showingTable: right.showingTable,\r\n          dedupStrategy: right.dedupStrategy,\r\n        },\r\n      };\r\n\r\n      urlStates.right = serializeStateToUrlParam(rightUrlState, true);\r\n    }\r\n\r\n    dispatch(updateLocation({ query: urlStates, replace }));\r\n    if (replace) {\r\n      dispatch(setUrlReplacedAction({ exploreId: ExploreId.left }));\r\n    }\r\n  };\r\n};\r\n\r\nexport const updateTime = (config: {\r\n  exploreId: ExploreId;\r\n  rawRange?: RawTimeRange;\r\n  absoluteRange?: AbsoluteTimeRange;\r\n}): ThunkResult<void> => {\r\n  return (dispatch, getState) => {\r\n    const { exploreId, absoluteRange: absRange, rawRange: actionRange } = config;\r\n    const itemState = getState().explore[exploreId];\r\n    const timeZone = getTimeZone(getState().user);\r\n    const { range: rangeInState } = itemState;\r\n    let rawRange: RawTimeRange = rangeInState.raw;\r\n\r\n    if (absRange) {\r\n      rawRange = {\r\n        from: dateTimeForTimeZone(timeZone, absRange.from),\r\n        to: dateTimeForTimeZone(timeZone, absRange.to),\r\n      };\r\n    }\r\n\r\n    if (actionRange) {\r\n      rawRange = actionRange;\r\n    }\r\n\r\n    const range = getTimeRange(timeZone, rawRange);\r\n    const absoluteRange: AbsoluteTimeRange = { from: range.from.valueOf(), to: range.to.valueOf() };\r\n\r\n    getTimeSrv().init({\r\n      time: range.raw,\r\n      refresh: false,\r\n      getTimezone: () => timeZone,\r\n      timeRangeUpdated: (): any => undefined,\r\n    });\r\n\r\n    dispatch(changeRangeAction({ exploreId, range, absoluteRange }));\r\n  };\r\n};\r\n\r\n/**\r\n * Start a scan for more results using the given scanner.\r\n * @param exploreId Explore area\r\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\r\n */\r\nexport function scanStart(exploreId: ExploreId): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    // Register the scanner\r\n    dispatch(scanStartAction({ exploreId }));\r\n    // Scanning must trigger query run, and return the new range\r\n    const range = getShiftedTimeRange(-1, getState().explore[exploreId].range);\r\n    // Set the new range to be displayed\r\n    dispatch(updateTime({ exploreId, absoluteRange: range }));\r\n    dispatch(runQueries(exploreId));\r\n  };\r\n}\r\n\r\n/**\r\n * Reset queries to the given queries. Any modifications will be discarded.\r\n * Use this action for clicks on query examples. Triggers a query run.\r\n */\r\nexport function setQueries(exploreId: ExploreId, rawQueries: DataQuery[]): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    // Inject react keys into query objects\r\n    const queries = getState().explore[exploreId].queries;\r\n    const nextQueries = rawQueries.map((query, index) => generateNewKeyAndAddRefIdIfMissing(query, queries, index));\r\n    dispatch(setQueriesAction({ exploreId, queries: nextQueries }));\r\n    dispatch(runQueries(exploreId));\r\n  };\r\n}\r\n\r\n/**\r\n * Close the split view and save URL state.\r\n */\r\nexport function splitClose(itemId: ExploreId): ThunkResult<void> {\r\n  return dispatch => {\r\n    dispatch(splitCloseAction({ itemId }));\r\n    dispatch(stateSave());\r\n  };\r\n}\r\n\r\n/**\r\n * Open the split view and copy the left state to be the right state.\r\n * The right state is automatically initialized.\r\n * The copy keeps all query modifications but wipes the query results.\r\n */\r\nexport function splitOpen(): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    // Clone left state to become the right state\r\n    const leftState = getState().explore[ExploreId.left];\r\n    const queryState = getState().location.query[ExploreId.left] as string;\r\n    const urlState = parseUrlState(queryState);\r\n    const itemState: ExploreItemState = {\r\n      ...leftState,\r\n      queries: leftState.queries.slice(),\r\n      urlState,\r\n    };\r\n    dispatch(splitOpenAction({ itemState }));\r\n    dispatch(stateSave());\r\n  };\r\n}\r\n\r\n/**\r\n * Syncs time interval, if they are not synced on both panels in a split mode.\r\n * Unsyncs time interval, if they are synced on both panels in a split mode.\r\n */\r\nexport function syncTimes(exploreId: ExploreId): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    if (exploreId === ExploreId.left) {\r\n      const leftState = getState().explore.left;\r\n      dispatch(updateTimeRange({ exploreId: ExploreId.right, rawRange: leftState.range.raw }));\r\n    } else {\r\n      const rightState = getState().explore.right;\r\n      dispatch(updateTimeRange({ exploreId: ExploreId.left, rawRange: rightState.range.raw }));\r\n    }\r\n    const isTimeSynced = getState().explore.syncedTimes;\r\n    dispatch(syncTimesAction({ syncedTimes: !isTimeSynced }));\r\n    dispatch(stateSave());\r\n  };\r\n}\r\n\r\n/**\r\n * Creates action to collapse graph/logs/table panel. When panel is collapsed,\r\n * queries won't be run\r\n */\r\nconst togglePanelActionCreator = (\r\n  actionCreator: ActionCreatorWithPayload<ToggleGraphPayload> | ActionCreatorWithPayload<ToggleTablePayload>\r\n) => (exploreId: ExploreId, isPanelVisible: boolean): ThunkResult<void> => {\r\n  return dispatch => {\r\n    let uiFragmentStateUpdate: Partial<ExploreUIState>;\r\n    const shouldRunQueries = !isPanelVisible;\r\n\r\n    switch (actionCreator.type) {\r\n      case toggleGraphAction.type:\r\n        uiFragmentStateUpdate = { showingGraph: !isPanelVisible };\r\n        break;\r\n      case toggleTableAction.type:\r\n        uiFragmentStateUpdate = { showingTable: !isPanelVisible };\r\n        break;\r\n    }\r\n\r\n    dispatch(actionCreator({ exploreId }));\r\n    dispatch(updateExploreUIState(exploreId, uiFragmentStateUpdate));\r\n\r\n    if (shouldRunQueries) {\r\n      dispatch(runQueries(exploreId));\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Expand/collapse the graph result viewer. When collapsed, graph queries won't be run.\r\n */\r\nexport const toggleGraph = togglePanelActionCreator(toggleGraphAction);\r\n\r\n/**\r\n * Expand/collapse the table result viewer. When collapsed, table queries won't be run.\r\n */\r\nexport const toggleTable = togglePanelActionCreator(toggleTableAction);\r\n\r\n/**\r\n * Change logs deduplication strategy and update URL.\r\n */\r\nexport const changeDedupStrategy = (exploreId: ExploreId, dedupStrategy: LogsDedupStrategy): ThunkResult<void> => {\r\n  return dispatch => {\r\n    dispatch(updateExploreUIState(exploreId, { dedupStrategy }));\r\n  };\r\n};\r\n\r\n/**\r\n * Reacts to changes in URL state that we need to sync back to our redux state. Checks the internal update variable\r\n * to see which parts change and need to be synced.\r\n * @param exploreId\r\n */\r\nexport function refreshExplore(exploreId: ExploreId): ThunkResult<void> {\r\n  return (dispatch, getState) => {\r\n    const itemState = getState().explore[exploreId];\r\n    if (!itemState.initialized) {\r\n      return;\r\n    }\r\n\r\n    const { urlState, update, containerWidth, eventBridge } = itemState;\r\n    const { datasource, queries, range: urlRange, mode, ui, originPanelId } = urlState;\r\n    const refreshQueries: DataQuery[] = [];\r\n    for (let index = 0; index < queries.length; index++) {\r\n      const query = queries[index];\r\n      refreshQueries.push(generateNewKeyAndAddRefIdIfMissing(query, refreshQueries, index));\r\n    }\r\n    const timeZone = getTimeZone(getState().user);\r\n    const range = getTimeRangeFromUrl(urlRange, timeZone);\r\n\r\n    // need to refresh datasource\r\n    if (update.datasource) {\r\n      const initialQueries = ensureQueries(queries);\r\n      dispatch(\r\n        initializeExplore(\r\n          exploreId,\r\n          datasource,\r\n          initialQueries,\r\n          range,\r\n          mode,\r\n          containerWidth,\r\n          eventBridge,\r\n          ui,\r\n          originPanelId\r\n        )\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (update.range) {\r\n      dispatch(updateTime({ exploreId, rawRange: range.raw }));\r\n    }\r\n\r\n    // need to refresh ui state\r\n    if (update.ui) {\r\n      dispatch(updateUIStateAction({ ...ui, exploreId }));\r\n    }\r\n\r\n    // need to refresh queries\r\n    if (update.queries) {\r\n      dispatch(setQueriesAction({ exploreId, queries: refreshQueries }));\r\n    }\r\n\r\n    // need to refresh mode\r\n    if (update.mode) {\r\n      dispatch(changeModeAction({ exploreId, mode }));\r\n    }\r\n\r\n    // always run queries when refresh is needed\r\n    if (update.queries || update.ui || update.range) {\r\n      dispatch(runQueries(exploreId));\r\n    }\r\n  };\r\n}\r\n\r\nexport interface NavigateToExploreDependencies {\r\n  getDataSourceSrv: () => DataSourceSrv;\r\n  getTimeSrv: () => TimeSrv;\r\n  getExploreUrl: (args: GetExploreUrlArguments) => Promise<string>;\r\n  openInNewWindow?: (url: string) => void;\r\n}\r\n\r\nexport const navigateToExplore = (\r\n  panel: PanelModel,\r\n  dependencies: NavigateToExploreDependencies\r\n): ThunkResult<void> => {\r\n  return async dispatch => {\r\n    const { getDataSourceSrv, getTimeSrv, getExploreUrl, openInNewWindow } = dependencies;\r\n    const datasourceSrv = getDataSourceSrv();\r\n    const datasource = await datasourceSrv.get(panel.datasource);\r\n    const path = await getExploreUrl({\r\n      panel,\r\n      panelTargets: panel.targets,\r\n      panelDatasource: datasource,\r\n      datasourceSrv,\r\n      timeSrv: getTimeSrv(),\r\n    });\r\n\r\n    if (openInNewWindow) {\r\n      openInNewWindow(path);\r\n      return;\r\n    }\r\n\r\n    const query = {}; // strips any angular query param\r\n    dispatch(updateLocation({ path, query }));\r\n  };\r\n};\r\n","import { createSelector } from 'reselect';\r\nimport { ExploreItemState } from 'app/types';\r\nimport { filterLogLevels, dedupLogRows } from 'app/core/logs_model';\r\nimport { getDatasourceSrv } from '../../plugins/datasource_srv';\r\nimport { DataSourceSelectItem } from '@grafana/data';\r\n\r\nconst logsRowsSelector = (state: ExploreItemState) => state.logsResult && state.logsResult.rows;\r\nconst hiddenLogLevelsSelector = (state: ExploreItemState) => state.hiddenLogLevels;\r\nconst dedupStrategySelector = (state: ExploreItemState) => state.dedupStrategy;\r\nexport const deduplicatedRowsSelector = createSelector(\r\n  logsRowsSelector,\r\n  hiddenLogLevelsSelector,\r\n  dedupStrategySelector,\r\n  function dedupRows(rows, hiddenLogLevels, dedupStrategy) {\r\n    if (!(rows && rows.length)) {\r\n      return rows;\r\n    }\r\n    const filteredRows = filterLogLevels(rows, new Set(hiddenLogLevels));\r\n    return dedupLogRows(filteredRows, dedupStrategy);\r\n  }\r\n);\r\n\r\nexport const getExploreDatasources = (): DataSourceSelectItem[] => {\r\n  return getDatasourceSrv()\r\n    .getExternal()\r\n    .map(\r\n      (ds: any) =>\r\n        ({\r\n          value: ds.name,\r\n          name: ds.name,\r\n          meta: ds.meta,\r\n        } as DataSourceSelectItem)\r\n    );\r\n};\r\n","import { UserState } from 'app/types';\r\n\r\nexport const getTimeZone = (state: UserState) => state.timeZone;\r\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChZA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAmBA;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AAEA;AACA;AAcA;AAAA;AAQA;AAAA;AAIA;AACA;AACA;AACA;;AALA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAiBA;AApDA;AACA;AACA;AACA;AAkDA;AAAA;AAtDA;AAwDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AAGA;AACA;AAaA;AACA;AACA;AAEA;AAmBA;AACA;AAkCA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;;;;;;AACA;AAEA;AACA;;AAAA;;AAEA;;AAAA;;;AAGA;AACA;AACA;AACA;AAAA;AAAA;;AAAA;;;AAAA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;;AAAA;AAEA;AACA;AACA;AAEA;;AAAA;AACA;;;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AAWA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAMA;;;;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;AACA;AAEA;;AADA;AACA;;;AAEA;AACA;;;AAGA;AAEA;;;;AACA;AACA;AAEA;;AAEA;AACA;AACA;;;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAcA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAaA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AASA;AAIA;;;;;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AANA;AAQA;AACA;AACA;AACA;AAEA;AACA;;;;AACA;AACA;;;;;;;;;;;;;AC3yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;;;;;A","sourceRoot":""}