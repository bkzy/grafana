{"version":3,"file":"elasticsearchPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/bucket_agg.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/components/ElasticsearchQueryField.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLink.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLinks.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ElasticDetails.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/configuration/LogsConfig.tsx","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/elastic_response.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/index_pattern.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/metric_agg.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/module.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/pipeline_variables.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/query_builder.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/elasticsearch/query_def.ts"],"sourcesContent":["import coreModule from 'app/core/core_module';\r\nimport _ from 'lodash';\r\nimport * as queryDef from './query_def';\r\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\r\nimport { CoreEvents } from 'app/types';\r\n\r\nexport class ElasticBucketAggCtrl {\r\n  /** @ngInject */\r\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\r\n    const bucketAggs = $scope.target.bucketAggs;\r\n\r\n    $scope.orderByOptions = [];\r\n\r\n    $scope.getBucketAggTypes = () => {\r\n      return queryDef.bucketAggTypes;\r\n    };\r\n\r\n    $scope.getOrderOptions = () => {\r\n      return queryDef.orderOptions;\r\n    };\r\n\r\n    $scope.getSizeOptions = () => {\r\n      return queryDef.sizeOptions;\r\n    };\r\n\r\n    $rootScope.onAppEvent(\r\n      CoreEvents.elasticQueryUpdated,\r\n      () => {\r\n        $scope.validateModel();\r\n      },\r\n      $scope\r\n    );\r\n\r\n    $scope.init = () => {\r\n      $scope.agg = bucketAggs[$scope.index];\r\n      $scope.validateModel();\r\n    };\r\n\r\n    $scope.onChangeInternal = () => {\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.onTypeChanged = () => {\r\n      $scope.agg.settings = {};\r\n      $scope.showOptions = false;\r\n\r\n      switch ($scope.agg.type) {\r\n        case 'date_histogram':\r\n        case 'histogram':\r\n        case 'terms': {\r\n          delete $scope.agg.query;\r\n          $scope.agg.field = 'select field';\r\n          break;\r\n        }\r\n        case 'filters': {\r\n          delete $scope.agg.field;\r\n          $scope.agg.query = '*';\r\n          break;\r\n        }\r\n        case 'geohash_grid': {\r\n          $scope.agg.settings.precision = 3;\r\n          break;\r\n        }\r\n      }\r\n\r\n      $scope.validateModel();\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.validateModel = () => {\r\n      $scope.index = _.indexOf(bucketAggs, $scope.agg);\r\n      $scope.isFirst = $scope.index === 0;\r\n      $scope.bucketAggCount = bucketAggs.length;\r\n\r\n      let settingsLinkText = '';\r\n      const settings = $scope.agg.settings || {};\r\n\r\n      switch ($scope.agg.type) {\r\n        case 'terms': {\r\n          settings.order = settings.order || 'desc';\r\n          settings.size = settings.size || '10';\r\n          settings.min_doc_count = settings.min_doc_count || 1;\r\n          settings.orderBy = settings.orderBy || '_term';\r\n\r\n          if (settings.size !== '0') {\r\n            settingsLinkText = queryDef.describeOrder(settings.order) + ' ' + settings.size + ', ';\r\n          }\r\n\r\n          if (settings.min_doc_count > 0) {\r\n            settingsLinkText += 'Min Doc Count: ' + settings.min_doc_count + ', ';\r\n          }\r\n\r\n          settingsLinkText += 'Order by: ' + queryDef.describeOrderBy(settings.orderBy, $scope.target);\r\n\r\n          if (settings.size === '0') {\r\n            settingsLinkText += ' (' + settings.order + ')';\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 'filters': {\r\n          settings.filters = settings.filters || [{ query: '*' }];\r\n          settingsLinkText = _.reduce(\r\n            settings.filters,\r\n            (memo, value, index) => {\r\n              memo += 'Q' + (index + 1) + '  = ' + value.query + ' ';\r\n              return memo;\r\n            },\r\n            ''\r\n          );\r\n          if (settingsLinkText.length > 50) {\r\n            settingsLinkText = settingsLinkText.substr(0, 50) + '...';\r\n          }\r\n          settingsLinkText = 'Filter Queries (' + settings.filters.length + ')';\r\n          break;\r\n        }\r\n        case 'date_histogram': {\r\n          settings.interval = settings.interval || 'auto';\r\n          settings.min_doc_count = settings.min_doc_count || 0;\r\n          $scope.agg.field = $scope.target.timeField;\r\n          settingsLinkText = 'Interval: ' + settings.interval;\r\n\r\n          if (settings.min_doc_count > 0) {\r\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\r\n          }\r\n\r\n          if (settings.trimEdges === undefined || settings.trimEdges < 0) {\r\n            settings.trimEdges = 0;\r\n          }\r\n\r\n          if (settings.trimEdges && settings.trimEdges > 0) {\r\n            settingsLinkText += ', Trim edges: ' + settings.trimEdges;\r\n          }\r\n          break;\r\n        }\r\n        case 'histogram': {\r\n          settings.interval = settings.interval || 1000;\r\n          settings.min_doc_count = _.defaultTo(settings.min_doc_count, 1);\r\n          settingsLinkText = 'Interval: ' + settings.interval;\r\n\r\n          if (settings.min_doc_count > 0) {\r\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\r\n          }\r\n          break;\r\n        }\r\n        case 'geohash_grid': {\r\n          // limit precision to 7\r\n          settings.precision = Math.max(Math.min(settings.precision, 7), 1);\r\n          settingsLinkText = 'Precision: ' + settings.precision;\r\n          break;\r\n        }\r\n      }\r\n\r\n      $scope.settingsLinkText = settingsLinkText;\r\n      $scope.agg.settings = settings;\r\n      return true;\r\n    };\r\n\r\n    $scope.addFiltersQuery = () => {\r\n      $scope.agg.settings.filters.push({ query: '*' });\r\n    };\r\n\r\n    $scope.removeFiltersQuery = (filter: any) => {\r\n      $scope.agg.settings.filters = _.without($scope.agg.settings.filters, filter);\r\n    };\r\n\r\n    $scope.toggleOptions = () => {\r\n      $scope.showOptions = !$scope.showOptions;\r\n    };\r\n\r\n    $scope.getOrderByOptions = () => {\r\n      return queryDef.getOrderByOptions($scope.target);\r\n    };\r\n\r\n    $scope.getFieldsInternal = () => {\r\n      if ($scope.agg.type === 'date_histogram') {\r\n        return $scope.getFields({ $fieldType: 'date' });\r\n      } else {\r\n        return $scope.getFields();\r\n      }\r\n    };\r\n\r\n    $scope.getIntervalOptions = () => {\r\n      return Promise.resolve(uiSegmentSrv.transformToSegments(true, 'interval')(queryDef.intervalOptions));\r\n    };\r\n\r\n    $scope.addBucketAgg = () => {\r\n      // if last is date histogram add it before\r\n      const lastBucket = bucketAggs[bucketAggs.length - 1];\r\n      let addIndex = bucketAggs.length - 1;\r\n\r\n      if (lastBucket && lastBucket.type === 'date_histogram') {\r\n        addIndex -= 1;\r\n      }\r\n\r\n      const id = _.reduce(\r\n        $scope.target.bucketAggs.concat($scope.target.metrics),\r\n        (max, val) => {\r\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\r\n        },\r\n        0\r\n      );\r\n\r\n      bucketAggs.splice(addIndex, 0, { type: 'terms', field: 'select field', id: (id + 1).toString(), fake: true });\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.removeBucketAgg = () => {\r\n      bucketAggs.splice($scope.index, 1);\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.init();\r\n  }\r\n}\r\n\r\nexport function elasticBucketAgg() {\r\n  return {\r\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/bucket_agg.html',\r\n    controller: ElasticBucketAggCtrl,\r\n    restrict: 'E',\r\n    scope: {\r\n      target: '=',\r\n      index: '=',\r\n      onChange: '&',\r\n      getFields: '&',\r\n    },\r\n  };\r\n}\r\n\r\ncoreModule.directive('elasticBucketAgg', elasticBucketAgg);\r\n","import _ from 'lodash';\r\nimport React from 'react';\r\n\r\nimport { QueryField, SlatePrism } from '@grafana/ui';\r\nimport { ExploreQueryFieldProps } from '@grafana/data';\r\nimport { ElasticDatasource } from '../datasource';\r\nimport { ElasticsearchOptions, ElasticsearchQuery } from '../types';\r\n\r\ninterface Props extends ExploreQueryFieldProps<ElasticDatasource, ElasticsearchQuery, ElasticsearchOptions> {}\r\n\r\ninterface State {\r\n  syntaxLoaded: boolean;\r\n}\r\n\r\nclass ElasticsearchQueryField extends React.PureComponent<Props, State> {\r\n  plugins: any[];\r\n\r\n  constructor(props: Props, context: React.Context<any>) {\r\n    super(props, context);\r\n\r\n    this.plugins = [\r\n      SlatePrism({\r\n        onlyIn: (node: any) => node.type === 'code_block',\r\n        getSyntax: (node: any) => 'lucene',\r\n      }),\r\n    ];\r\n\r\n    this.state = {\r\n      syntaxLoaded: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    if (!this.props.query.isLogsQuery) {\r\n      this.onChangeQuery('', true);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {}\r\n\r\n  componentDidUpdate(prevProps: Props) {\r\n    // if query changed from the outside (i.e. cleared via explore toolbar)\r\n    if (!this.props.query.isLogsQuery) {\r\n      this.onChangeQuery('', true);\r\n    }\r\n  }\r\n\r\n  onChangeQuery = (value: string, override?: boolean) => {\r\n    // Send text change to parent\r\n    const { query, onChange, onRunQuery } = this.props;\r\n    if (onChange) {\r\n      const nextQuery: ElasticsearchQuery = { ...query, query: value, isLogsQuery: true };\r\n      onChange(nextQuery);\r\n\r\n      if (override && onRunQuery) {\r\n        onRunQuery();\r\n      }\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { data, query } = this.props;\r\n    const { syntaxLoaded } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\r\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\r\n            <QueryField\r\n              additionalPlugins={this.plugins}\r\n              query={query.query}\r\n              onChange={this.onChangeQuery}\r\n              onRunQuery={this.props.onRunQuery}\r\n              placeholder=\"Enter a Lucene query\"\r\n              portalOrigin=\"elasticsearch\"\r\n              syntaxLoaded={syntaxLoaded}\r\n            />\r\n          </div>\r\n        </div>\r\n        {data && data.error ? <div className=\"prom-query-field-info text-error\">{data.error.message}</div> : null}\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ElasticsearchQueryField;\r\n","import React, { useEffect } from 'react';\r\nimport { DataSourceHttpSettings } from '@grafana/ui';\r\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\r\nimport { ElasticsearchOptions } from '../types';\r\nimport { defaultMaxConcurrentShardRequests, ElasticDetails } from './ElasticDetails';\r\nimport { LogsConfig } from './LogsConfig';\r\nimport { DataLinks } from './DataLinks';\r\n\r\nexport type Props = DataSourcePluginOptionsEditorProps<ElasticsearchOptions>;\r\nexport const ConfigEditor = (props: Props) => {\r\n  const { options, onOptionsChange } = props;\r\n\r\n  // Apply some defaults on initial render\r\n  useEffect(() => {\r\n    const esVersion = options.jsonData.esVersion || 5;\r\n    onOptionsChange({\r\n      ...options,\r\n      jsonData: {\r\n        ...options.jsonData,\r\n        timeField: options.jsonData.timeField || '@timestamp',\r\n        esVersion,\r\n        maxConcurrentShardRequests:\r\n          options.jsonData.maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(esVersion),\r\n        logMessageField: options.jsonData.logMessageField || '',\r\n        logLevelField: options.jsonData.logLevelField || '',\r\n      },\r\n    });\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <DataSourceHttpSettings\r\n        defaultUrl={'http://localhost:9200'}\r\n        dataSourceConfig={options}\r\n        showAccessOptions={true}\r\n        onChange={onOptionsChange}\r\n      />\r\n\r\n      <ElasticDetails value={options} onChange={onOptionsChange} />\r\n\r\n      <LogsConfig\r\n        value={options.jsonData}\r\n        onChange={newValue =>\r\n          onOptionsChange({\r\n            ...options,\r\n            jsonData: newValue,\r\n          })\r\n        }\r\n      />\r\n\r\n      <DataLinks\r\n        value={options.jsonData.dataLinks}\r\n        onChange={newValue => {\r\n          onOptionsChange({\r\n            ...options,\r\n            jsonData: {\r\n              ...options.jsonData,\r\n              dataLinks: newValue,\r\n            },\r\n          });\r\n        }}\r\n      />\r\n    </>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { css } from 'emotion';\r\nimport { Button, FormField, VariableSuggestion, DataLinkInput, stylesFactory } from '@grafana/ui';\r\nimport { DataLinkConfig } from '../types';\r\n\r\nconst getStyles = stylesFactory(() => ({\r\n  firstRow: css`\r\n    display: flex;\r\n  `,\r\n  nameField: css`\r\n    flex: 2;\r\n  `,\r\n  regexField: css`\r\n    flex: 3;\r\n  `,\r\n}));\r\n\r\ntype Props = {\r\n  value: DataLinkConfig;\r\n  onChange: (value: DataLinkConfig) => void;\r\n  onDelete: () => void;\r\n  suggestions: VariableSuggestion[];\r\n  className?: string;\r\n};\r\nexport const DataLink = (props: Props) => {\r\n  const { value, onChange, onDelete, suggestions, className } = props;\r\n  const styles = getStyles();\r\n\r\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    onChange({\r\n      ...value,\r\n      [field]: event.currentTarget.value,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className={className}>\r\n      <div className={styles.firstRow}>\r\n        <FormField\r\n          className={styles.nameField}\r\n          labelWidth={6}\r\n          // A bit of a hack to prevent using default value for the width from FormField\r\n          inputWidth={null}\r\n          label=\"Field\"\r\n          type=\"text\"\r\n          value={value.field}\r\n          tooltip={'Can be exact field name or a regex pattern that will match on the field name.'}\r\n          onChange={handleChange('field')}\r\n        />\r\n        <Button\r\n          variant={'inverse'}\r\n          title=\"Remove field\"\r\n          icon={'fa fa-times'}\r\n          onClick={event => {\r\n            event.preventDefault();\r\n            onDelete();\r\n          }}\r\n        />\r\n      </div>\r\n\r\n      <FormField\r\n        label=\"URL\"\r\n        labelWidth={6}\r\n        inputEl={\r\n          <DataLinkInput\r\n            placeholder={'http://example.com/${__value.raw}'}\r\n            value={value.url || ''}\r\n            onChange={newValue =>\r\n              onChange({\r\n                ...value,\r\n                url: newValue,\r\n              })\r\n            }\r\n            suggestions={suggestions}\r\n          />\r\n        }\r\n        className={css`\r\n          width: 100%;\r\n        `}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { css } from 'emotion';\r\nimport { Button, DataLinkBuiltInVars, stylesFactory, useTheme, VariableOrigin } from '@grafana/ui';\r\nimport { GrafanaTheme } from '@grafana/data';\r\nimport { DataLinkConfig } from '../types';\r\nimport { DataLink } from './DataLink';\r\n\r\nconst getStyles = stylesFactory((theme: GrafanaTheme) => ({\r\n  infoText: css`\r\n    padding-bottom: ${theme.spacing.md};\r\n    color: ${theme.colors.textWeak};\r\n  `,\r\n  dataLink: css`\r\n    margin-bottom: ${theme.spacing.sm};\r\n  `,\r\n}));\r\n\r\ntype Props = {\r\n  value?: DataLinkConfig[];\r\n  onChange: (value: DataLinkConfig[]) => void;\r\n};\r\nexport const DataLinks = (props: Props) => {\r\n  const { value, onChange } = props;\r\n  const theme = useTheme();\r\n  const styles = getStyles(theme);\r\n\r\n  return (\r\n    <>\r\n      <h3 className=\"page-heading\">Data links</h3>\r\n\r\n      <div className={styles.infoText}>\r\n        Add links to existing fields. Links will be shown in log row details next to the field value.\r\n      </div>\r\n\r\n      <div className=\"gf-form-group\">\r\n        {value &&\r\n          value.map((field, index) => {\r\n            return (\r\n              <DataLink\r\n                className={styles.dataLink}\r\n                key={index}\r\n                value={field}\r\n                onChange={newField => {\r\n                  const newDataLinks = [...value];\r\n                  newDataLinks.splice(index, 1, newField);\r\n                  onChange(newDataLinks);\r\n                }}\r\n                onDelete={() => {\r\n                  const newDataLinks = [...value];\r\n                  newDataLinks.splice(index, 1);\r\n                  onChange(newDataLinks);\r\n                }}\r\n                suggestions={[\r\n                  {\r\n                    value: DataLinkBuiltInVars.valueRaw,\r\n                    label: 'Raw value',\r\n                    documentation: 'Raw value of the field',\r\n                    origin: VariableOrigin.Value,\r\n                  },\r\n                ]}\r\n              />\r\n            );\r\n          })}\r\n        <div>\r\n          <Button\r\n            variant={'inverse'}\r\n            className={css`\r\n              margin-right: 10px;\r\n            `}\r\n            icon=\"fa fa-plus\"\r\n            onClick={event => {\r\n              event.preventDefault();\r\n              const newDataLinks = [...(value || []), { field: '', url: '' }];\r\n              onChange(newDataLinks);\r\n            }}\r\n          >\r\n            Add\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { EventsWithValidation, FormField, Input, regexValidation, Select } from '@grafana/ui';\r\nimport { ElasticsearchOptions } from '../types';\r\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\r\n\r\nconst indexPatternTypes = [\r\n  { label: 'No pattern', value: 'none' },\r\n  { label: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },\r\n  { label: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },\r\n  { label: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },\r\n  { label: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },\r\n  { label: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },\r\n];\r\n\r\nconst esVersions = [\r\n  { label: '2.x', value: 2 },\r\n  { label: '5.x', value: 5 },\r\n  { label: '5.6+', value: 56 },\r\n  { label: '6.0+', value: 60 },\r\n  { label: '7.0+', value: 70 },\r\n];\r\n\r\ntype Props = {\r\n  value: DataSourceSettings<ElasticsearchOptions>;\r\n  onChange: (value: DataSourceSettings<ElasticsearchOptions>) => void;\r\n};\r\nexport const ElasticDetails = (props: Props) => {\r\n  const { value, onChange } = props;\r\n\r\n  return (\r\n    <>\r\n      <h3 className=\"page-heading\">Elasticsearch details</h3>\r\n\r\n      <div className=\"gf-form-group\">\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form max-width-25\">\r\n            <FormField\r\n              labelWidth={10}\r\n              inputWidth={15}\r\n              label=\"Index name\"\r\n              value={value.database || ''}\r\n              onChange={changeHandler('database', value, onChange)}\r\n              placeholder={'es-index-name'}\r\n              required\r\n            />\r\n          </div>\r\n\r\n          <div className=\"gf-form width-14\">\r\n            <FormField\r\n              labelWidth={10}\r\n              label=\"Pattern\"\r\n              inputEl={\r\n                <Select\r\n                  options={indexPatternTypes}\r\n                  onChange={intervalHandler(value, onChange)}\r\n                  value={indexPatternTypes.find(\r\n                    pattern =>\r\n                      pattern.value === (value.jsonData.interval === undefined ? 'none' : value.jsonData.interval)\r\n                  )}\r\n                />\r\n              }\r\n            />\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"gf-form max-width-25\">\r\n          <FormField\r\n            labelWidth={10}\r\n            inputWidth={15}\r\n            label=\"Time field name\"\r\n            value={value.jsonData.timeField || ''}\r\n            onChange={jsonDataChangeHandler('timeField', value, onChange)}\r\n            required\r\n          />\r\n        </div>\r\n\r\n        <div className=\"gf-form\">\r\n          <span className=\"gf-form-select-wrapper\">\r\n            <FormField\r\n              labelWidth={10}\r\n              label=\"Version\"\r\n              inputEl={\r\n                <Select\r\n                  options={esVersions}\r\n                  onChange={option => {\r\n                    const maxConcurrentShardRequests = getMaxConcurrenShardRequestOrDefault(\r\n                      value.jsonData.maxConcurrentShardRequests,\r\n                      option.value\r\n                    );\r\n                    onChange({\r\n                      ...value,\r\n                      jsonData: {\r\n                        ...value.jsonData,\r\n                        esVersion: option.value,\r\n                        maxConcurrentShardRequests,\r\n                      },\r\n                    });\r\n                  }}\r\n                  value={esVersions.find(version => version.value === value.jsonData.esVersion)}\r\n                />\r\n              }\r\n            />\r\n          </span>\r\n        </div>\r\n        {value.jsonData.esVersion >= 56 && (\r\n          <div className=\"gf-form max-width-30\">\r\n            <FormField\r\n              aria-label={'Max concurrent Shard Requests input'}\r\n              labelWidth={15}\r\n              label=\"Max concurrent Shard Requests\"\r\n              value={value.jsonData.maxConcurrentShardRequests || ''}\r\n              onChange={jsonDataChangeHandler('maxConcurrentShardRequests', value, onChange)}\r\n            />\r\n          </div>\r\n        )}\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form\">\r\n            <FormField\r\n              labelWidth={10}\r\n              label=\"Min time interval\"\r\n              inputEl={\r\n                <Input\r\n                  className={'width-6'}\r\n                  value={value.jsonData.timeInterval || ''}\r\n                  onChange={jsonDataChangeHandler('timeInterval', value, onChange)}\r\n                  placeholder=\"10s\"\r\n                  validationEvents={{\r\n                    [EventsWithValidation.onBlur]: [\r\n                      regexValidation(\r\n                        /^\\d+(ms|[Mwdhmsy])$/,\r\n                        'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\r\n                      ),\r\n                    ],\r\n                  }}\r\n                />\r\n              }\r\n              tooltip={\r\n                <>\r\n                  A lower limit for the auto group by time interval. Recommended to be set to write frequency, for\r\n                  example <code>1m</code> if your data is written every minute.\r\n                </>\r\n              }\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst changeHandler = (\r\n  key: keyof DataSourceSettings<ElasticsearchOptions>,\r\n  value: Props['value'],\r\n  onChange: Props['onChange']\r\n) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>) => {\r\n  onChange({\r\n    ...value,\r\n    [key]: event.currentTarget.value,\r\n  });\r\n};\r\n\r\nconst jsonDataChangeHandler = (key: keyof ElasticsearchOptions, value: Props['value'], onChange: Props['onChange']) => (\r\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\r\n) => {\r\n  onChange({\r\n    ...value,\r\n    jsonData: {\r\n      ...value.jsonData,\r\n      [key]: event.currentTarget.value,\r\n    },\r\n  });\r\n};\r\n\r\nconst intervalHandler = (value: Props['value'], onChange: Props['onChange']) => (option: SelectableValue<string>) => {\r\n  const { database } = value;\r\n  // If option value is undefined it will send its label instead so we have to convert made up value to undefined here.\r\n  const newInterval = option.value === 'none' ? undefined : option.value;\r\n\r\n  if (!database || database.length === 0 || database.startsWith('[logstash-]')) {\r\n    let newDatabase = '';\r\n    if (newInterval !== undefined) {\r\n      const pattern = indexPatternTypes.find(pattern => pattern.value === newInterval);\r\n      if (pattern) {\r\n        newDatabase = pattern.example;\r\n      }\r\n    }\r\n\r\n    onChange({\r\n      ...value,\r\n      database: newDatabase,\r\n      jsonData: {\r\n        ...value.jsonData,\r\n        interval: newInterval,\r\n      },\r\n    });\r\n  } else {\r\n    onChange({\r\n      ...value,\r\n      jsonData: {\r\n        ...value.jsonData,\r\n        interval: newInterval,\r\n      },\r\n    });\r\n  }\r\n};\r\n\r\nfunction getMaxConcurrenShardRequestOrDefault(maxConcurrentShardRequests: number, version: number): number {\r\n  if (maxConcurrentShardRequests === 5 && version < 70) {\r\n    return 256;\r\n  }\r\n\r\n  if (maxConcurrentShardRequests === 256 && version >= 70) {\r\n    return 5;\r\n  }\r\n\r\n  return maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(version);\r\n}\r\n\r\nexport function defaultMaxConcurrentShardRequests(version: number) {\r\n  return version >= 70 ? 5 : 256;\r\n}\r\n","import React from 'react';\r\nimport { FormField } from '@grafana/ui';\r\nimport { ElasticsearchOptions } from '../types';\r\n\r\ntype Props = {\r\n  value: ElasticsearchOptions;\r\n  onChange: (value: ElasticsearchOptions) => void;\r\n};\r\nexport const LogsConfig = (props: Props) => {\r\n  const { value, onChange } = props;\r\n  const changeHandler = (key: keyof ElasticsearchOptions) => (\r\n    event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\r\n  ) => {\r\n    onChange({\r\n      ...value,\r\n      [key]: event.currentTarget.value,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h3 className=\"page-heading\">Logs</h3>\r\n\r\n      <div className=\"gf-form-group\">\r\n        <div className=\"gf-form max-width-30\">\r\n          <FormField\r\n            labelWidth={11}\r\n            label=\"Message field name\"\r\n            value={value.logMessageField}\r\n            onChange={changeHandler('logMessageField')}\r\n            placeholder=\"_source\"\r\n          />\r\n        </div>\r\n        <div className=\"gf-form max-width-30\">\r\n          <FormField\r\n            labelWidth={11}\r\n            label=\"Level field name\"\r\n            value={value.logLevelField}\r\n            onChange={changeHandler('logLevelField')}\r\n          />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n","import angular from 'angular';\r\nimport _ from 'lodash';\r\nimport {\r\n  DataSourceApi,\r\n  DataSourceInstanceSettings,\r\n  DataQueryRequest,\r\n  DataQueryResponse,\r\n  DataFrame,\r\n  ScopedVars,\r\n} from '@grafana/data';\r\nimport { ElasticResponse } from './elastic_response';\r\nimport { IndexPattern } from './index_pattern';\r\nimport { ElasticQueryBuilder } from './query_builder';\r\nimport { toUtc } from '@grafana/data';\r\nimport * as queryDef from './query_def';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\nimport { DataLinkConfig, ElasticsearchOptions, ElasticsearchQuery } from './types';\r\n\r\nexport class ElasticDatasource extends DataSourceApi<ElasticsearchQuery, ElasticsearchOptions> {\r\n  basicAuth: string;\r\n  withCredentials: boolean;\r\n  url: string;\r\n  name: string;\r\n  index: string;\r\n  timeField: string;\r\n  esVersion: number;\r\n  interval: string;\r\n  maxConcurrentShardRequests: number;\r\n  queryBuilder: ElasticQueryBuilder;\r\n  indexPattern: IndexPattern;\r\n  logMessageField?: string;\r\n  logLevelField?: string;\r\n  dataLinks: DataLinkConfig[];\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: DataSourceInstanceSettings<ElasticsearchOptions>,\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv,\r\n    private timeSrv: TimeSrv\r\n  ) {\r\n    super(instanceSettings);\r\n    this.basicAuth = instanceSettings.basicAuth;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    this.url = instanceSettings.url;\r\n    this.name = instanceSettings.name;\r\n    this.index = instanceSettings.database;\r\n    const settingsData = instanceSettings.jsonData || ({} as ElasticsearchOptions);\r\n\r\n    this.timeField = settingsData.timeField;\r\n    this.esVersion = settingsData.esVersion;\r\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\r\n    this.interval = settingsData.timeInterval;\r\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\r\n    this.queryBuilder = new ElasticQueryBuilder({\r\n      timeField: this.timeField,\r\n      esVersion: this.esVersion,\r\n    });\r\n    this.logMessageField = settingsData.logMessageField || '';\r\n    this.logLevelField = settingsData.logLevelField || '';\r\n    this.dataLinks = settingsData.dataLinks || [];\r\n\r\n    if (this.logMessageField === '') {\r\n      this.logMessageField = null;\r\n    }\r\n\r\n    if (this.logLevelField === '') {\r\n      this.logLevelField = null;\r\n    }\r\n  }\r\n\r\n  private request(method: string, url: string, data?: undefined) {\r\n    const options: any = {\r\n      url: this.url + '/' + url,\r\n      method: method,\r\n      data: data,\r\n    };\r\n\r\n    if (this.basicAuth || this.withCredentials) {\r\n      options.withCredentials = true;\r\n    }\r\n    if (this.basicAuth) {\r\n      options.headers = {\r\n        Authorization: this.basicAuth,\r\n      };\r\n    }\r\n\r\n    return this.backendSrv.datasourceRequest(options);\r\n  }\r\n\r\n  private get(url: string) {\r\n    const range = this.timeSrv.timeRange();\r\n    const indexList = this.indexPattern.getIndexList(range.from.valueOf(), range.to.valueOf());\r\n    if (_.isArray(indexList) && indexList.length) {\r\n      return this.request('GET', indexList[0] + url).then((results: any) => {\r\n        results.data.$$config = results.config;\r\n        return results.data;\r\n      });\r\n    } else {\r\n      return this.request('GET', this.indexPattern.getIndexForToday() + url).then((results: any) => {\r\n        results.data.$$config = results.config;\r\n        return results.data;\r\n      });\r\n    }\r\n  }\r\n\r\n  private post(url: string, data: any) {\r\n    return this.request('POST', url, data)\r\n      .then((results: any) => {\r\n        results.data.$$config = results.config;\r\n        return results.data;\r\n      })\r\n      .catch((err: any) => {\r\n        if (err.data && err.data.error) {\r\n          throw {\r\n            message: 'Elasticsearch error: ' + err.data.error.reason,\r\n            error: err.data.error,\r\n          };\r\n        }\r\n\r\n        throw err;\r\n      });\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    const annotation = options.annotation;\r\n    const timeField = annotation.timeField || '@timestamp';\r\n    const timeEndField = annotation.timeEndField || null;\r\n    const queryString = annotation.query || '*';\r\n    const tagsField = annotation.tagsField || 'tags';\r\n    const textField = annotation.textField || null;\r\n\r\n    const dateRanges = [];\r\n    const rangeStart: any = {};\r\n    rangeStart[timeField] = {\r\n      from: options.range.from.valueOf(),\r\n      to: options.range.to.valueOf(),\r\n      format: 'epoch_millis',\r\n    };\r\n    dateRanges.push({ range: rangeStart });\r\n\r\n    if (timeEndField) {\r\n      const rangeEnd: any = {};\r\n      rangeEnd[timeEndField] = {\r\n        from: options.range.from.valueOf(),\r\n        to: options.range.to.valueOf(),\r\n        format: 'epoch_millis',\r\n      };\r\n      dateRanges.push({ range: rangeEnd });\r\n    }\r\n\r\n    const queryInterpolated = this.templateSrv.replace(queryString, {}, 'lucene');\r\n    const query = {\r\n      bool: {\r\n        filter: [\r\n          {\r\n            bool: {\r\n              should: dateRanges,\r\n              minimum_should_match: 1,\r\n            },\r\n          },\r\n          {\r\n            query_string: {\r\n              query: queryInterpolated,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    };\r\n\r\n    const data: any = {\r\n      query,\r\n      size: 10000,\r\n    };\r\n\r\n    // fields field not supported on ES 5.x\r\n    if (this.esVersion < 5) {\r\n      data['fields'] = [timeField, '_source'];\r\n    }\r\n\r\n    const header: any = {\r\n      search_type: 'query_then_fetch',\r\n      ignore_unavailable: true,\r\n    };\r\n\r\n    // old elastic annotations had index specified on them\r\n    if (annotation.index) {\r\n      header.index = annotation.index;\r\n    } else {\r\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\r\n    }\r\n\r\n    const payload = angular.toJson(header) + '\\n' + angular.toJson(data) + '\\n';\r\n\r\n    return this.post('_msearch', payload).then((res: any) => {\r\n      const list = [];\r\n      const hits = res.responses[0].hits.hits;\r\n\r\n      const getFieldFromSource = (source: any, fieldName: any) => {\r\n        if (!fieldName) {\r\n          return;\r\n        }\r\n\r\n        const fieldNames = fieldName.split('.');\r\n        let fieldValue = source;\r\n\r\n        for (let i = 0; i < fieldNames.length; i++) {\r\n          fieldValue = fieldValue[fieldNames[i]];\r\n          if (!fieldValue) {\r\n            console.log('could not find field in annotation: ', fieldName);\r\n            return '';\r\n          }\r\n        }\r\n\r\n        return fieldValue;\r\n      };\r\n\r\n      for (let i = 0; i < hits.length; i++) {\r\n        const source = hits[i]._source;\r\n        let time = getFieldFromSource(source, timeField);\r\n        if (typeof hits[i].fields !== 'undefined') {\r\n          const fields = hits[i].fields;\r\n          if (_.isString(fields[timeField]) || _.isNumber(fields[timeField])) {\r\n            time = fields[timeField];\r\n          }\r\n        }\r\n\r\n        const event: {\r\n          annotation: any;\r\n          time: number;\r\n          timeEnd?: number;\r\n          text: string;\r\n          tags: string | string[];\r\n        } = {\r\n          annotation: annotation,\r\n          time: toUtc(time).valueOf(),\r\n          text: getFieldFromSource(source, textField),\r\n          tags: getFieldFromSource(source, tagsField),\r\n        };\r\n\r\n        if (timeEndField) {\r\n          const timeEnd = getFieldFromSource(source, timeEndField);\r\n          if (timeEnd) {\r\n            event.timeEnd = toUtc(timeEnd).valueOf();\r\n          }\r\n        }\r\n\r\n        // legacy support for title tield\r\n        if (annotation.titleField) {\r\n          const title = getFieldFromSource(source, annotation.titleField);\r\n          if (title) {\r\n            event.text = title + '\\n' + event.text;\r\n          }\r\n        }\r\n\r\n        if (typeof event.tags === 'string') {\r\n          event.tags = event.tags.split(',');\r\n        }\r\n\r\n        list.push(event);\r\n      }\r\n      return list;\r\n    });\r\n  }\r\n\r\n  interpolateVariablesInQueries(queries: ElasticsearchQuery[], scopedVars: ScopedVars): ElasticsearchQuery[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          query: this.templateSrv.replace(query.query, scopedVars, 'lucene'),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  testDatasource() {\r\n    // validate that the index exist and has date field\r\n    return this.getFields({ type: 'date' }).then(\r\n      (dateFields: any) => {\r\n        const timeField: any = _.find(dateFields, { text: this.timeField });\r\n        if (!timeField) {\r\n          return {\r\n            status: 'error',\r\n            message: 'No date field named ' + this.timeField + ' found',\r\n          };\r\n        }\r\n        return { status: 'success', message: 'Index OK. Time field name OK.' };\r\n      },\r\n      (err: any) => {\r\n        console.log(err);\r\n        if (err.data && err.data.error) {\r\n          let message = angular.toJson(err.data.error);\r\n          if (err.data.error.reason) {\r\n            message = err.data.error.reason;\r\n          }\r\n          return { status: 'error', message: message };\r\n        } else {\r\n          return { status: 'error', message: err.status };\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  getQueryHeader(searchType: any, timeFrom: any, timeTo: any) {\r\n    const queryHeader: any = {\r\n      search_type: searchType,\r\n      ignore_unavailable: true,\r\n      index: this.indexPattern.getIndexList(timeFrom, timeTo),\r\n    };\r\n    if (this.esVersion >= 56 && this.esVersion < 70) {\r\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\r\n    }\r\n    return angular.toJson(queryHeader);\r\n  }\r\n\r\n  query(options: DataQueryRequest<ElasticsearchQuery>): Promise<DataQueryResponse> {\r\n    let payload = '';\r\n    const targets = _.cloneDeep(options.targets);\r\n    const sentTargets: ElasticsearchQuery[] = [];\r\n\r\n    // add global adhoc filters to timeFilter\r\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\r\n\r\n    for (const target of targets) {\r\n      if (target.hide) {\r\n        continue;\r\n      }\r\n\r\n      let queryString = this.templateSrv.replace(target.query, options.scopedVars, 'lucene');\r\n      // Elasticsearch queryString should always be '*' if empty string\r\n      if (!queryString || queryString === '') {\r\n        queryString = '*';\r\n      }\r\n\r\n      let queryObj;\r\n      if (target.isLogsQuery || queryDef.hasMetricOfType(target, 'logs')) {\r\n        target.bucketAggs = [queryDef.defaultBucketAgg()];\r\n        target.metrics = [queryDef.defaultMetricAgg()];\r\n        // Setting this for metrics queries that are typed as logs\r\n        target.isLogsQuery = true;\r\n        queryObj = this.queryBuilder.getLogsQuery(target, adhocFilters, queryString);\r\n      } else {\r\n        if (target.alias) {\r\n          target.alias = this.templateSrv.replace(target.alias, options.scopedVars, 'lucene');\r\n        }\r\n\r\n        queryObj = this.queryBuilder.build(target, adhocFilters, queryString);\r\n      }\r\n\r\n      const esQuery = angular.toJson(queryObj);\r\n\r\n      const searchType = queryObj.size === 0 && this.esVersion < 5 ? 'count' : 'query_then_fetch';\r\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\r\n      payload += header + '\\n';\r\n\r\n      payload += esQuery + '\\n';\r\n\r\n      sentTargets.push(target);\r\n    }\r\n\r\n    if (sentTargets.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    payload = payload.replace(/\\$timeFrom/g, options.range.from.valueOf().toString());\r\n    payload = payload.replace(/\\$timeTo/g, options.range.to.valueOf().toString());\r\n    payload = this.templateSrv.replace(payload, options.scopedVars);\r\n\r\n    const url = this.getMultiSearchUrl();\r\n\r\n    return this.post(url, payload).then((res: any) => {\r\n      const er = new ElasticResponse(sentTargets, res);\r\n      if (sentTargets.some(target => target.isLogsQuery)) {\r\n        const response = er.getLogs(this.logMessageField, this.logLevelField);\r\n        for (const dataFrame of response.data) {\r\n          this.enhanceDataFrame(dataFrame);\r\n        }\r\n        return response;\r\n      }\r\n\r\n      return er.getTimeSeries();\r\n    });\r\n  }\r\n\r\n  getFields(query: any) {\r\n    const configuredEsVersion = this.esVersion;\r\n    return this.get('/_mapping').then((result: any) => {\r\n      const typeMap: any = {\r\n        float: 'number',\r\n        double: 'number',\r\n        integer: 'number',\r\n        long: 'number',\r\n        date: 'date',\r\n        string: 'string',\r\n        text: 'string',\r\n        scaled_float: 'number',\r\n        nested: 'nested',\r\n      };\r\n\r\n      function shouldAddField(obj: any, key: any, query: any) {\r\n        if (key[0] === '_') {\r\n          return false;\r\n        }\r\n\r\n        if (!query.type) {\r\n          return true;\r\n        }\r\n\r\n        // equal query type filter, or via typemap translation\r\n        return query.type === obj.type || query.type === typeMap[obj.type];\r\n      }\r\n\r\n      // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\r\n      const fieldNameParts: any = [];\r\n      const fields: any = {};\r\n\r\n      function getFieldsRecursively(obj: any) {\r\n        for (const key in obj) {\r\n          const subObj = obj[key];\r\n\r\n          // Check mapping field for nested fields\r\n          if (_.isObject(subObj.properties)) {\r\n            fieldNameParts.push(key);\r\n            getFieldsRecursively(subObj.properties);\r\n          }\r\n\r\n          if (_.isObject(subObj.fields)) {\r\n            fieldNameParts.push(key);\r\n            getFieldsRecursively(subObj.fields);\r\n          }\r\n\r\n          if (_.isString(subObj.type)) {\r\n            const fieldName = fieldNameParts.concat(key).join('.');\r\n\r\n            // Hide meta-fields and check field type\r\n            if (shouldAddField(subObj, key, query)) {\r\n              fields[fieldName] = {\r\n                text: fieldName,\r\n                type: subObj.type,\r\n              };\r\n            }\r\n          }\r\n        }\r\n        fieldNameParts.pop();\r\n      }\r\n\r\n      for (const indexName in result) {\r\n        const index = result[indexName];\r\n        if (index && index.mappings) {\r\n          const mappings = index.mappings;\r\n\r\n          if (configuredEsVersion < 70) {\r\n            for (const typeName in mappings) {\r\n              const properties = mappings[typeName].properties;\r\n              getFieldsRecursively(properties);\r\n            }\r\n          } else {\r\n            const properties = mappings.properties;\r\n            getFieldsRecursively(properties);\r\n          }\r\n        }\r\n      }\r\n\r\n      // transform to array\r\n      return _.map(fields, value => {\r\n        return value;\r\n      });\r\n    });\r\n  }\r\n\r\n  getTerms(queryDef: any) {\r\n    const range = this.timeSrv.timeRange();\r\n    const searchType = this.esVersion >= 5 ? 'query_then_fetch' : 'count';\r\n    const header = this.getQueryHeader(searchType, range.from, range.to);\r\n    let esQuery = angular.toJson(this.queryBuilder.getTermsQuery(queryDef));\r\n\r\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\r\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\r\n    esQuery = header + '\\n' + esQuery + '\\n';\r\n\r\n    const url = this.getMultiSearchUrl();\r\n\r\n    return this.post(url, esQuery).then((res: any) => {\r\n      if (!res.responses[0].aggregations) {\r\n        return [];\r\n      }\r\n\r\n      const buckets = res.responses[0].aggregations['1'].buckets;\r\n      return _.map(buckets, bucket => {\r\n        return {\r\n          text: bucket.key_as_string || bucket.key,\r\n          value: bucket.key,\r\n        };\r\n      });\r\n    });\r\n  }\r\n\r\n  getMultiSearchUrl() {\r\n    if (this.esVersion >= 70 && this.maxConcurrentShardRequests) {\r\n      return `_msearch?max_concurrent_shard_requests=${this.maxConcurrentShardRequests}`;\r\n    }\r\n\r\n    return '_msearch';\r\n  }\r\n\r\n  metricFindQuery(query: any) {\r\n    query = angular.fromJson(query);\r\n    if (!query) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    if (query.find === 'fields') {\r\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\r\n      return this.getFields(query);\r\n    }\r\n\r\n    if (query.find === 'terms') {\r\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\r\n      query.query = this.templateSrv.replace(query.query || '*', {}, 'lucene');\r\n      return this.getTerms(query);\r\n    }\r\n  }\r\n\r\n  getTagKeys() {\r\n    return this.getFields({});\r\n  }\r\n\r\n  getTagValues(options: any) {\r\n    return this.getTerms({ field: options.key, query: '*' });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    if (this.templateSrv.variableExists(target.query) || this.templateSrv.variableExists(target.alias)) {\r\n      return true;\r\n    }\r\n\r\n    for (const bucketAgg of target.bucketAggs) {\r\n      if (this.templateSrv.variableExists(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    for (const metric of target.metrics) {\r\n      if (\r\n        this.templateSrv.variableExists(metric.field) ||\r\n        this.objectContainsTemplate(metric.settings) ||\r\n        this.objectContainsTemplate(metric.meta)\r\n      ) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  enhanceDataFrame(dataFrame: DataFrame) {\r\n    if (this.dataLinks.length) {\r\n      for (const field of dataFrame.fields) {\r\n        const dataLink = this.dataLinks.find(dataLink => field.name && field.name.match(dataLink.field));\r\n        if (dataLink) {\r\n          field.config = field.config || {};\r\n          field.config.links = [\r\n            ...(field.config.links || []),\r\n            {\r\n              url: dataLink.url,\r\n              title: '',\r\n            },\r\n          ];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private isPrimitive(obj: any) {\r\n    if (obj === null || obj === undefined) {\r\n      return true;\r\n    }\r\n    if (['string', 'number', 'boolean'].some(type => type === typeof true)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private objectContainsTemplate(obj: any) {\r\n    if (!obj) {\r\n      return false;\r\n    }\r\n\r\n    for (const key of Object.keys(obj)) {\r\n      if (this.isPrimitive(obj[key])) {\r\n        if (this.templateSrv.variableExists(obj[key])) {\r\n          return true;\r\n        }\r\n      } else if (Array.isArray(obj[key])) {\r\n        for (const item of obj[key]) {\r\n          if (this.objectContainsTemplate(item)) {\r\n            return true;\r\n          }\r\n        }\r\n      } else {\r\n        if (this.objectContainsTemplate(obj[key])) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport flatten from 'app/core/utils/flatten';\r\nimport * as queryDef from './query_def';\r\nimport TableModel from 'app/core/table_model';\r\nimport { DataQueryResponse, DataFrame, toDataFrame, FieldType, MutableDataFrame } from '@grafana/data';\r\nimport { ElasticsearchAggregation } from './types';\r\n\r\nexport class ElasticResponse {\r\n  constructor(private targets: any, private response: any) {\r\n    this.targets = targets;\r\n    this.response = response;\r\n  }\r\n\r\n  processMetrics(esAgg: any, target: any, seriesList: any, props: any) {\r\n    let metric, y, i, newSeries, bucket, value;\r\n\r\n    for (y = 0; y < target.metrics.length; y++) {\r\n      metric = target.metrics[y];\r\n      if (metric.hide) {\r\n        continue;\r\n      }\r\n\r\n      switch (metric.type) {\r\n        case 'count': {\r\n          newSeries = { datapoints: [], metric: 'count', props: props };\r\n          for (i = 0; i < esAgg.buckets.length; i++) {\r\n            bucket = esAgg.buckets[i];\r\n            value = bucket.doc_count;\r\n            newSeries.datapoints.push([value, bucket.key]);\r\n          }\r\n          seriesList.push(newSeries);\r\n          break;\r\n        }\r\n        case 'percentiles': {\r\n          if (esAgg.buckets.length === 0) {\r\n            break;\r\n          }\r\n\r\n          const firstBucket = esAgg.buckets[0];\r\n          const percentiles = firstBucket[metric.id].values;\r\n\r\n          for (const percentileName in percentiles) {\r\n            newSeries = {\r\n              datapoints: [],\r\n              metric: 'p' + percentileName,\r\n              props: props,\r\n              field: metric.field,\r\n            };\r\n\r\n            for (i = 0; i < esAgg.buckets.length; i++) {\r\n              bucket = esAgg.buckets[i];\r\n              const values = bucket[metric.id].values;\r\n              newSeries.datapoints.push([values[percentileName], bucket.key]);\r\n            }\r\n            seriesList.push(newSeries);\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 'extended_stats': {\r\n          for (const statName in metric.meta) {\r\n            if (!metric.meta[statName]) {\r\n              continue;\r\n            }\r\n\r\n            newSeries = {\r\n              datapoints: [],\r\n              metric: statName,\r\n              props: props,\r\n              field: metric.field,\r\n            };\r\n\r\n            for (i = 0; i < esAgg.buckets.length; i++) {\r\n              bucket = esAgg.buckets[i];\r\n              const stats = bucket[metric.id];\r\n\r\n              // add stats that are in nested obj to top level obj\r\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\r\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\r\n\r\n              newSeries.datapoints.push([stats[statName], bucket.key]);\r\n            }\r\n\r\n            seriesList.push(newSeries);\r\n          }\r\n\r\n          break;\r\n        }\r\n        default: {\r\n          newSeries = {\r\n            datapoints: [],\r\n            metric: metric.type,\r\n            field: metric.field,\r\n            metricId: metric.id,\r\n            props: props,\r\n          };\r\n          for (i = 0; i < esAgg.buckets.length; i++) {\r\n            bucket = esAgg.buckets[i];\r\n\r\n            value = bucket[metric.id];\r\n            if (value !== undefined) {\r\n              if (value.normalized_value) {\r\n                newSeries.datapoints.push([value.normalized_value, bucket.key]);\r\n              } else {\r\n                newSeries.datapoints.push([value.value, bucket.key]);\r\n              }\r\n            }\r\n          }\r\n          seriesList.push(newSeries);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  processAggregationDocs(esAgg: any, aggDef: ElasticsearchAggregation, target: any, table: any, props: any) {\r\n    // add columns\r\n    if (table.columns.length === 0) {\r\n      for (const propKey of _.keys(props)) {\r\n        table.addColumn({ text: propKey, filterable: true });\r\n      }\r\n      table.addColumn({ text: aggDef.field, filterable: true });\r\n    }\r\n\r\n    // helper func to add values to value array\r\n    const addMetricValue = (values: any[], metricName: string, value: any) => {\r\n      table.addColumn({ text: metricName });\r\n      values.push(value);\r\n    };\r\n\r\n    for (const bucket of esAgg.buckets) {\r\n      const values = [];\r\n\r\n      for (const propValues of _.values(props)) {\r\n        values.push(propValues);\r\n      }\r\n\r\n      // add bucket key (value)\r\n      values.push(bucket.key);\r\n\r\n      for (const metric of target.metrics) {\r\n        switch (metric.type) {\r\n          case 'count': {\r\n            addMetricValue(values, this.getMetricName(metric.type), bucket.doc_count);\r\n            break;\r\n          }\r\n          case 'extended_stats': {\r\n            for (const statName in metric.meta) {\r\n              if (!metric.meta[statName]) {\r\n                continue;\r\n              }\r\n\r\n              const stats = bucket[metric.id];\r\n              // add stats that are in nested obj to top level obj\r\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\r\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\r\n\r\n              addMetricValue(values, this.getMetricName(statName), stats[statName]);\r\n            }\r\n            break;\r\n          }\r\n          case 'percentiles': {\r\n            const percentiles = bucket[metric.id].values;\r\n\r\n            for (const percentileName in percentiles) {\r\n              addMetricValue(values, `p${percentileName} ${metric.field}`, percentiles[percentileName]);\r\n            }\r\n            break;\r\n          }\r\n          default: {\r\n            let metricName = this.getMetricName(metric.type);\r\n            const otherMetrics = _.filter(target.metrics, { type: metric.type });\r\n\r\n            // if more of the same metric type include field field name in property\r\n            if (otherMetrics.length > 1) {\r\n              metricName += ' ' + metric.field;\r\n            }\r\n\r\n            addMetricValue(values, metricName, bucket[metric.id].value);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      table.rows.push(values);\r\n    }\r\n  }\r\n\r\n  // This is quite complex\r\n  // need to recurse down the nested buckets to build series\r\n  processBuckets(aggs: any, target: any, seriesList: any, table: any, props: any, depth: any) {\r\n    let bucket, aggDef: any, esAgg, aggId;\r\n    const maxDepth = target.bucketAggs.length - 1;\r\n\r\n    for (aggId in aggs) {\r\n      aggDef = _.find(target.bucketAggs, { id: aggId });\r\n      esAgg = aggs[aggId];\r\n\r\n      if (!aggDef) {\r\n        continue;\r\n      }\r\n\r\n      if (depth === maxDepth) {\r\n        if (aggDef.type === 'date_histogram') {\r\n          this.processMetrics(esAgg, target, seriesList, props);\r\n        } else {\r\n          this.processAggregationDocs(esAgg, aggDef, target, table, props);\r\n        }\r\n      } else {\r\n        for (const nameIndex in esAgg.buckets) {\r\n          bucket = esAgg.buckets[nameIndex];\r\n          props = _.clone(props);\r\n          if (bucket.key !== void 0) {\r\n            props[aggDef.field] = bucket.key;\r\n          } else {\r\n            props['filter'] = nameIndex;\r\n          }\r\n          if (bucket.key_as_string) {\r\n            props[aggDef.field] = bucket.key_as_string;\r\n          }\r\n          this.processBuckets(bucket, target, seriesList, table, props, depth + 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private getMetricName(metric: any) {\r\n    let metricDef: any = _.find(queryDef.metricAggTypes, { value: metric });\r\n    if (!metricDef) {\r\n      metricDef = _.find(queryDef.extendedStats, { value: metric });\r\n    }\r\n\r\n    return metricDef ? metricDef.text : metric;\r\n  }\r\n\r\n  private getSeriesName(series: any, target: any, metricTypeCount: any) {\r\n    let metricName = this.getMetricName(series.metric);\r\n\r\n    if (target.alias) {\r\n      const regex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\r\n\r\n      return target.alias.replace(regex, (match: any, g1: any, g2: any) => {\r\n        const group = g1 || g2;\r\n\r\n        if (group.indexOf('term ') === 0) {\r\n          return series.props[group.substring(5)];\r\n        }\r\n        if (series.props[group] !== void 0) {\r\n          return series.props[group];\r\n        }\r\n        if (group === 'metric') {\r\n          return metricName;\r\n        }\r\n        if (group === 'field') {\r\n          return series.field || '';\r\n        }\r\n\r\n        return match;\r\n      });\r\n    }\r\n\r\n    if (series.field && queryDef.isPipelineAgg(series.metric)) {\r\n      if (series.metric && queryDef.isPipelineAggWithMultipleBucketPaths(series.metric)) {\r\n        const agg: any = _.find(target.metrics, { id: series.metricId });\r\n        if (agg && agg.settings.script) {\r\n          metricName = agg.settings.script;\r\n\r\n          for (const pv of agg.pipelineVariables) {\r\n            const appliedAgg: any = _.find(target.metrics, { id: pv.pipelineAgg });\r\n            if (appliedAgg) {\r\n              metricName = metricName.replace('params.' + pv.name, queryDef.describeMetric(appliedAgg));\r\n            }\r\n          }\r\n        } else {\r\n          metricName = 'Unset';\r\n        }\r\n      } else {\r\n        const appliedAgg: any = _.find(target.metrics, { id: series.field });\r\n        if (appliedAgg) {\r\n          metricName += ' ' + queryDef.describeMetric(appliedAgg);\r\n        } else {\r\n          metricName = 'Unset';\r\n        }\r\n      }\r\n    } else if (series.field) {\r\n      metricName += ' ' + series.field;\r\n    }\r\n\r\n    const propKeys = _.keys(series.props);\r\n    if (propKeys.length === 0) {\r\n      return metricName;\r\n    }\r\n\r\n    let name = '';\r\n    for (const propName in series.props) {\r\n      name += series.props[propName] + ' ';\r\n    }\r\n\r\n    if (metricTypeCount === 1) {\r\n      return name.trim();\r\n    }\r\n\r\n    return name.trim() + ' ' + metricName;\r\n  }\r\n\r\n  nameSeries(seriesList: any, target: any) {\r\n    const metricTypeCount = _.uniq(_.map(seriesList, 'metric')).length;\r\n\r\n    for (let i = 0; i < seriesList.length; i++) {\r\n      const series = seriesList[i];\r\n      series.target = this.getSeriesName(series, target, metricTypeCount);\r\n    }\r\n  }\r\n\r\n  processHits(hits: { total: { value: any }; hits: any[] }, seriesList: any[]) {\r\n    const hitsTotal = typeof hits.total === 'number' ? hits.total : hits.total.value; // <- Works with Elasticsearch 7.0+\r\n\r\n    const series: any = {\r\n      target: 'docs',\r\n      type: 'docs',\r\n      datapoints: [],\r\n      total: hitsTotal,\r\n      filterable: true,\r\n    };\r\n    let propName, hit, doc: any, i;\r\n\r\n    for (i = 0; i < hits.hits.length; i++) {\r\n      hit = hits.hits[i];\r\n      doc = {\r\n        _id: hit._id,\r\n        _type: hit._type,\r\n        _index: hit._index,\r\n      };\r\n\r\n      if (hit._source) {\r\n        for (propName in hit._source) {\r\n          doc[propName] = hit._source[propName];\r\n        }\r\n      }\r\n\r\n      for (propName in hit.fields) {\r\n        doc[propName] = hit.fields[propName];\r\n      }\r\n      series.datapoints.push(doc);\r\n    }\r\n\r\n    seriesList.push(series);\r\n  }\r\n\r\n  trimDatapoints(aggregations: any, target: any) {\r\n    const histogram: any = _.find(target.bucketAggs, { type: 'date_histogram' });\r\n\r\n    const shouldDropFirstAndLast = histogram && histogram.settings && histogram.settings.trimEdges;\r\n    if (shouldDropFirstAndLast) {\r\n      const trim = histogram.settings.trimEdges;\r\n      for (const prop in aggregations) {\r\n        const points = aggregations[prop];\r\n        if (points.datapoints.length > trim * 2) {\r\n          points.datapoints = points.datapoints.slice(trim, points.datapoints.length - trim);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getErrorFromElasticResponse(response: any, err: any) {\r\n    const result: any = {};\r\n    result.data = JSON.stringify(err, null, 4);\r\n    if (err.root_cause && err.root_cause.length > 0 && err.root_cause[0].reason) {\r\n      result.message = err.root_cause[0].reason;\r\n    } else {\r\n      result.message = err.reason || 'Unkown elastic error response';\r\n    }\r\n\r\n    if (response.$$config) {\r\n      result.config = response.$$config;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  getTimeSeries() {\r\n    const seriesList = [];\r\n\r\n    for (let i = 0; i < this.response.responses.length; i++) {\r\n      const response = this.response.responses[i];\r\n      if (response.error) {\r\n        throw this.getErrorFromElasticResponse(this.response, response.error);\r\n      }\r\n\r\n      if (response.hits && response.hits.hits.length > 0) {\r\n        this.processHits(response.hits, seriesList);\r\n      }\r\n\r\n      if (response.aggregations) {\r\n        const aggregations = response.aggregations;\r\n        const target = this.targets[i];\r\n        const tmpSeriesList: any[] = [];\r\n        const table = new TableModel();\r\n\r\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\r\n        this.trimDatapoints(tmpSeriesList, target);\r\n        this.nameSeries(tmpSeriesList, target);\r\n\r\n        for (let y = 0; y < tmpSeriesList.length; y++) {\r\n          seriesList.push(tmpSeriesList[y]);\r\n        }\r\n\r\n        if (table.rows.length > 0) {\r\n          seriesList.push(table);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { data: seriesList };\r\n  }\r\n\r\n  getLogs(logMessageField?: string, logLevelField?: string): DataQueryResponse {\r\n    const dataFrame: DataFrame[] = [];\r\n    const docs: any[] = [];\r\n\r\n    for (let n = 0; n < this.response.responses.length; n++) {\r\n      const response = this.response.responses[n];\r\n      if (response.error) {\r\n        throw this.getErrorFromElasticResponse(this.response, response.error);\r\n      }\r\n\r\n      // We keep a list of all props so that we can create all the fields in the dataFrame, this can lead\r\n      // to wide sparse dataframes in case the scheme is different per document.\r\n      let propNames: string[] = [];\r\n\r\n      for (const hit of response.hits.hits) {\r\n        const flattened = hit._source ? flatten(hit._source, null) : {};\r\n        const doc = {\r\n          _id: hit._id,\r\n          _type: hit._type,\r\n          _index: hit._index,\r\n          _source: { ...flattened },\r\n          ...flattened,\r\n        };\r\n\r\n        for (const propName of Object.keys(doc)) {\r\n          if (propNames.indexOf(propName) === -1) {\r\n            propNames.push(propName);\r\n          }\r\n        }\r\n\r\n        docs.push(doc);\r\n      }\r\n\r\n      if (docs.length > 0) {\r\n        propNames = propNames.sort();\r\n        const series = new MutableDataFrame({ fields: [] });\r\n\r\n        series.addField({\r\n          name: this.targets[0].timeField,\r\n          type: FieldType.time,\r\n        });\r\n\r\n        if (logMessageField) {\r\n          series.addField({\r\n            name: logMessageField,\r\n            type: FieldType.string,\r\n          }).parse = (v: any) => {\r\n            return v || '';\r\n          };\r\n        } else {\r\n          series.addField({\r\n            name: '_source',\r\n            type: FieldType.string,\r\n          }).parse = (v: any) => {\r\n            return JSON.stringify(v, null, 2);\r\n          };\r\n        }\r\n\r\n        if (logLevelField) {\r\n          series.addField({\r\n            name: 'level',\r\n            type: FieldType.string,\r\n          }).parse = (v: any) => {\r\n            return v || '';\r\n          };\r\n        }\r\n\r\n        for (const propName of propNames) {\r\n          if (propName === this.targets[0].timeField || propName === '_source') {\r\n            continue;\r\n          }\r\n\r\n          series.addField({\r\n            name: propName,\r\n            type: FieldType.string,\r\n          }).parse = (v: any) => {\r\n            return v || '';\r\n          };\r\n        }\r\n\r\n        // Add a row for each document\r\n        for (const doc of docs) {\r\n          series.add(doc);\r\n        }\r\n\r\n        dataFrame.push(series);\r\n      }\r\n\r\n      if (response.aggregations) {\r\n        const aggregations = response.aggregations;\r\n        const target = this.targets[n];\r\n        const tmpSeriesList: any[] = [];\r\n        const table = new TableModel();\r\n\r\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\r\n        this.trimDatapoints(tmpSeriesList, target);\r\n        this.nameSeries(tmpSeriesList, target);\r\n\r\n        for (let y = 0; y < tmpSeriesList.length; y++) {\r\n          const series = toDataFrame(tmpSeriesList[y]);\r\n          dataFrame.push(series);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { data: dataFrame };\r\n  }\r\n}\r\n","import { toUtc, dateTime } from '@grafana/data';\r\n\r\nconst intervalMap: any = {\r\n  Hourly: { startOf: 'hour', amount: 'hours' },\r\n  Daily: { startOf: 'day', amount: 'days' },\r\n  Weekly: { startOf: 'isoWeek', amount: 'weeks' },\r\n  Monthly: { startOf: 'month', amount: 'months' },\r\n  Yearly: { startOf: 'year', amount: 'years' },\r\n};\r\n\r\nexport class IndexPattern {\r\n  constructor(private pattern: any, private interval: string | null) {}\r\n\r\n  getIndexForToday() {\r\n    if (this.interval) {\r\n      return toUtc().format(this.pattern);\r\n    } else {\r\n      return this.pattern;\r\n    }\r\n  }\r\n\r\n  getIndexList(from: any, to: any) {\r\n    if (!this.interval) {\r\n      return this.pattern;\r\n    }\r\n\r\n    const intervalInfo = intervalMap[this.interval];\r\n    const start = dateTime(from)\r\n      .utc()\r\n      .startOf(intervalInfo.startOf);\r\n    const endEpoch = dateTime(to)\r\n      .utc()\r\n      .startOf(intervalInfo.startOf)\r\n      .valueOf();\r\n    const indexList = [];\r\n\r\n    while (start.valueOf() <= endEpoch) {\r\n      indexList.push(start.format(this.pattern));\r\n      start.add(1, intervalInfo.amount);\r\n    }\r\n\r\n    return indexList;\r\n  }\r\n}\r\n","import coreModule from 'app/core/core_module';\r\nimport _ from 'lodash';\r\nimport * as queryDef from './query_def';\r\nimport { ElasticsearchAggregation } from './types';\r\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\r\nimport { CoreEvents } from 'app/types';\r\n\r\nexport class ElasticMetricAggCtrl {\r\n  /** @ngInject */\r\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\r\n    const metricAggs: ElasticsearchAggregation[] = $scope.target.metrics;\r\n    $scope.metricAggTypes = queryDef.getMetricAggTypes($scope.esVersion);\r\n    $scope.extendedStats = queryDef.extendedStats;\r\n    $scope.pipelineAggOptions = [];\r\n    $scope.modelSettingsValues = {};\r\n\r\n    $scope.init = () => {\r\n      $scope.agg = metricAggs[$scope.index];\r\n      $scope.validateModel();\r\n      $scope.updatePipelineAggOptions();\r\n    };\r\n\r\n    $scope.updatePipelineAggOptions = () => {\r\n      $scope.pipelineAggOptions = queryDef.getPipelineAggOptions($scope.target);\r\n    };\r\n\r\n    $rootScope.onAppEvent(\r\n      CoreEvents.elasticQueryUpdated,\r\n      () => {\r\n        $scope.index = _.indexOf(metricAggs, $scope.agg);\r\n        $scope.updatePipelineAggOptions();\r\n        $scope.validateModel();\r\n      },\r\n      $scope\r\n    );\r\n\r\n    $scope.validateModel = () => {\r\n      $scope.isFirst = $scope.index === 0;\r\n      $scope.isSingle = metricAggs.length === 1;\r\n      $scope.settingsLinkText = '';\r\n      $scope.variablesLinkText = '';\r\n      $scope.aggDef = _.find($scope.metricAggTypes, { value: $scope.agg.type });\r\n\r\n      if (queryDef.isPipelineAgg($scope.agg.type)) {\r\n        if (queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type)) {\r\n          $scope.variablesLinkText = 'Options';\r\n\r\n          if ($scope.agg.settings.script) {\r\n            $scope.variablesLinkText = 'Script: ' + $scope.agg.settings.script.replace(new RegExp('params.', 'g'), '');\r\n          }\r\n        } else {\r\n          $scope.agg.pipelineAgg = $scope.agg.pipelineAgg || 'select metric';\r\n          $scope.agg.field = $scope.agg.pipelineAgg;\r\n        }\r\n\r\n        const pipelineOptions = queryDef.getPipelineOptions($scope.agg);\r\n        if (pipelineOptions.length > 0) {\r\n          _.each(pipelineOptions, opt => {\r\n            $scope.agg.settings[opt.text] = $scope.agg.settings[opt.text] || opt.default;\r\n          });\r\n          $scope.settingsLinkText = 'Options';\r\n        }\r\n      } else if (!$scope.agg.field) {\r\n        $scope.agg.field = 'select field';\r\n      }\r\n      switch ($scope.agg.type) {\r\n        case 'cardinality': {\r\n          const precisionThreshold = $scope.agg.settings.precision_threshold || '';\r\n          $scope.settingsLinkText = 'Precision threshold: ' + precisionThreshold;\r\n          break;\r\n        }\r\n        case 'percentiles': {\r\n          $scope.agg.settings.percents = $scope.agg.settings.percents || [25, 50, 75, 95, 99];\r\n          $scope.settingsLinkText = 'Values: ' + $scope.agg.settings.percents.join(',');\r\n          break;\r\n        }\r\n        case 'extended_stats': {\r\n          if (_.keys($scope.agg.meta).length === 0) {\r\n            $scope.agg.meta.std_deviation_bounds_lower = true;\r\n            $scope.agg.meta.std_deviation_bounds_upper = true;\r\n          }\r\n\r\n          const stats = _.reduce(\r\n            $scope.agg.meta,\r\n            (memo, val, key) => {\r\n              if (val) {\r\n                const def: any = _.find($scope.extendedStats, { value: key });\r\n                memo.push(def.text);\r\n              }\r\n              return memo;\r\n            },\r\n            []\r\n          );\r\n\r\n          $scope.settingsLinkText = 'Stats: ' + stats.join(', ');\r\n          break;\r\n        }\r\n        case 'moving_avg': {\r\n          $scope.movingAvgModelTypes = queryDef.movingAvgModelOptions;\r\n          $scope.modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, true);\r\n          $scope.updateMovingAvgModelSettings();\r\n          break;\r\n        }\r\n        case 'raw_document': {\r\n          $scope.agg.settings.size = $scope.agg.settings.size || 500;\r\n          $scope.settingsLinkText = 'Size: ' + $scope.agg.settings.size;\r\n          $scope.target.metrics.splice(0, $scope.target.metrics.length, $scope.agg);\r\n\r\n          $scope.target.bucketAggs = [];\r\n          break;\r\n        }\r\n      }\r\n      if ($scope.aggDef.supportsInlineScript) {\r\n        // I know this stores the inline script twice\r\n        // but having it like this simplifes the query_builder\r\n        const inlineScript = $scope.agg.inlineScript;\r\n        if (inlineScript) {\r\n          $scope.agg.settings.script = { inline: inlineScript };\r\n        } else {\r\n          delete $scope.agg.settings.script;\r\n        }\r\n\r\n        if ($scope.settingsLinkText === '') {\r\n          $scope.settingsLinkText = 'Options';\r\n        }\r\n      }\r\n    };\r\n\r\n    $scope.toggleOptions = () => {\r\n      $scope.showOptions = !$scope.showOptions;\r\n      $scope.updatePipelineAggOptions();\r\n    };\r\n\r\n    $scope.toggleVariables = () => {\r\n      $scope.showVariables = !$scope.showVariables;\r\n    };\r\n\r\n    $scope.onChangeInternal = () => {\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.updateMovingAvgModelSettings = () => {\r\n      const modelSettingsKeys = [];\r\n      const modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, false);\r\n      for (let i = 0; i < modelSettings.length; i++) {\r\n        modelSettingsKeys.push(modelSettings[i].value);\r\n      }\r\n\r\n      for (const key in $scope.agg.settings.settings) {\r\n        if ($scope.agg.settings.settings[key] === null || modelSettingsKeys.indexOf(key) === -1) {\r\n          delete $scope.agg.settings.settings[key];\r\n        }\r\n      }\r\n    };\r\n\r\n    $scope.onChangeClearInternal = () => {\r\n      delete $scope.agg.settings.minimize;\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.onTypeChange = () => {\r\n      $scope.agg.settings = {};\r\n      $scope.agg.meta = {};\r\n      $scope.showOptions = false;\r\n\r\n      // reset back to metric/group by query\r\n      if ($scope.target.bucketAggs.length === 0 && $scope.agg.type !== 'raw_document') {\r\n        $scope.target.bucketAggs = [queryDef.defaultBucketAgg()];\r\n      }\r\n\r\n      $scope.showVariables = queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type);\r\n      $scope.updatePipelineAggOptions();\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.getFieldsInternal = () => {\r\n      if ($scope.agg.type === 'cardinality') {\r\n        return $scope.getFields();\r\n      }\r\n      return $scope.getFields({ $fieldType: 'number' });\r\n    };\r\n\r\n    $scope.addMetricAgg = () => {\r\n      const addIndex = metricAggs.length;\r\n\r\n      const id = _.reduce(\r\n        $scope.target.bucketAggs.concat($scope.target.metrics),\r\n        (max, val) => {\r\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\r\n        },\r\n        0\r\n      );\r\n\r\n      metricAggs.splice(addIndex, 0, { type: 'count', field: 'select field', id: (id + 1).toString() });\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.removeMetricAgg = () => {\r\n      metricAggs.splice($scope.index, 1);\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.toggleShowMetric = () => {\r\n      $scope.agg.hide = !$scope.agg.hide;\r\n      if (!$scope.agg.hide) {\r\n        delete $scope.agg.hide;\r\n      }\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.init();\r\n  }\r\n}\r\n\r\nexport function elasticMetricAgg() {\r\n  return {\r\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/metric_agg.html',\r\n    controller: ElasticMetricAggCtrl,\r\n    restrict: 'E',\r\n    scope: {\r\n      target: '=',\r\n      index: '=',\r\n      onChange: '&',\r\n      getFields: '&',\r\n      esVersion: '=',\r\n    },\r\n  };\r\n}\r\n\r\ncoreModule.directive('elasticMetricAgg', elasticMetricAgg);\r\n","import { DataSourcePlugin } from '@grafana/data';\r\nimport { ElasticDatasource } from './datasource';\r\nimport { ElasticQueryCtrl } from './query_ctrl';\r\nimport ElasticsearchQueryField from './components/ElasticsearchQueryField';\r\nimport { ConfigEditor } from './configuration/ConfigEditor';\r\n\r\nclass ElasticAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n}\r\n\r\nexport const plugin = new DataSourcePlugin(ElasticDatasource)\r\n  .setQueryCtrl(ElasticQueryCtrl)\r\n  .setConfigEditor(ConfigEditor)\r\n  .setExploreLogsQueryField(ElasticsearchQueryField)\r\n  .setAnnotationQueryCtrl(ElasticAnnotationsQueryCtrl);\r\n","import coreModule from 'app/core/core_module';\r\nimport _ from 'lodash';\r\n\r\nexport function elasticPipelineVariables() {\r\n  return {\r\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/pipeline_variables.html',\r\n    controller: 'ElasticPipelineVariablesCtrl',\r\n    restrict: 'E',\r\n    scope: {\r\n      onChange: '&',\r\n      variables: '=',\r\n      options: '=',\r\n    },\r\n  };\r\n}\r\n\r\nconst newVariable = (index: any) => {\r\n  return {\r\n    name: 'var' + index,\r\n    pipelineAgg: 'select metric',\r\n  };\r\n};\r\n\r\nexport class ElasticPipelineVariablesCtrl {\r\n  /** @ngInject */\r\n  constructor($scope: any) {\r\n    $scope.variables = $scope.variables || [newVariable(1)];\r\n\r\n    $scope.onChangeInternal = () => {\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.add = () => {\r\n      $scope.variables.push(newVariable($scope.variables.length + 1));\r\n      $scope.onChange();\r\n    };\r\n\r\n    $scope.remove = (index: number) => {\r\n      $scope.variables.splice(index, 1);\r\n      $scope.onChange();\r\n    };\r\n  }\r\n}\r\n\r\ncoreModule.directive('elasticPipelineVariables', elasticPipelineVariables);\r\ncoreModule.controller('ElasticPipelineVariablesCtrl', ElasticPipelineVariablesCtrl);\r\n","import * as queryDef from './query_def';\r\nimport { ElasticsearchAggregation } from './types';\r\n\r\nexport class ElasticQueryBuilder {\r\n  timeField: string;\r\n  esVersion: number;\r\n\r\n  constructor(options: { timeField: string; esVersion: number }) {\r\n    this.timeField = options.timeField;\r\n    this.esVersion = options.esVersion;\r\n  }\r\n\r\n  getRangeFilter() {\r\n    const filter: any = {};\r\n    filter[this.timeField] = {\r\n      gte: '$timeFrom',\r\n      lte: '$timeTo',\r\n      format: 'epoch_millis',\r\n    };\r\n\r\n    return filter;\r\n  }\r\n\r\n  buildTermsAgg(aggDef: ElasticsearchAggregation, queryNode: { terms?: any; aggs?: any }, target: { metrics: any[] }) {\r\n    let metricRef, metric, y;\r\n    queryNode.terms = { field: aggDef.field };\r\n\r\n    if (!aggDef.settings) {\r\n      return queryNode;\r\n    }\r\n\r\n    queryNode.terms.size = parseInt(aggDef.settings.size, 10) === 0 ? 500 : parseInt(aggDef.settings.size, 10);\r\n    if (aggDef.settings.orderBy !== void 0) {\r\n      queryNode.terms.order = {};\r\n      if (aggDef.settings.orderBy === '_term' && this.esVersion >= 60) {\r\n        queryNode.terms.order['_key'] = aggDef.settings.order;\r\n      } else {\r\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\r\n      }\r\n\r\n      // if metric ref, look it up and add it to this agg level\r\n      metricRef = parseInt(aggDef.settings.orderBy, 10);\r\n      if (!isNaN(metricRef)) {\r\n        for (y = 0; y < target.metrics.length; y++) {\r\n          metric = target.metrics[y];\r\n          if (metric.id === aggDef.settings.orderBy) {\r\n            queryNode.aggs = {};\r\n            queryNode.aggs[metric.id] = {};\r\n            queryNode.aggs[metric.id][metric.type] = { field: metric.field };\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (aggDef.settings.min_doc_count !== void 0) {\r\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\r\n    }\r\n\r\n    if (aggDef.settings.missing) {\r\n      queryNode.terms.missing = aggDef.settings.missing;\r\n    }\r\n\r\n    return queryNode;\r\n  }\r\n\r\n  getDateHistogramAgg(aggDef: ElasticsearchAggregation) {\r\n    const esAgg: any = {};\r\n    const settings = aggDef.settings || {};\r\n    esAgg.interval = settings.interval;\r\n    esAgg.field = this.timeField;\r\n    esAgg.min_doc_count = settings.min_doc_count || 0;\r\n    esAgg.extended_bounds = { min: '$timeFrom', max: '$timeTo' };\r\n    esAgg.format = 'epoch_millis';\r\n\r\n    if (settings.offset !== '') {\r\n      esAgg.offset = settings.offset;\r\n    }\r\n\r\n    if (esAgg.interval === 'auto') {\r\n      esAgg.interval = '$__interval';\r\n    }\r\n\r\n    if (settings.missing) {\r\n      esAgg.missing = settings.missing;\r\n    }\r\n\r\n    return esAgg;\r\n  }\r\n\r\n  getHistogramAgg(aggDef: ElasticsearchAggregation) {\r\n    const esAgg: any = {};\r\n    const settings = aggDef.settings || {};\r\n    esAgg.interval = settings.interval;\r\n    esAgg.field = aggDef.field;\r\n    esAgg.min_doc_count = settings.min_doc_count || 0;\r\n\r\n    if (settings.missing) {\r\n      esAgg.missing = settings.missing;\r\n    }\r\n    return esAgg;\r\n  }\r\n\r\n  getFiltersAgg(aggDef: ElasticsearchAggregation) {\r\n    const filterObj: any = {};\r\n    for (let i = 0; i < aggDef.settings.filters.length; i++) {\r\n      const query = aggDef.settings.filters[i].query;\r\n      let label = aggDef.settings.filters[i].label;\r\n      label = label === '' || label === undefined ? query : label;\r\n      filterObj[label] = {\r\n        query_string: {\r\n          query: query,\r\n          analyze_wildcard: true,\r\n        },\r\n      };\r\n    }\r\n\r\n    return filterObj;\r\n  }\r\n\r\n  documentQuery(query: any, size: number) {\r\n    query.size = size;\r\n    query.sort = {};\r\n    query.sort[this.timeField] = { order: 'desc', unmapped_type: 'boolean' };\r\n\r\n    // fields field not supported on ES 5.x\r\n    if (this.esVersion < 5) {\r\n      query.fields = ['*', '_source'];\r\n    }\r\n\r\n    query.script_fields = {};\r\n    return query;\r\n  }\r\n\r\n  addAdhocFilters(query: any, adhocFilters: any) {\r\n    if (!adhocFilters) {\r\n      return;\r\n    }\r\n\r\n    let i, filter, condition: any, queryCondition: any;\r\n\r\n    for (i = 0; i < adhocFilters.length; i++) {\r\n      filter = adhocFilters[i];\r\n      condition = {};\r\n      condition[filter.key] = filter.value;\r\n      queryCondition = {};\r\n      queryCondition[filter.key] = { query: filter.value };\r\n\r\n      switch (filter.operator) {\r\n        case '=':\r\n          if (!query.query.bool.must) {\r\n            query.query.bool.must = [];\r\n          }\r\n          query.query.bool.must.push({ match_phrase: queryCondition });\r\n          break;\r\n        case '!=':\r\n          if (!query.query.bool.must_not) {\r\n            query.query.bool.must_not = [];\r\n          }\r\n          query.query.bool.must_not.push({ match_phrase: queryCondition });\r\n          break;\r\n        case '<':\r\n          condition[filter.key] = { lt: filter.value };\r\n          query.query.bool.filter.push({ range: condition });\r\n          break;\r\n        case '>':\r\n          condition[filter.key] = { gt: filter.value };\r\n          query.query.bool.filter.push({ range: condition });\r\n          break;\r\n        case '=~':\r\n          query.query.bool.filter.push({ regexp: condition });\r\n          break;\r\n        case '!~':\r\n          query.query.bool.filter.push({\r\n            bool: { must_not: { regexp: condition } },\r\n          });\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  build(target: any, adhocFilters?: any, queryString?: string) {\r\n    // make sure query has defaults;\r\n    target.metrics = target.metrics || [queryDef.defaultMetricAgg()];\r\n    target.bucketAggs = target.bucketAggs || [queryDef.defaultBucketAgg()];\r\n    target.timeField = this.timeField;\r\n\r\n    let i, j, pv, nestedAggs, metric;\r\n    const query = {\r\n      size: 0,\r\n      query: {\r\n        bool: {\r\n          filter: [\r\n            { range: this.getRangeFilter() },\r\n            {\r\n              query_string: {\r\n                analyze_wildcard: true,\r\n                query: queryString,\r\n              },\r\n            },\r\n          ],\r\n        },\r\n      },\r\n    };\r\n\r\n    this.addAdhocFilters(query, adhocFilters);\r\n\r\n    // handle document query\r\n    if (target.bucketAggs.length === 0) {\r\n      metric = target.metrics[0];\r\n      if (!metric || metric.type !== 'raw_document') {\r\n        throw { message: 'Invalid query' };\r\n      }\r\n\r\n      const size = (metric.settings && metric.settings.size) || 500;\r\n      return this.documentQuery(query, size);\r\n    }\r\n\r\n    nestedAggs = query;\r\n\r\n    for (i = 0; i < target.bucketAggs.length; i++) {\r\n      const aggDef: any = target.bucketAggs[i];\r\n      const esAgg: any = {};\r\n\r\n      switch (aggDef.type) {\r\n        case 'date_histogram': {\r\n          esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\r\n          break;\r\n        }\r\n        case 'histogram': {\r\n          esAgg['histogram'] = this.getHistogramAgg(aggDef);\r\n          break;\r\n        }\r\n        case 'filters': {\r\n          esAgg['filters'] = { filters: this.getFiltersAgg(aggDef) };\r\n          break;\r\n        }\r\n        case 'terms': {\r\n          this.buildTermsAgg(aggDef, esAgg, target);\r\n          break;\r\n        }\r\n        case 'geohash_grid': {\r\n          esAgg['geohash_grid'] = {\r\n            field: aggDef.field,\r\n            precision: aggDef.settings.precision,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n\r\n      nestedAggs.aggs = nestedAggs.aggs || {};\r\n      nestedAggs.aggs[aggDef.id] = esAgg;\r\n      nestedAggs = esAgg;\r\n    }\r\n\r\n    nestedAggs.aggs = {};\r\n\r\n    for (i = 0; i < target.metrics.length; i++) {\r\n      metric = target.metrics[i];\r\n      if (metric.type === 'count') {\r\n        continue;\r\n      }\r\n\r\n      const aggField: any = {};\r\n      let metricAgg: any = null;\r\n\r\n      if (queryDef.isPipelineAgg(metric.type)) {\r\n        if (queryDef.isPipelineAggWithMultipleBucketPaths(metric.type)) {\r\n          if (metric.pipelineVariables) {\r\n            metricAgg = {\r\n              buckets_path: {},\r\n            };\r\n\r\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\r\n              pv = metric.pipelineVariables[j];\r\n\r\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\r\n                const appliedAgg = queryDef.findMetricById(target.metrics, pv.pipelineAgg);\r\n                if (appliedAgg) {\r\n                  if (appliedAgg.type === 'count') {\r\n                    metricAgg.buckets_path[pv.name] = '_count';\r\n                  } else {\r\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            continue;\r\n          }\r\n        } else {\r\n          if (metric.pipelineAgg && /^\\d*$/.test(metric.pipelineAgg)) {\r\n            const appliedAgg = queryDef.findMetricById(target.metrics, metric.pipelineAgg);\r\n            if (appliedAgg) {\r\n              if (appliedAgg.type === 'count') {\r\n                metricAgg = { buckets_path: '_count' };\r\n              } else {\r\n                metricAgg = { buckets_path: metric.pipelineAgg };\r\n              }\r\n            }\r\n          } else {\r\n            continue;\r\n          }\r\n        }\r\n      } else {\r\n        metricAgg = { field: metric.field };\r\n      }\r\n\r\n      for (const prop in metric.settings) {\r\n        if (metric.settings.hasOwnProperty(prop) && metric.settings[prop] !== null) {\r\n          metricAgg[prop] = metric.settings[prop];\r\n        }\r\n      }\r\n\r\n      aggField[metric.type] = metricAgg;\r\n      nestedAggs.aggs[metric.id] = aggField;\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  getTermsQuery(queryDef: any) {\r\n    const query: any = {\r\n      size: 0,\r\n      query: {\r\n        bool: {\r\n          filter: [{ range: this.getRangeFilter() }],\r\n        },\r\n      },\r\n    };\r\n\r\n    if (queryDef.query) {\r\n      query.query.bool.filter.push({\r\n        query_string: {\r\n          analyze_wildcard: true,\r\n          query: queryDef.query,\r\n        },\r\n      });\r\n    }\r\n\r\n    let size = 500;\r\n    if (queryDef.size) {\r\n      size = queryDef.size;\r\n    }\r\n\r\n    query.aggs = {\r\n      '1': {\r\n        terms: {\r\n          field: queryDef.field,\r\n          size: size,\r\n          order: {},\r\n        },\r\n      },\r\n    };\r\n\r\n    // Default behaviour is to order results by { _key: asc }\r\n    // queryDef.order allows selection of asc/desc\r\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\r\n\r\n    const { orderBy = 'key', order = orderBy === 'doc_count' ? 'desc' : 'asc' } = queryDef;\r\n\r\n    if (['asc', 'desc'].indexOf(order) < 0) {\r\n      throw { message: `Invalid query sort order ${order}` };\r\n    }\r\n\r\n    switch (orderBy) {\r\n      case 'key':\r\n      case 'term':\r\n        const keyname = this.esVersion >= 60 ? '_key' : '_term';\r\n        query.aggs['1'].terms.order[keyname] = order;\r\n        break;\r\n      case 'doc_count':\r\n        query.aggs['1'].terms.order['_count'] = order;\r\n        break;\r\n      default:\r\n        throw { message: `Invalid query sort type ${orderBy}` };\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  getLogsQuery(target: any, adhocFilters?: any, querystring?: string) {\r\n    let query: any = {\r\n      size: 0,\r\n      query: {\r\n        bool: {\r\n          filter: [{ range: this.getRangeFilter() }],\r\n        },\r\n      },\r\n    };\r\n\r\n    this.addAdhocFilters(query, adhocFilters);\r\n\r\n    if (target.query) {\r\n      query.query.bool.filter.push({\r\n        query_string: {\r\n          analyze_wildcard: true,\r\n          query: querystring,\r\n        },\r\n      });\r\n    }\r\n\r\n    query = this.documentQuery(query, 500);\r\n\r\n    return {\r\n      ...query,\r\n      aggs: this.build(target, null, querystring).aggs,\r\n    };\r\n  }\r\n}\r\n","import './bucket_agg';\r\nimport './metric_agg';\r\nimport './pipeline_variables';\r\n\r\nimport angular, { auto } from 'angular';\r\nimport _ from 'lodash';\r\nimport * as queryDef from './query_def';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { ElasticsearchAggregation } from './types';\r\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\r\nimport { CoreEvents } from 'app/types';\r\n\r\nexport class ElasticQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  esVersion: any;\r\n  rawQueryOld: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    $scope: any,\r\n    $injector: auto.IInjectorService,\r\n    private $rootScope: GrafanaRootScope,\r\n    private uiSegmentSrv: any\r\n  ) {\r\n    super($scope, $injector);\r\n\r\n    this.esVersion = this.datasource.esVersion;\r\n\r\n    this.target = this.target || {};\r\n    this.target.metrics = this.target.metrics || [queryDef.defaultMetricAgg()];\r\n    this.target.bucketAggs = this.target.bucketAggs || [queryDef.defaultBucketAgg()];\r\n\r\n    if (this.target.bucketAggs.length === 0) {\r\n      const metric = this.target.metrics[0];\r\n      if (!metric || metric.type !== 'raw_document') {\r\n        this.target.bucketAggs = [queryDef.defaultBucketAgg()];\r\n      }\r\n      this.refresh();\r\n    }\r\n\r\n    this.queryUpdated();\r\n  }\r\n\r\n  getFields(type: any) {\r\n    const jsonStr = angular.toJson({ find: 'fields', type: type });\r\n    return this.datasource\r\n      .metricFindQuery(jsonStr)\r\n      .then(this.uiSegmentSrv.transformToSegments(false))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  queryUpdated() {\r\n    const newJson = angular.toJson(this.datasource.queryBuilder.build(this.target), true);\r\n    if (this.rawQueryOld && newJson !== this.rawQueryOld) {\r\n      this.refresh();\r\n    }\r\n\r\n    this.rawQueryOld = newJson;\r\n    this.$rootScope.appEvent(CoreEvents.elasticQueryUpdated);\r\n  }\r\n\r\n  getCollapsedText() {\r\n    const metricAggs: ElasticsearchAggregation[] = this.target.metrics;\r\n    const bucketAggs = this.target.bucketAggs;\r\n    const metricAggTypes = queryDef.getMetricAggTypes(this.esVersion);\r\n    const bucketAggTypes = queryDef.bucketAggTypes;\r\n    let text = '';\r\n\r\n    if (this.target.query) {\r\n      text += 'Query: ' + this.target.query + ', ';\r\n    }\r\n\r\n    text += 'Metrics: ';\r\n\r\n    _.each(metricAggs, (metric, index) => {\r\n      const aggDef: any = _.find(metricAggTypes, { value: metric.type });\r\n      text += aggDef.text + '(';\r\n      if (aggDef.requiresField) {\r\n        text += metric.field;\r\n      }\r\n      if (aggDef.supportsMultipleBucketPaths) {\r\n        text += metric.settings.script.replace(new RegExp('params.', 'g'), '');\r\n      }\r\n      text += '), ';\r\n    });\r\n\r\n    _.each(bucketAggs, (bucketAgg: any, index: number) => {\r\n      if (index === 0) {\r\n        text += ' Group by: ';\r\n      }\r\n\r\n      const aggDef: any = _.find(bucketAggTypes, { value: bucketAgg.type });\r\n      text += aggDef.text + '(';\r\n      if (aggDef.requiresField) {\r\n        text += bucketAgg.field;\r\n      }\r\n      text += '), ';\r\n    });\r\n\r\n    if (this.target.alias) {\r\n      text += 'Alias: ' + this.target.alias;\r\n    }\r\n\r\n    return text;\r\n  }\r\n\r\n  handleQueryError(err: any): any[] {\r\n    this.error = err.message || 'Failed to issue metric query';\r\n    return [];\r\n  }\r\n}\r\n","import _ from 'lodash';\r\n\r\nexport const metricAggTypes = [\r\n  { text: 'Count', value: 'count', requiresField: false },\r\n  {\r\n    text: 'Average',\r\n    value: 'avg',\r\n    requiresField: true,\r\n    supportsInlineScript: true,\r\n    supportsMissing: true,\r\n  },\r\n  {\r\n    text: 'Sum',\r\n    value: 'sum',\r\n    requiresField: true,\r\n    supportsInlineScript: true,\r\n    supportsMissing: true,\r\n  },\r\n  {\r\n    text: 'Max',\r\n    value: 'max',\r\n    requiresField: true,\r\n    supportsInlineScript: true,\r\n    supportsMissing: true,\r\n  },\r\n  {\r\n    text: 'Min',\r\n    value: 'min',\r\n    requiresField: true,\r\n    supportsInlineScript: true,\r\n    supportsMissing: true,\r\n  },\r\n  {\r\n    text: 'Extended Stats',\r\n    value: 'extended_stats',\r\n    requiresField: true,\r\n    supportsMissing: true,\r\n    supportsInlineScript: true,\r\n  },\r\n  {\r\n    text: 'Percentiles',\r\n    value: 'percentiles',\r\n    requiresField: true,\r\n    supportsMissing: true,\r\n    supportsInlineScript: true,\r\n  },\r\n  {\r\n    text: 'Unique Count',\r\n    value: 'cardinality',\r\n    requiresField: true,\r\n    supportsMissing: true,\r\n  },\r\n  {\r\n    text: 'Moving Average',\r\n    value: 'moving_avg',\r\n    requiresField: false,\r\n    isPipelineAgg: true,\r\n    minVersion: 2,\r\n  },\r\n  {\r\n    text: 'Derivative',\r\n    value: 'derivative',\r\n    requiresField: false,\r\n    isPipelineAgg: true,\r\n    minVersion: 2,\r\n  },\r\n  {\r\n    text: 'Bucket Script',\r\n    value: 'bucket_script',\r\n    requiresField: false,\r\n    isPipelineAgg: true,\r\n    supportsMultipleBucketPaths: true,\r\n    minVersion: 2,\r\n  },\r\n  { text: 'Raw Document', value: 'raw_document', requiresField: false },\r\n  { text: 'Logs', value: 'logs', requiresField: false },\r\n];\r\n\r\nexport const bucketAggTypes = [\r\n  { text: 'Terms', value: 'terms', requiresField: true },\r\n  { text: 'Filters', value: 'filters' },\r\n  { text: 'Geo Hash Grid', value: 'geohash_grid', requiresField: true },\r\n  { text: 'Date Histogram', value: 'date_histogram', requiresField: true },\r\n  { text: 'Histogram', value: 'histogram', requiresField: true },\r\n];\r\n\r\nexport const orderByOptions = [\r\n  { text: 'Doc Count', value: '_count' },\r\n  { text: 'Term value', value: '_term' },\r\n];\r\n\r\nexport const orderOptions = [\r\n  { text: 'Top', value: 'desc' },\r\n  { text: 'Bottom', value: 'asc' },\r\n];\r\n\r\nexport const sizeOptions = [\r\n  { text: 'No limit', value: '0' },\r\n  { text: '1', value: '1' },\r\n  { text: '2', value: '2' },\r\n  { text: '3', value: '3' },\r\n  { text: '5', value: '5' },\r\n  { text: '10', value: '10' },\r\n  { text: '15', value: '15' },\r\n  { text: '20', value: '20' },\r\n];\r\n\r\nexport const extendedStats = [\r\n  { text: 'Avg', value: 'avg' },\r\n  { text: 'Min', value: 'min' },\r\n  { text: 'Max', value: 'max' },\r\n  { text: 'Sum', value: 'sum' },\r\n  { text: 'Count', value: 'count' },\r\n  { text: 'Std Dev', value: 'std_deviation' },\r\n  { text: 'Std Dev Upper', value: 'std_deviation_bounds_upper' },\r\n  { text: 'Std Dev Lower', value: 'std_deviation_bounds_lower' },\r\n];\r\n\r\nexport const intervalOptions = [\r\n  { text: 'auto', value: 'auto' },\r\n  { text: '10s', value: '10s' },\r\n  { text: '1m', value: '1m' },\r\n  { text: '5m', value: '5m' },\r\n  { text: '10m', value: '10m' },\r\n  { text: '20m', value: '20m' },\r\n  { text: '1h', value: '1h' },\r\n  { text: '1d', value: '1d' },\r\n];\r\n\r\nexport const movingAvgModelOptions = [\r\n  { text: 'Simple', value: 'simple' },\r\n  { text: 'Linear', value: 'linear' },\r\n  { text: 'Exponentially Weighted', value: 'ewma' },\r\n  { text: 'Holt Linear', value: 'holt' },\r\n  { text: 'Holt Winters', value: 'holt_winters' },\r\n];\r\n\r\nexport const pipelineOptions: any = {\r\n  moving_avg: [\r\n    { text: 'window', default: 5 },\r\n    { text: 'model', default: 'simple' },\r\n    { text: 'predict', default: undefined },\r\n    { text: 'minimize', default: false },\r\n  ],\r\n  derivative: [{ text: 'unit', default: undefined }],\r\n  bucket_script: [],\r\n};\r\n\r\nexport const movingAvgModelSettings: any = {\r\n  simple: [],\r\n  linear: [],\r\n  ewma: [{ text: 'Alpha', value: 'alpha', default: undefined }],\r\n  holt: [\r\n    { text: 'Alpha', value: 'alpha', default: undefined },\r\n    { text: 'Beta', value: 'beta', default: undefined },\r\n  ],\r\n  holt_winters: [\r\n    { text: 'Alpha', value: 'alpha', default: undefined },\r\n    { text: 'Beta', value: 'beta', default: undefined },\r\n    { text: 'Gamma', value: 'gamma', default: undefined },\r\n    { text: 'Period', value: 'period', default: undefined },\r\n    { text: 'Pad', value: 'pad', default: undefined, isCheckbox: true },\r\n  ],\r\n};\r\n\r\nexport function getMetricAggTypes(esVersion: any) {\r\n  return _.filter(metricAggTypes, f => {\r\n    if (f.minVersion) {\r\n      return f.minVersion <= esVersion;\r\n    } else {\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\nexport function getPipelineOptions(metric: any) {\r\n  if (!isPipelineAgg(metric.type)) {\r\n    return [];\r\n  }\r\n\r\n  return pipelineOptions[metric.type];\r\n}\r\n\r\nexport function isPipelineAgg(metricType: any) {\r\n  if (metricType) {\r\n    const po = pipelineOptions[metricType];\r\n    return po !== null && po !== undefined;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function isPipelineAggWithMultipleBucketPaths(metricType: any) {\r\n  if (metricType) {\r\n    return metricAggTypes.find(t => t.value === metricType && t.supportsMultipleBucketPaths) !== undefined;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function getPipelineAggOptions(targets: any) {\r\n  const result: any[] = [];\r\n  _.each(targets.metrics, metric => {\r\n    if (!isPipelineAgg(metric.type)) {\r\n      result.push({ text: describeMetric(metric), value: metric.id });\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexport function getMovingAvgSettings(model: any, filtered: boolean) {\r\n  const filteredResult: any[] = [];\r\n  if (filtered) {\r\n    _.each(movingAvgModelSettings[model], setting => {\r\n      if (!setting.isCheckbox) {\r\n        filteredResult.push(setting);\r\n      }\r\n    });\r\n    return filteredResult;\r\n  }\r\n  return movingAvgModelSettings[model];\r\n}\r\n\r\nexport function getOrderByOptions(target: any) {\r\n  const metricRefs: any[] = [];\r\n  _.each(target.metrics, metric => {\r\n    if (metric.type !== 'count') {\r\n      metricRefs.push({ text: describeMetric(metric), value: metric.id });\r\n    }\r\n  });\r\n\r\n  return orderByOptions.concat(metricRefs);\r\n}\r\n\r\nexport function describeOrder(order: string) {\r\n  const def: any = _.find(orderOptions, { value: order });\r\n  return def.text;\r\n}\r\n\r\nexport function describeMetric(metric: { type: string; field: string }) {\r\n  const def: any = _.find(metricAggTypes, { value: metric.type });\r\n  if (!def.requiresField && !isPipelineAgg(metric.type)) {\r\n    return def.text;\r\n  }\r\n  return def.text + ' ' + metric.field;\r\n}\r\n\r\nexport function describeOrderBy(orderBy: any, target: any) {\r\n  const def: any = _.find(orderByOptions, { value: orderBy });\r\n  if (def) {\r\n    return def.text;\r\n  }\r\n  const metric: any = _.find(target.metrics, { id: orderBy });\r\n  if (metric) {\r\n    return describeMetric(metric);\r\n  } else {\r\n    return 'metric not found';\r\n  }\r\n}\r\n\r\nexport function defaultMetricAgg() {\r\n  return { type: 'count', id: '1' };\r\n}\r\n\r\nexport function defaultBucketAgg() {\r\n  return { type: 'date_histogram', id: '2', settings: { interval: 'auto' } };\r\n}\r\n\r\nexport const findMetricById = (metrics: any[], id: any) => {\r\n  return _.find(metrics, { id: id });\r\n};\r\n\r\nexport function hasMetricOfType(target: any, type: string): boolean {\r\n  return target && target.metrics && target.metrics.some((m: any) => m.type === type);\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;ACrOA;AAEA;AAWA;AAAA;AAGA;AAAA;AA8BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtCA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAWA;AAGA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAYA;AAEA;AAEA;AAOA;AAEA;AAGA;AAAA;AAOA;AAGA;AAOA;AAIA;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AAGA;AACA;AAGA;AAGA;AAGA;AASA;AACA;AACA;AAEA;;AACA;AAIA;AAEA;AAEA;AACA;AAGA;AACA;AAOA;AAKA;AACA;AACA;AAIA;AAQA;AAAA;AAcA;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AAGA;AAEA;AACA;AAIA;AAGA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAOA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAWA;AACA;AASA;AAAA;AAQA;AACA;AAUA;AACA;AACA;AAOA;AAIA;AAQA;AAOA;AAEA;AASA;AACA;AACA;AAUA;AACA;AAIA;AAEA;;AAKA;AACA;AAQA;AAEA;;AAKA;AAIA;AAEA;;AAGA;AAOA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5NA;AACA;AAOA;AACA;AACA;;AAGA;AAIA;AAEA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAgBA;AACA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAXA;AAAA;AAAA;AAYA;;;;;;;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACxmBA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;;AAEA;AAAA;AACA;AACA;;;;;;;;;AAEA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;;;;;;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;;AAQA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;;;;;;;;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;AACA;AAAA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC3gBA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC7CA;AAGA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzZA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAMA;AACA;AAAA;AAGA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAjGA;AAkGA;AAAA;AAnGA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}