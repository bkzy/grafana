{"version":3,"file":"graphitePlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/core/utils/version.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/MetricTankMetaInspector.tsx","webpack:///webpack:///./public/app/plugins/datasource/graphite/add_graphite_func.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/configuration/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/graphite/configuration/GraphiteDetails.tsx","webpack:///webpack:///./public/app/plugins/datasource/graphite/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/func_editor.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/gfunc.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/graphite_query.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/lexer.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/meta.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/module.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/parser.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/graphite/types.ts"],"sourcesContent":["import _ from 'lodash';\r\n\r\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\r\n\r\nexport class SemVersion {\r\n  major: number;\r\n  minor: number;\r\n  patch: number;\r\n  meta: string;\r\n\r\n  constructor(version: string) {\r\n    const match = versionPattern.exec(version);\r\n    if (match) {\r\n      this.major = Number(match[1]);\r\n      this.minor = Number(match[2] || 0);\r\n      this.patch = Number(match[3] || 0);\r\n      this.meta = match[4];\r\n    }\r\n  }\r\n\r\n  isGtOrEq(version: string): boolean {\r\n    const compared = new SemVersion(version);\r\n\r\n    for (let i = 0; i < this.comparable.length; ++i) {\r\n      if (this.comparable[i] > compared.comparable[i]) {\r\n        return true;\r\n      }\r\n      if (this.comparable[i] < compared.comparable[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  isValid(): boolean {\r\n    return _.isNumber(this.major);\r\n  }\r\n\r\n  get comparable() {\r\n    return [this.major, this.minor, this.patch];\r\n  }\r\n}\r\n\r\nexport function isVersionGtOrEq(a: string, b: string): boolean {\r\n  const aSemver = new SemVersion(a);\r\n  return aSemver.isGtOrEq(b);\r\n}\r\n","import React, { PureComponent } from 'react';\r\nimport { MetadataInspectorProps, DataFrame } from '@grafana/data';\r\nimport { GraphiteDatasource } from './datasource';\r\nimport { GraphiteQuery, GraphiteOptions, MetricTankMeta, MetricTankResultMeta } from './types';\r\nimport { parseSchemaRetentions } from './meta';\r\n\r\nexport type Props = MetadataInspectorProps<GraphiteDatasource, GraphiteQuery, GraphiteOptions>;\r\n\r\nexport interface State {\r\n  index: number;\r\n}\r\n\r\nexport class MetricTankMetaInspector extends PureComponent<Props, State> {\r\n  state = { index: 0 };\r\n\r\n  renderInfo = (info: MetricTankResultMeta, frame: DataFrame) => {\r\n    const buckets = parseSchemaRetentions(info['schema-retentions']);\r\n    return (\r\n      <div>\r\n        <h3>Info</h3>\r\n        <table>\r\n          <tbody>\r\n            {buckets.map(row => (\r\n              <tr key={row.interval}>\r\n                <td>{row.interval} &nbsp;</td>\r\n                <td>{row.retention} &nbsp;</td>\r\n                <td>{row.chunkspan} &nbsp;</td>\r\n                <td>{row.numchunks} &nbsp;</td>\r\n                <td>{row.ready} &nbsp;</td>\r\n              </tr>\r\n            ))}\r\n          </tbody>\r\n        </table>\r\n        <pre>{JSON.stringify(info, null, 2)}</pre>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    const { data } = this.props;\r\n    if (!data || !data.length) {\r\n      return <div>No Metadata</div>;\r\n    }\r\n\r\n    const frame = data[this.state.index];\r\n    const meta = frame.meta?.custom as MetricTankMeta;\r\n    if (!meta || !meta.info) {\r\n      return <>No Metadatata on DataFrame</>;\r\n    }\r\n    return (\r\n      <div>\r\n        <h3>MetricTank Request</h3>\r\n        <pre>{JSON.stringify(meta.request, null, 2)}</pre>\r\n        {meta.info.map(info => this.renderInfo(info, frame))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport $ from 'jquery';\r\n// @ts-ignore\r\nimport Drop from 'tether-drop';\r\nimport coreModule from 'app/core/core_module';\r\nimport { FuncDef } from './gfunc';\r\n\r\n/** @ngInject */\r\nexport function graphiteAddFunc($compile: any) {\r\n  const inputTemplate =\r\n    '<input type=\"text\"' + ' class=\"gf-form-input\"' + ' spellcheck=\"false\" style=\"display:none\"></input>';\r\n\r\n  const buttonTemplate =\r\n    '<a class=\"gf-form-label query-part dropdown-toggle\"' +\r\n    ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\r\n    '<i class=\"fa fa-plus\"></i></a>';\r\n\r\n  return {\r\n    link: function($scope: any, elem: JQuery) {\r\n      const ctrl = $scope.ctrl;\r\n\r\n      const $input = $(inputTemplate);\r\n      const $button = $(buttonTemplate);\r\n\r\n      $input.appendTo(elem);\r\n      $button.appendTo(elem);\r\n\r\n      ctrl.datasource.getFuncDefs().then((funcDefs: FuncDef[]) => {\r\n        const allFunctions = _.map(funcDefs, 'name').sort();\r\n\r\n        $scope.functionMenu = createFunctionDropDownMenu(funcDefs);\r\n\r\n        $input.attr('data-provide', 'typeahead');\r\n        $input.typeahead({\r\n          source: allFunctions,\r\n          minLength: 1,\r\n          items: 10,\r\n          updater: (value: any) => {\r\n            let funcDef: any = ctrl.datasource.getFuncDef(value);\r\n            if (!funcDef) {\r\n              // try find close match\r\n              value = value.toLowerCase();\r\n              funcDef = _.find(allFunctions, funcName => {\r\n                return funcName.toLowerCase().indexOf(value) === 0;\r\n              });\r\n\r\n              if (!funcDef) {\r\n                return '';\r\n              }\r\n            }\r\n\r\n            $scope.$apply(() => {\r\n              ctrl.addFunction(funcDef);\r\n            });\r\n\r\n            $input.trigger('blur');\r\n            return '';\r\n          },\r\n        });\r\n\r\n        $button.click(() => {\r\n          $button.hide();\r\n          $input.show();\r\n          $input.focus();\r\n        });\r\n\r\n        $input.keyup(() => {\r\n          elem.toggleClass('open', $input.val() === '');\r\n        });\r\n\r\n        $input.blur(() => {\r\n          // clicking the function dropdown menu won't\r\n          // work if you remove class at once\r\n          setTimeout(() => {\r\n            $input.val('');\r\n            $input.hide();\r\n            $button.show();\r\n            elem.removeClass('open');\r\n          }, 200);\r\n        });\r\n\r\n        $compile(elem.contents())($scope);\r\n      });\r\n\r\n      let drop: any;\r\n      const cleanUpDrop = () => {\r\n        if (drop) {\r\n          drop.destroy();\r\n          drop = null;\r\n        }\r\n      };\r\n\r\n      $(elem)\r\n        .on('mouseenter', 'ul.dropdown-menu li', async () => {\r\n          cleanUpDrop();\r\n\r\n          let funcDef;\r\n          try {\r\n            funcDef = ctrl.datasource.getFuncDef($('a', this).text());\r\n          } catch (e) {\r\n            // ignore\r\n          }\r\n\r\n          if (funcDef && funcDef.description) {\r\n            let shortDesc = funcDef.description;\r\n            if (shortDesc.length > 500) {\r\n              shortDesc = shortDesc.substring(0, 497) + '...';\r\n            }\r\n\r\n            const contentElement = document.createElement('div');\r\n            // @ts-ignore\r\n            const { default: rst2html } = await import(/* webpackChunkName: \"rst2html\" */ 'rst2html');\r\n            contentElement.innerHTML = '<h4>' + funcDef.name + '</h4>' + rst2html(shortDesc);\r\n\r\n            drop = new Drop({\r\n              target: this,\r\n              content: contentElement,\r\n              classes: 'drop-popover',\r\n              openOn: 'always',\r\n              tetherOptions: {\r\n                attachment: 'bottom left',\r\n                targetAttachment: 'bottom right',\r\n              },\r\n            });\r\n          }\r\n        })\r\n        .on('mouseout', 'ul.dropdown-menu li', () => {\r\n          cleanUpDrop();\r\n        });\r\n\r\n      $scope.$on('$destroy', cleanUpDrop);\r\n    },\r\n  };\r\n}\r\n\r\ncoreModule.directive('graphiteAddFunc', graphiteAddFunc);\r\n\r\nfunction createFunctionDropDownMenu(funcDefs: FuncDef[]) {\r\n  const categories: any = {};\r\n\r\n  _.forEach(funcDefs, funcDef => {\r\n    if (!funcDef.category) {\r\n      return;\r\n    }\r\n    if (!categories[funcDef.category]) {\r\n      categories[funcDef.category] = [];\r\n    }\r\n    categories[funcDef.category].push({\r\n      text: funcDef.name,\r\n      click: \"ctrl.addFunction('\" + funcDef.name + \"')\",\r\n    });\r\n  });\r\n\r\n  return _.sortBy(\r\n    _.map(categories, (submenu, category) => {\r\n      return {\r\n        text: category,\r\n        submenu: _.sortBy(submenu, 'text'),\r\n      };\r\n    }),\r\n    'text'\r\n  );\r\n}\r\n","import React from 'react';\r\nimport { DataSourceHttpSettings } from '@grafana/ui';\r\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\r\nimport { GraphiteDetails } from './GraphiteDetails';\r\nimport { GraphiteOptions } from '../types';\r\n\r\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<GraphiteOptions>) => {\r\n  const { options, onOptionsChange } = props;\r\n\r\n  return (\r\n    <>\r\n      <DataSourceHttpSettings\r\n        defaultUrl=\"http://localhost:8080\"\r\n        dataSourceConfig={options}\r\n        onChange={onOptionsChange}\r\n      />\r\n      <GraphiteDetails value={options} onChange={onOptionsChange} />\r\n    </>\r\n  );\r\n};\r\n","import React, { PureComponent } from 'react';\r\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\r\nimport { Button, FormLabel, Select } from '@grafana/ui';\r\nimport { GraphiteOptions, GraphiteType } from '../types';\r\n\r\nconst graphiteVersions = [\r\n  { label: '0.9.x', value: '0.9' },\r\n  { label: '1.0.x', value: '1.0' },\r\n  { label: '1.1.x', value: '1.1' },\r\n];\r\n\r\nconst graphiteTypes = Object.keys(GraphiteType).map((key: string) => ({\r\n  label: key,\r\n  value: (GraphiteType as any)[key],\r\n}));\r\n\r\ninterface Props {\r\n  value: DataSourceSettings<GraphiteOptions>;\r\n  onChange: (value: DataSourceSettings<GraphiteOptions>) => void;\r\n}\r\n\r\ninterface State {\r\n  showMetricTankHelp: boolean;\r\n}\r\n\r\nexport class GraphiteDetails extends PureComponent<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      showMetricTankHelp: false,\r\n    };\r\n  }\r\n\r\n  onChangeHandler = (key: keyof GraphiteOptions) => (newValue: SelectableValue) => {\r\n    const { value, onChange } = this.props;\r\n    onChange({\r\n      ...value,\r\n      jsonData: {\r\n        ...value.jsonData,\r\n        [key]: newValue.value,\r\n      },\r\n    });\r\n  };\r\n\r\n  render() {\r\n    const { value } = this.props;\r\n    const { showMetricTankHelp } = this.state;\r\n\r\n    const currentVersion =\r\n      graphiteVersions.find(item => item.value === value.jsonData.graphiteVersion) ?? graphiteVersions[2];\r\n\r\n    return (\r\n      <>\r\n        <h3 className=\"page-heading\">Graphite details</h3>\r\n        <div className=\"gf-form-group\">\r\n          <div className=\"gf-form\">\r\n            <FormLabel tooltip=\"This option controls what functions are available in the Graphite query editor.\">\r\n              Version\r\n            </FormLabel>\r\n            <Select\r\n              value={currentVersion}\r\n              options={graphiteVersions}\r\n              width={8}\r\n              onChange={this.onChangeHandler('graphiteVersion')}\r\n            />\r\n          </div>\r\n          <div className=\"gf-form-inline\">\r\n            <FormLabel>Type</FormLabel>\r\n            <Select\r\n              options={graphiteTypes}\r\n              value={graphiteTypes.find(type => type.value === value.jsonData.graphiteType)}\r\n              width={8}\r\n              onChange={this.onChangeHandler('graphiteType')}\r\n            />\r\n\r\n            <Button\r\n              style={{ marginLeft: '8px', marginTop: '5px' }}\r\n              variant=\"secondary\"\r\n              size=\"sm\"\r\n              onClick={() =>\r\n                this.setState((prevState: State) => ({ showMetricTankHelp: !prevState.showMetricTankHelp }))\r\n              }\r\n            >\r\n              Help <i className={showMetricTankHelp ? 'fa fa-caret-down' : 'fa fa-caret-right'} />\r\n            </Button>\r\n          </div>\r\n          {showMetricTankHelp && (\r\n            <div className=\"grafana-info-box m-t-2\">\r\n              <div className=\"alert-body\">\r\n                <p>\r\n                  There are different types of Graphite compatible backends. Here you can specify the type you are\r\n                  using. If you are using{' '}\r\n                  <a href=\"https://github.com/grafana/metrictank\" className=\"pointer\" target=\"_blank\">\r\n                    Metrictank\r\n                  </a>{' '}\r\n                  then select that here. This will enable Metrictank specific features like query processing meta data.\r\n                  Metrictank is a multi-tenant timeseries engine for Graphite and friends.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport {\r\n  DataFrame,\r\n  dateMath,\r\n  ScopedVars,\r\n  DataQueryResponse,\r\n  DataQueryRequest,\r\n  toDataFrame,\r\n  DataSourceApi,\r\n} from '@grafana/data';\r\nimport { isVersionGtOrEq, SemVersion } from 'app/core/utils/version';\r\nimport gfunc from './gfunc';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n//Types\r\nimport { GraphiteOptions, GraphiteQuery, GraphiteType } from './types';\r\nimport { getSearchFilterScopedVar } from '../../../features/templating/variable';\r\n\r\nexport class GraphiteDatasource extends DataSourceApi<GraphiteQuery, GraphiteOptions> {\r\n  basicAuth: string;\r\n  url: string;\r\n  name: string;\r\n  graphiteVersion: any;\r\n  supportsTags: boolean;\r\n  isMetricTank: boolean;\r\n  cacheTimeout: any;\r\n  withCredentials: boolean;\r\n  funcDefs: any = null;\r\n  funcDefsPromise: Promise<any> = null;\r\n  _seriesRefLetters: string;\r\n\r\n  /** @ngInject */\r\n  constructor(instanceSettings: any, private backendSrv: BackendSrv, private templateSrv: TemplateSrv) {\r\n    super(instanceSettings);\r\n    this.basicAuth = instanceSettings.basicAuth;\r\n    this.url = instanceSettings.url;\r\n    this.name = instanceSettings.name;\r\n    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || '0.9';\r\n    this.isMetricTank = instanceSettings.jsonData.graphiteType === GraphiteType.Metrictank;\r\n    this.supportsTags = supportsTags(this.graphiteVersion);\r\n    this.cacheTimeout = instanceSettings.cacheTimeout;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    this.funcDefs = null;\r\n    this.funcDefsPromise = null;\r\n    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n  }\r\n\r\n  getQueryOptionsInfo() {\r\n    return {\r\n      maxDataPoints: true,\r\n      cacheTimeout: true,\r\n      links: [\r\n        {\r\n          text: 'Help',\r\n          url: 'http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana',\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  async query(options: DataQueryRequest<GraphiteQuery>): Promise<DataQueryResponse> {\r\n    const graphOptions = {\r\n      from: this.translateTime(options.rangeRaw.from, false, options.timezone),\r\n      until: this.translateTime(options.rangeRaw.to, true, options.timezone),\r\n      targets: options.targets,\r\n      format: (options as any).format,\r\n      cacheTimeout: options.cacheTimeout || this.cacheTimeout,\r\n      maxDataPoints: options.maxDataPoints,\r\n    };\r\n\r\n    const params = this.buildGraphiteParams(graphOptions, options.scopedVars);\r\n    if (params.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    if (this.isMetricTank) {\r\n      params.push('meta=true');\r\n    }\r\n\r\n    const httpOptions: any = {\r\n      method: 'POST',\r\n      url: '/render',\r\n      data: params.join('&'),\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n      },\r\n    };\r\n\r\n    this.addTracingHeaders(httpOptions, options);\r\n\r\n    if (options.panelId) {\r\n      httpOptions.requestId = this.name + '.panelId.' + options.panelId;\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then(this.convertResponseToDataFrames);\r\n  }\r\n\r\n  addTracingHeaders(httpOptions: { headers: any }, options: { dashboardId: any; panelId: any }) {\r\n    const proxyMode = !this.url.match(/^http/);\r\n    if (proxyMode) {\r\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\r\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\r\n    }\r\n  }\r\n\r\n  convertResponseToDataFrames = (result: any): DataQueryResponse => {\r\n    const data: DataFrame[] = [];\r\n    if (!result || !result.data) {\r\n      return { data };\r\n    }\r\n    // Series are either at the root or under a node called 'series'\r\n    const series = result.data.series || result.data;\r\n    if (!_.isArray(series)) {\r\n      throw { message: 'Missing series in result', data: result };\r\n    }\r\n\r\n    for (let i = 0; i < series.length; i++) {\r\n      const s = series[i];\r\n      for (let y = 0; y < s.datapoints.length; y++) {\r\n        s.datapoints[y][1] *= 1000;\r\n      }\r\n      const frame = toDataFrame(s);\r\n\r\n      // Metrictank metadata\r\n      if (s.meta) {\r\n        frame.meta = {\r\n          datasource: this.name,\r\n          custom: {\r\n            request: result.data.meta, // info for the whole request\r\n            info: s.meta, // Array of metadata\r\n          },\r\n        };\r\n      }\r\n      data.push(frame);\r\n    }\r\n    return { data };\r\n  };\r\n\r\n  parseTags(tagString: string) {\r\n    let tags: string[] = [];\r\n    tags = tagString.split(',');\r\n    if (tags.length === 1) {\r\n      tags = tagString.split(' ');\r\n      if (tags[0] === '') {\r\n        tags = [];\r\n      }\r\n    }\r\n    return tags;\r\n  }\r\n\r\n  interpolateVariablesInQueries(queries: GraphiteQuery[], scopedVars: ScopedVars): GraphiteQuery[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          target: this.templateSrv.replace(query.target, scopedVars),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    // Graphite metric as annotation\r\n    if (options.annotation.target) {\r\n      const target = this.templateSrv.replace(options.annotation.target, {}, 'glob');\r\n      const graphiteQuery = ({\r\n        rangeRaw: options.rangeRaw,\r\n        targets: [{ target: target }],\r\n        format: 'json',\r\n        maxDataPoints: 100,\r\n      } as unknown) as DataQueryRequest<GraphiteQuery>;\r\n\r\n      return this.query(graphiteQuery).then(result => {\r\n        const list = [];\r\n\r\n        for (let i = 0; i < result.data.length; i++) {\r\n          const target = result.data[i];\r\n\r\n          for (let y = 0; y < target.length; y++) {\r\n            const time = target.fields[1].values.get(y);\r\n            const value = target.fields[0].values.get(y);\r\n\r\n            if (!value) {\r\n              continue;\r\n            }\r\n\r\n            list.push({\r\n              annotation: options.annotation,\r\n              time,\r\n              title: target.name,\r\n            });\r\n          }\r\n        }\r\n\r\n        return list;\r\n      });\r\n    } else {\r\n      // Graphite event as annotation\r\n      const tags = this.templateSrv.replace(options.annotation.tags);\r\n      return this.events({ range: options.rangeRaw, tags: tags }).then((results: any) => {\r\n        const list = [];\r\n        for (let i = 0; i < results.data.length; i++) {\r\n          const e = results.data[i];\r\n\r\n          let tags = e.tags;\r\n          if (_.isString(e.tags)) {\r\n            tags = this.parseTags(e.tags);\r\n          }\r\n\r\n          list.push({\r\n            annotation: options.annotation,\r\n            time: e.when * 1000,\r\n            title: e.what,\r\n            tags: tags,\r\n            text: e.data,\r\n          });\r\n        }\r\n\r\n        return list;\r\n      });\r\n    }\r\n  }\r\n\r\n  events(options: { range: any; tags: any; timezone?: any }) {\r\n    try {\r\n      let tags = '';\r\n      if (options.tags) {\r\n        tags = '&tags=' + options.tags;\r\n      }\r\n      return this.doGraphiteRequest({\r\n        method: 'GET',\r\n        url:\r\n          '/events/get_data?from=' +\r\n          this.translateTime(options.range.from, false, options.timezone) +\r\n          '&until=' +\r\n          this.translateTime(options.range.to, true, options.timezone) +\r\n          tags,\r\n      });\r\n    } catch (err) {\r\n      return Promise.reject(err);\r\n    }\r\n  }\r\n\r\n  targetContainsTemplate(target: GraphiteQuery) {\r\n    return this.templateSrv.variableExists(target.target);\r\n  }\r\n\r\n  translateTime(date: any, roundUp: any, timezone: any) {\r\n    if (_.isString(date)) {\r\n      if (date === 'now') {\r\n        return 'now';\r\n      } else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {\r\n        date = date.substring(3);\r\n        date = date.replace('m', 'min');\r\n        date = date.replace('M', 'mon');\r\n        return date;\r\n      }\r\n      date = dateMath.parse(date, roundUp, timezone);\r\n    }\r\n\r\n    // graphite' s from filter is exclusive\r\n    // here we step back one minute in order\r\n    // to guarantee that we get all the data that\r\n    // exists for the specified range\r\n    if (roundUp) {\r\n      if (date.get('s')) {\r\n        date.add(1, 's');\r\n      }\r\n    } else if (roundUp === false) {\r\n      if (date.get('s')) {\r\n        date.subtract(1, 's');\r\n      }\r\n    }\r\n\r\n    return date.unix();\r\n  }\r\n\r\n  metricFindQuery(query: string, optionalOptions: any) {\r\n    const options: any = optionalOptions || {};\r\n    let interpolatedQuery = this.templateSrv.replace(\r\n      query,\r\n      getSearchFilterScopedVar({ query, wildcardChar: '', options: optionalOptions })\r\n    );\r\n\r\n    // special handling for tag_values(<tag>[,<expression>]*), this is used for template variables\r\n    let matches = interpolatedQuery.match(/^tag_values\\(([^,]+)((, *[^,]+)*)\\)$/);\r\n    if (matches) {\r\n      const expressions = [];\r\n      const exprRegex = /, *([^,]+)/g;\r\n      let match = exprRegex.exec(matches[2]);\r\n      while (match !== null) {\r\n        expressions.push(match[1]);\r\n        match = exprRegex.exec(matches[2]);\r\n      }\r\n      options.limit = 10000;\r\n      return this.getTagValuesAutoComplete(expressions, matches[1], undefined, options);\r\n    }\r\n\r\n    // special handling for tags(<expression>[,<expression>]*), this is used for template variables\r\n    matches = interpolatedQuery.match(/^tags\\(([^,]*)((, *[^,]+)*)\\)$/);\r\n    if (matches) {\r\n      const expressions = [];\r\n      if (matches[1]) {\r\n        expressions.push(matches[1]);\r\n        const exprRegex = /, *([^,]+)/g;\r\n        let match = exprRegex.exec(matches[2]);\r\n        while (match !== null) {\r\n          expressions.push(match[1]);\r\n          match = exprRegex.exec(matches[2]);\r\n        }\r\n      }\r\n      options.limit = 10000;\r\n      return this.getTagsAutoComplete(expressions, undefined, options);\r\n    }\r\n\r\n    interpolatedQuery = this.templateSrv.replace(\r\n      query,\r\n      getSearchFilterScopedVar({ query, wildcardChar: '*', options: optionalOptions })\r\n    );\r\n\r\n    const httpOptions: any = {\r\n      method: 'POST',\r\n      url: '/metrics/find',\r\n      params: {},\r\n      data: `query=${interpolatedQuery}`,\r\n      headers: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n      },\r\n      // for cancellations\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    if (options.range) {\r\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\r\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\r\n      return _.map(results.data, metric => {\r\n        return {\r\n          text: metric.text,\r\n          expandable: metric.expandable ? true : false,\r\n        };\r\n      });\r\n    });\r\n  }\r\n\r\n  getTags(optionalOptions: any) {\r\n    const options = optionalOptions || {};\r\n\r\n    const httpOptions: any = {\r\n      method: 'GET',\r\n      url: '/tags',\r\n      // for cancellations\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    if (options.range) {\r\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\r\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\r\n      return _.map(results.data, tag => {\r\n        return {\r\n          text: tag.tag,\r\n          id: tag.id,\r\n        };\r\n      });\r\n    });\r\n  }\r\n\r\n  getTagValues(options: any = {}) {\r\n    const httpOptions: any = {\r\n      method: 'GET',\r\n      url: '/tags/' + this.templateSrv.replace(options.key),\r\n      // for cancellations\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    if (options.range) {\r\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\r\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\r\n      if (results.data && results.data.values) {\r\n        return _.map(results.data.values, value => {\r\n          return {\r\n            text: value.value,\r\n            id: value.id,\r\n          };\r\n        });\r\n      } else {\r\n        return [];\r\n      }\r\n    });\r\n  }\r\n\r\n  getTagsAutoComplete(expressions: any[], tagPrefix: any, optionalOptions: any) {\r\n    const options = optionalOptions || {};\r\n\r\n    const httpOptions: any = {\r\n      method: 'GET',\r\n      url: '/tags/autoComplete/tags',\r\n      params: {\r\n        expr: _.map(expressions, expression => this.templateSrv.replace((expression || '').trim())),\r\n      },\r\n      // for cancellations\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    if (tagPrefix) {\r\n      httpOptions.params.tagPrefix = tagPrefix;\r\n    }\r\n    if (options.limit) {\r\n      httpOptions.params.limit = options.limit;\r\n    }\r\n    if (options.range) {\r\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\r\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\r\n      if (results.data) {\r\n        return _.map(results.data, tag => {\r\n          return { text: tag };\r\n        });\r\n      } else {\r\n        return [];\r\n      }\r\n    });\r\n  }\r\n\r\n  getTagValuesAutoComplete(expressions: any[], tag: any, valuePrefix: any, optionalOptions: any) {\r\n    const options = optionalOptions || {};\r\n\r\n    const httpOptions: any = {\r\n      method: 'GET',\r\n      url: '/tags/autoComplete/values',\r\n      params: {\r\n        expr: _.map(expressions, expression => this.templateSrv.replace((expression || '').trim())),\r\n        tag: this.templateSrv.replace((tag || '').trim()),\r\n      },\r\n      // for cancellations\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    if (valuePrefix) {\r\n      httpOptions.params.valuePrefix = valuePrefix;\r\n    }\r\n    if (options.limit) {\r\n      httpOptions.params.limit = options.limit;\r\n    }\r\n    if (options.range) {\r\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\r\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\r\n    }\r\n\r\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\r\n      if (results.data) {\r\n        return _.map(results.data, value => {\r\n          return { text: value };\r\n        });\r\n      } else {\r\n        return [];\r\n      }\r\n    });\r\n  }\r\n\r\n  getVersion(optionalOptions: any) {\r\n    const options = optionalOptions || {};\r\n\r\n    const httpOptions = {\r\n      method: 'GET',\r\n      url: '/version',\r\n      requestId: options.requestId,\r\n    };\r\n\r\n    return this.doGraphiteRequest(httpOptions)\r\n      .then((results: any) => {\r\n        if (results.data) {\r\n          const semver = new SemVersion(results.data);\r\n          return semver.isValid() ? results.data : '';\r\n        }\r\n        return '';\r\n      })\r\n      .catch(() => {\r\n        return '';\r\n      });\r\n  }\r\n\r\n  createFuncInstance(funcDef: any, options?: any) {\r\n    return gfunc.createFuncInstance(funcDef, options, this.funcDefs);\r\n  }\r\n\r\n  getFuncDef(name: string) {\r\n    return gfunc.getFuncDef(name, this.funcDefs);\r\n  }\r\n\r\n  waitForFuncDefsLoaded() {\r\n    return this.getFuncDefs();\r\n  }\r\n\r\n  getFuncDefs() {\r\n    if (this.funcDefsPromise !== null) {\r\n      return this.funcDefsPromise;\r\n    }\r\n\r\n    if (!supportsFunctionIndex(this.graphiteVersion)) {\r\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\r\n      this.funcDefsPromise = Promise.resolve(this.funcDefs);\r\n      return this.funcDefsPromise;\r\n    }\r\n\r\n    const httpOptions = {\r\n      method: 'GET',\r\n      url: '/functions',\r\n    };\r\n\r\n    this.funcDefsPromise = this.doGraphiteRequest(httpOptions)\r\n      .then((results: any) => {\r\n        if (results.status !== 200 || typeof results.data !== 'object') {\r\n          this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\r\n        } else {\r\n          this.funcDefs = gfunc.parseFuncDefs(results.data);\r\n        }\r\n        return this.funcDefs;\r\n      })\r\n      .catch((err: any) => {\r\n        console.log('Fetching graphite functions error', err);\r\n        this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\r\n        return this.funcDefs;\r\n      });\r\n\r\n    return this.funcDefsPromise;\r\n  }\r\n\r\n  testDatasource() {\r\n    const query = ({\r\n      panelId: 3,\r\n      rangeRaw: { from: 'now-1h', to: 'now' },\r\n      targets: [{ target: 'constantLine(100)' }],\r\n      maxDataPoints: 300,\r\n    } as unknown) as DataQueryRequest<GraphiteQuery>;\r\n    return this.query(query).then(() => {\r\n      return { status: 'success', message: 'Data source is working' };\r\n    });\r\n  }\r\n\r\n  doGraphiteRequest(options: {\r\n    method?: string;\r\n    url: any;\r\n    requestId?: any;\r\n    withCredentials?: any;\r\n    headers?: any;\r\n    inspect?: any;\r\n  }) {\r\n    if (this.basicAuth || this.withCredentials) {\r\n      options.withCredentials = true;\r\n    }\r\n    if (this.basicAuth) {\r\n      options.headers = options.headers || {};\r\n      options.headers.Authorization = this.basicAuth;\r\n    }\r\n\r\n    options.url = this.url + options.url;\r\n    options.inspect = { type: 'graphite' };\r\n\r\n    return this.backendSrv.datasourceRequest(options);\r\n  }\r\n\r\n  buildGraphiteParams(options: any, scopedVars: ScopedVars): string[] {\r\n    const graphiteOptions = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\r\n    const cleanOptions = [],\r\n      targets: any = {};\r\n    let target, targetValue, i;\r\n    const regex = /\\#([A-Z])/g;\r\n    const intervalFormatFixRegex = /'(\\d+)m'/gi;\r\n    let hasTargets = false;\r\n\r\n    options['format'] = 'json';\r\n\r\n    function fixIntervalFormat(match: any) {\r\n      return match.replace('m', 'min').replace('M', 'mon');\r\n    }\r\n\r\n    for (i = 0; i < options.targets.length; i++) {\r\n      target = options.targets[i];\r\n      if (!target.target) {\r\n        continue;\r\n      }\r\n\r\n      if (!target.refId) {\r\n        target.refId = this._seriesRefLetters[i];\r\n      }\r\n\r\n      targetValue = this.templateSrv.replace(target.target, scopedVars);\r\n      targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\r\n      targets[target.refId] = targetValue;\r\n    }\r\n\r\n    function nestedSeriesRegexReplacer(match: any, g1: string | number) {\r\n      return targets[g1] || match;\r\n    }\r\n\r\n    for (i = 0; i < options.targets.length; i++) {\r\n      target = options.targets[i];\r\n      if (!target.target) {\r\n        continue;\r\n      }\r\n\r\n      targetValue = targets[target.refId];\r\n      targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\r\n      targets[target.refId] = targetValue;\r\n\r\n      if (!target.hide) {\r\n        hasTargets = true;\r\n        cleanOptions.push('target=' + encodeURIComponent(targetValue));\r\n      }\r\n    }\r\n\r\n    _.each(options, (value, key) => {\r\n      if (_.indexOf(graphiteOptions, key) === -1) {\r\n        return;\r\n      }\r\n      if (value) {\r\n        cleanOptions.push(key + '=' + encodeURIComponent(value));\r\n      }\r\n    });\r\n\r\n    if (!hasTargets) {\r\n      return [];\r\n    }\r\n\r\n    return cleanOptions;\r\n  }\r\n}\r\n\r\nfunction supportsTags(version: string): boolean {\r\n  return isVersionGtOrEq(version, '1.1');\r\n}\r\n\r\nfunction supportsFunctionIndex(version: string): boolean {\r\n  return isVersionGtOrEq(version, '1.1');\r\n}\r\n","import _ from 'lodash';\r\nimport $ from 'jquery';\r\nimport coreModule from 'app/core/core_module';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\n/** @ngInject */\r\nexport function graphiteFuncEditor($compile: any, templateSrv: TemplateSrv) {\r\n  const funcSpanTemplate = `\r\n    <function-editor\r\n      func=\"func\"\r\n      onRemove=\"ctrl.handleRemoveFunction\"\r\n      onMoveLeft=\"ctrl.handleMoveLeft\"\r\n      onMoveRight=\"ctrl.handleMoveRight\"\r\n    /><span>(</span>\r\n  `;\r\n  const paramTemplate =\r\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\r\n\r\n  return {\r\n    restrict: 'A',\r\n    link: function postLink($scope: any, elem: JQuery) {\r\n      const $funcLink = $(funcSpanTemplate);\r\n      const ctrl = $scope.ctrl;\r\n      const func = $scope.func;\r\n      let scheduledRelink = false;\r\n      let paramCountAtLink = 0;\r\n      let cancelBlur: any = null;\r\n\r\n      ctrl.handleRemoveFunction = (func: any) => {\r\n        ctrl.removeFunction(func);\r\n      };\r\n\r\n      ctrl.handleMoveLeft = (func: any) => {\r\n        ctrl.moveFunction(func, -1);\r\n      };\r\n\r\n      ctrl.handleMoveRight = (func: any) => {\r\n        ctrl.moveFunction(func, 1);\r\n      };\r\n\r\n      function clickFuncParam(this: any, paramIndex: any) {\r\n        /*jshint validthis:true */\r\n\r\n        const $link = $(this);\r\n        const $comma = $link.prev('.comma');\r\n        const $input = $link.next();\r\n\r\n        $input.val(func.params[paramIndex]);\r\n\r\n        $comma.removeClass('query-part__last');\r\n        $link.hide();\r\n        $input.show();\r\n        $input.focus();\r\n        $input.select();\r\n\r\n        const typeahead = $input.data('typeahead');\r\n        if (typeahead) {\r\n          $input.val('');\r\n          typeahead.lookup();\r\n        }\r\n      }\r\n\r\n      function scheduledRelinkIfNeeded() {\r\n        if (paramCountAtLink === func.params.length) {\r\n          return;\r\n        }\r\n\r\n        if (!scheduledRelink) {\r\n          scheduledRelink = true;\r\n          setTimeout(() => {\r\n            relink();\r\n            scheduledRelink = false;\r\n          }, 200);\r\n        }\r\n      }\r\n\r\n      function paramDef(index: number) {\r\n        if (index < func.def.params.length) {\r\n          return func.def.params[index];\r\n        }\r\n        if ((_.last(func.def.params) as any).multiple) {\r\n          return _.assign({}, _.last(func.def.params), { optional: true });\r\n        }\r\n        return {};\r\n      }\r\n\r\n      function switchToLink(inputElem: HTMLElement, paramIndex: any) {\r\n        /*jshint validthis:true */\r\n        const $input = $(inputElem);\r\n\r\n        clearTimeout(cancelBlur);\r\n        cancelBlur = null;\r\n\r\n        const $link = $input.prev();\r\n        const $comma = $link.prev('.comma');\r\n        const newValue = $input.val();\r\n\r\n        // remove optional empty params\r\n        if (newValue !== '' || paramDef(paramIndex).optional) {\r\n          func.updateParam(newValue, paramIndex);\r\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\r\n        }\r\n\r\n        scheduledRelinkIfNeeded();\r\n\r\n        $scope.$apply(() => {\r\n          ctrl.targetChanged();\r\n        });\r\n\r\n        if ($link.hasClass('query-part__last') && newValue === '') {\r\n          $comma.addClass('query-part__last');\r\n        } else {\r\n          $link.removeClass('query-part__last');\r\n        }\r\n\r\n        $input.hide();\r\n        $link.show();\r\n      }\r\n\r\n      // this = input element\r\n      function inputBlur(this: any, paramIndex: any) {\r\n        /*jshint validthis:true */\r\n        const inputElem = this;\r\n        // happens long before the click event on the typeahead options\r\n        // need to have long delay because the blur\r\n        cancelBlur = setTimeout(() => {\r\n          switchToLink(inputElem, paramIndex);\r\n        }, 200);\r\n      }\r\n\r\n      function inputKeyPress(this: any, paramIndex: any, e: any) {\r\n        /*jshint validthis:true */\r\n        if (e.which === 13) {\r\n          $(this).blur();\r\n        }\r\n      }\r\n\r\n      function inputKeyDown(this: any) {\r\n        /*jshint validthis:true */\r\n        this.style.width = (3 + this.value.length) * 8 + 'px';\r\n      }\r\n\r\n      function addTypeahead($input: any, paramIndex: any) {\r\n        $input.attr('data-provide', 'typeahead');\r\n\r\n        let options = paramDef(paramIndex).options;\r\n        if (paramDef(paramIndex).type === 'int') {\r\n          options = _.map(options, val => {\r\n            return val.toString();\r\n          });\r\n        }\r\n\r\n        $input.typeahead({\r\n          source: options,\r\n          minLength: 0,\r\n          items: 20,\r\n          updater: (value: any) => {\r\n            $input.val(value);\r\n            switchToLink($input[0], paramIndex);\r\n            return value;\r\n          },\r\n        });\r\n\r\n        const typeahead = $input.data('typeahead');\r\n        typeahead.lookup = function() {\r\n          this.query = this.$element.val() || '';\r\n          return this.process(this.source);\r\n        };\r\n      }\r\n\r\n      function addElementsAndCompile() {\r\n        $funcLink.appendTo(elem);\r\n\r\n        const defParams: any = _.clone(func.def.params);\r\n        const lastParam: any = _.last(func.def.params);\r\n\r\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\r\n          defParams.push(_.assign({}, lastParam, { optional: true }));\r\n        }\r\n\r\n        _.each(defParams, (param: any, index: number) => {\r\n          if (param.optional && func.params.length < index) {\r\n            return false;\r\n          }\r\n\r\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\r\n          const hasValue = paramValue !== null && paramValue !== undefined;\r\n\r\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\r\n          if (last && param.multiple) {\r\n            paramValue = '+';\r\n          }\r\n\r\n          if (index > 0) {\r\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">, </span>').appendTo(elem);\r\n          }\r\n\r\n          const $paramLink = $(\r\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\r\n              (last ? ' query-part__last' : '') +\r\n              '\">' +\r\n              (hasValue ? paramValue : '&nbsp;') +\r\n              '</a>'\r\n          );\r\n          const $input = $(paramTemplate);\r\n          $input.attr('placeholder', param.name);\r\n\r\n          paramCountAtLink++;\r\n\r\n          $paramLink.appendTo(elem);\r\n          $input.appendTo(elem);\r\n\r\n          $input.blur(_.partial(inputBlur, index));\r\n          $input.keyup(inputKeyDown);\r\n          $input.keypress(_.partial(inputKeyPress, index));\r\n          $paramLink.click(_.partial(clickFuncParam, index));\r\n\r\n          if (param.options) {\r\n            addTypeahead($input, index);\r\n          }\r\n\r\n          return true;\r\n        });\r\n\r\n        $('<span>)</span>').appendTo(elem);\r\n\r\n        $compile(elem.contents())($scope);\r\n      }\r\n\r\n      function ifJustAddedFocusFirstParam() {\r\n        if ($scope.func.added) {\r\n          $scope.func.added = false;\r\n          setTimeout(() => {\r\n            elem\r\n              .find('.graphite-func-param-link')\r\n              .first()\r\n              .click();\r\n          }, 10);\r\n        }\r\n      }\r\n\r\n      function relink() {\r\n        elem.children().remove();\r\n        addElementsAndCompile();\r\n        ifJustAddedFocusFirstParam();\r\n      }\r\n\r\n      relink();\r\n    },\r\n  };\r\n}\r\n\r\ncoreModule.directive('graphiteFuncEditor', graphiteFuncEditor);\r\n","import _ from 'lodash';\r\nimport { isVersionGtOrEq } from 'app/core/utils/version';\r\nimport { InterpolateFunction } from '@grafana/data';\r\n\r\nconst index: any = {};\r\n\r\nexport interface FuncDef {\r\n  name: any;\r\n  category?: string;\r\n  params?: any;\r\n  defaultParams?: any;\r\n  shortName?: any;\r\n  fake?: boolean;\r\n  version?: string;\r\n  description?: string;\r\n}\r\n\r\nfunction addFuncDef(funcDef: FuncDef) {\r\n  funcDef.params = funcDef.params || [];\r\n  funcDef.defaultParams = funcDef.defaultParams || [];\r\n\r\n  index[funcDef.name] = funcDef;\r\n  if (funcDef.shortName) {\r\n    index[funcDef.shortName] = funcDef;\r\n  }\r\n}\r\n\r\nconst optionalSeriesRefArgs = [{ name: 'other', type: 'value_or_series', optional: true, multiple: true }];\r\n\r\naddFuncDef({\r\n  name: 'scaleToSeconds',\r\n  category: 'Transform',\r\n  params: [{ name: 'seconds', type: 'int' }],\r\n  defaultParams: [1],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'perSecond',\r\n  category: 'Transform',\r\n  params: [{ name: 'max value', type: 'int', optional: true }],\r\n  defaultParams: [],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'holtWintersForecast',\r\n  category: 'Calculate',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'holtWintersConfidenceBands',\r\n  category: 'Calculate',\r\n  params: [{ name: 'delta', type: 'int' }],\r\n  defaultParams: [3],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'holtWintersAberration',\r\n  category: 'Calculate',\r\n  params: [{ name: 'delta', type: 'int' }],\r\n  defaultParams: [3],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'nPercentile',\r\n  category: 'Calculate',\r\n  params: [{ name: 'Nth percentile', type: 'int' }],\r\n  defaultParams: [95],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'diffSeries',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: ['#A'],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'stddevSeries',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: [''],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'divideSeries',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: ['#A'],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'multiplySeries',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: ['#A'],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'asPercent',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: ['#A'],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'group',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: ['#A', '#B'],\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sumSeries',\r\n  shortName: 'sum',\r\n  category: 'Combine',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: [''],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'averageSeries',\r\n  shortName: 'avg',\r\n  category: 'Combine',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: [''],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'rangeOfSeries',\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'percentileOfSeries',\r\n  category: 'Combine',\r\n  params: [\r\n    { name: 'n', type: 'int' },\r\n    { name: 'interpolate', type: 'boolean', options: ['true', 'false'] },\r\n  ],\r\n  defaultParams: [95, 'false'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sumSeriesWithWildcards',\r\n  category: 'Combine',\r\n  params: [{ name: 'node', type: 'int', multiple: true }],\r\n  defaultParams: [3],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'maxSeries',\r\n  shortName: 'max',\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'minSeries',\r\n  shortName: 'min',\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'averageSeriesWithWildcards',\r\n  category: 'Combine',\r\n  params: [{ name: 'node', type: 'int', multiple: true }],\r\n  defaultParams: [3],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'alias',\r\n  category: 'Alias',\r\n  params: [{ name: 'alias', type: 'string' }],\r\n  defaultParams: ['alias'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'aliasSub',\r\n  category: 'Alias',\r\n  params: [\r\n    { name: 'search', type: 'string' },\r\n    { name: 'replace', type: 'string' },\r\n  ],\r\n  defaultParams: ['', '\\\\1'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'consolidateBy',\r\n  category: 'Special',\r\n  params: [\r\n    {\r\n      name: 'function',\r\n      type: 'string',\r\n      options: ['sum', 'average', 'min', 'max'],\r\n    },\r\n  ],\r\n  defaultParams: ['max'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'cumulative',\r\n  category: 'Special',\r\n  params: [],\r\n  defaultParams: [],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'groupByNode',\r\n  category: 'Combine',\r\n  params: [\r\n    {\r\n      name: 'node',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n    },\r\n    {\r\n      name: 'function',\r\n      type: 'string',\r\n      options: ['sum', 'avg', 'maxSeries'],\r\n    },\r\n  ],\r\n  defaultParams: [3, 'sum'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'aliasByNode',\r\n  category: 'Alias',\r\n  params: [\r\n    {\r\n      name: 'node',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n      multiple: true,\r\n    },\r\n  ],\r\n  defaultParams: [3],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'substr',\r\n  category: 'Special',\r\n  params: [\r\n    {\r\n      name: 'start',\r\n      type: 'int',\r\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n    },\r\n    {\r\n      name: 'stop',\r\n      type: 'int',\r\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n    },\r\n  ],\r\n  defaultParams: [0, 0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sortByName',\r\n  category: 'Sorting',\r\n  params: [\r\n    {\r\n      name: 'natural',\r\n      type: 'boolean',\r\n      options: ['true', 'false'],\r\n      optional: true,\r\n    },\r\n  ],\r\n  defaultParams: ['false'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sortByMaxima',\r\n  category: 'Sorting',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sortByMinima',\r\n  category: 'Sorting',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'sortByTotal',\r\n  category: 'Sorting',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'aliasByMetric',\r\n  category: 'Alias',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'randomWalk',\r\n  fake: true,\r\n  category: 'Special',\r\n  params: [{ name: 'name', type: 'string' }],\r\n  defaultParams: ['randomWalk'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'countSeries',\r\n  category: 'Combine',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'constantLine',\r\n  category: 'Special',\r\n  params: [{ name: 'value', type: 'int' }],\r\n  defaultParams: [10],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'cactiStyle',\r\n  category: 'Special',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'keepLastValue',\r\n  category: 'Transform',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [100],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'changed',\r\n  category: 'Special',\r\n  params: [],\r\n  defaultParams: [],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'scale',\r\n  category: 'Transform',\r\n  params: [{ name: 'factor', type: 'int' }],\r\n  defaultParams: [1],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'offset',\r\n  category: 'Transform',\r\n  params: [{ name: 'amount', type: 'int' }],\r\n  defaultParams: [10],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'transformNull',\r\n  category: 'Transform',\r\n  params: [{ name: 'amount', type: 'int' }],\r\n  defaultParams: [0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'integral',\r\n  category: 'Transform',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'derivative',\r\n  category: 'Transform',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'nonNegativeDerivative',\r\n  category: 'Transform',\r\n  params: [{ name: 'max value or 0', type: 'int', optional: true }],\r\n  defaultParams: [''],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'timeShift',\r\n  category: 'Transform',\r\n  params: [\r\n    {\r\n      name: 'amount',\r\n      type: 'select',\r\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\r\n    },\r\n  ],\r\n  defaultParams: ['1d'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'timeStack',\r\n  category: 'Transform',\r\n  params: [\r\n    {\r\n      name: 'timeShiftUnit',\r\n      type: 'select',\r\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\r\n    },\r\n    { name: 'timeShiftStart', type: 'int' },\r\n    { name: 'timeShiftEnd', type: 'int' },\r\n  ],\r\n  defaultParams: ['1d', 0, 7],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'summarize',\r\n  category: 'Transform',\r\n  params: [\r\n    { name: 'interval', type: 'string' },\r\n    {\r\n      name: 'func',\r\n      type: 'select',\r\n      options: ['sum', 'avg', 'min', 'max', 'last'],\r\n    },\r\n    {\r\n      name: 'alignToFrom',\r\n      type: 'boolean',\r\n      optional: true,\r\n      options: ['false', 'true'],\r\n    },\r\n  ],\r\n  defaultParams: ['1h', 'sum', 'false'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'smartSummarize',\r\n  category: 'Transform',\r\n  params: [\r\n    { name: 'interval', type: 'string' },\r\n    {\r\n      name: 'func',\r\n      type: 'select',\r\n      options: ['sum', 'avg', 'min', 'max', 'last'],\r\n    },\r\n  ],\r\n  defaultParams: ['1h', 'sum'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'absolute',\r\n  category: 'Transform',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'hitcount',\r\n  category: 'Transform',\r\n  params: [{ name: 'interval', type: 'string' }],\r\n  defaultParams: ['10s'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'log',\r\n  category: 'Transform',\r\n  params: [{ name: 'base', type: 'int' }],\r\n  defaultParams: ['10'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'averageAbove',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [25],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'averageBelow',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [25],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'currentAbove',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [25],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'currentBelow',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [25],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'maximumAbove',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'value', type: 'int' }],\r\n  defaultParams: [0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'maximumBelow',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'value', type: 'int' }],\r\n  defaultParams: [0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'minimumAbove',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'value', type: 'int' }],\r\n  defaultParams: [0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'minimumBelow',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'value', type: 'int' }],\r\n  defaultParams: [0],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'limit',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'mostDeviant',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [10],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'exclude',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'exclude', type: 'string' }],\r\n  defaultParams: ['exclude'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'highestCurrent',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'highestMax',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'lowestCurrent',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'movingAverage',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: [10],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'movingMedian',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: ['5'],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'stdev',\r\n  category: 'Calculate',\r\n  params: [\r\n    { name: 'n', type: 'int' },\r\n    { name: 'tolerance', type: 'int' },\r\n  ],\r\n  defaultParams: [5, 0.1],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'highestAverage',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'lowestAverage',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeAbovePercentile',\r\n  category: 'Filter Data',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeAboveValue',\r\n  category: 'Filter Data',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeBelowPercentile',\r\n  category: 'Filter Data',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeBelowValue',\r\n  category: 'Filter Data',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [5],\r\n});\r\n\r\naddFuncDef({\r\n  name: 'useSeriesAbove',\r\n  category: 'Filter Series',\r\n  params: [\r\n    { name: 'value', type: 'int' },\r\n    { name: 'search', type: 'string' },\r\n    { name: 'replace', type: 'string' },\r\n  ],\r\n  defaultParams: [0, 'search', 'replace'],\r\n});\r\n\r\n////////////////////\r\n// Graphite 1.0.x //\r\n////////////////////\r\n\r\naddFuncDef({\r\n  name: 'aggregateLine',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'func',\r\n      type: 'select',\r\n      options: ['sum', 'avg', 'min', 'max', 'last'],\r\n    },\r\n  ],\r\n  defaultParams: ['avg'],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'averageOutsidePercentile',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [95],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'delay',\r\n  category: 'Transform',\r\n  params: [{ name: 'steps', type: 'int' }],\r\n  defaultParams: [1],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'exponentialMovingAverage',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: [10],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'fallbackSeries',\r\n  category: 'Special',\r\n  params: [{ name: 'fallback', type: 'string' }],\r\n  defaultParams: ['constantLine(0)'],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'grep',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'grep', type: 'string' }],\r\n  defaultParams: ['grep'],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'groupByNodes',\r\n  category: 'Combine',\r\n  params: [\r\n    {\r\n      name: 'function',\r\n      type: 'string',\r\n      options: ['sum', 'avg', 'maxSeries'],\r\n    },\r\n    {\r\n      name: 'node',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n      multiple: true,\r\n    },\r\n  ],\r\n  defaultParams: ['sum', 3],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'integralByInterval',\r\n  category: 'Transform',\r\n  params: [\r\n    {\r\n      name: 'intervalUnit',\r\n      type: 'select',\r\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\r\n    },\r\n  ],\r\n  defaultParams: ['1d'],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'interpolate',\r\n  category: 'Transform',\r\n  params: [{ name: 'limit', type: 'int', optional: true }],\r\n  defaultParams: [],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'invert',\r\n  category: 'Transform',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'isNonNull',\r\n  category: 'Combine',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'linearRegression',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'startSourceAt',\r\n      type: 'select',\r\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\r\n      optional: true,\r\n    },\r\n    {\r\n      name: 'endSourceAt',\r\n      type: 'select',\r\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\r\n      optional: true,\r\n    },\r\n  ],\r\n  defaultParams: [],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'mapSeries',\r\n  shortName: 'map',\r\n  params: [{ name: 'node', type: 'int' }],\r\n  defaultParams: [3],\r\n  category: 'Combine',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'movingMin',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: [10],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'movingMax',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: [10],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'movingSum',\r\n  category: 'Calculate',\r\n  params: [\r\n    {\r\n      name: 'windowSize',\r\n      type: 'int_or_interval',\r\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\r\n    },\r\n  ],\r\n  defaultParams: [10],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'multiplySeriesWithWildcards',\r\n  category: 'Combine',\r\n  params: [\r\n    {\r\n      name: 'position',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n      multiple: true,\r\n    },\r\n  ],\r\n  defaultParams: [2],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'offsetToZero',\r\n  category: 'Transform',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'pow',\r\n  category: 'Transform',\r\n  params: [{ name: 'factor', type: 'int' }],\r\n  defaultParams: [10],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'powSeries',\r\n  category: 'Transform',\r\n  params: optionalSeriesRefArgs,\r\n  defaultParams: [''],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'reduceSeries',\r\n  shortName: 'reduce',\r\n  params: [\r\n    {\r\n      name: 'function',\r\n      type: 'string',\r\n      options: ['asPercent', 'diffSeries', 'divideSeries'],\r\n    },\r\n    {\r\n      name: 'reduceNode',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\r\n    },\r\n    { name: 'reduceMatchers', type: 'string', multiple: true },\r\n  ],\r\n  defaultParams: ['asPercent', 2, 'used_bytes'],\r\n  category: 'Combine',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeBetweenPercentile',\r\n  category: 'Filter Series',\r\n  params: [{ name: 'n', type: 'int' }],\r\n  defaultParams: [95],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'removeEmptySeries',\r\n  category: 'Filter Series',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'squareRoot',\r\n  category: 'Transform',\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'timeSlice',\r\n  category: 'Transform',\r\n  params: [\r\n    {\r\n      name: 'startSliceAt',\r\n      type: 'select',\r\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\r\n    },\r\n    {\r\n      name: 'endSliceAt',\r\n      type: 'select',\r\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\r\n      optional: true,\r\n    },\r\n  ],\r\n  defaultParams: ['-1h'],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'weightedAverage',\r\n  category: 'Combine',\r\n  params: [\r\n    { name: 'other', type: 'value_or_series', optional: true },\r\n    {\r\n      name: 'node',\r\n      type: 'int',\r\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\r\n    },\r\n  ],\r\n  defaultParams: ['#A', 4],\r\n  version: '1.0',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'seriesByTag',\r\n  category: 'Special',\r\n  params: [{ name: 'tagExpression', type: 'string', multiple: true }],\r\n  version: '1.1',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'groupByTags',\r\n  category: 'Combine',\r\n  params: [\r\n    {\r\n      name: 'function',\r\n      type: 'string',\r\n      options: ['sum', 'avg', 'maxSeries'],\r\n    },\r\n    { name: 'tag', type: 'string', multiple: true },\r\n  ],\r\n  defaultParams: ['sum', 'tag'],\r\n  version: '1.1',\r\n});\r\n\r\naddFuncDef({\r\n  name: 'aliasByTags',\r\n  category: 'Alias',\r\n  params: [{ name: 'tag', type: 'string', multiple: true }],\r\n  defaultParams: ['tag'],\r\n  version: '1.1',\r\n});\r\n\r\nfunction isVersionRelatedFunction(obj: { version: string }, graphiteVersion: string) {\r\n  return !obj.version || isVersionGtOrEq(graphiteVersion, obj.version);\r\n}\r\n\r\nexport class FuncInstance {\r\n  def: any;\r\n  params: any;\r\n  text: any;\r\n  added: boolean;\r\n\r\n  constructor(funcDef: any, options: { withDefaultParams: any }) {\r\n    this.def = funcDef;\r\n    this.params = [];\r\n\r\n    if (options && options.withDefaultParams) {\r\n      this.params = funcDef.defaultParams.slice(0);\r\n    }\r\n\r\n    this.updateText();\r\n  }\r\n\r\n  render(metricExp: string, replaceVariables: InterpolateFunction): string {\r\n    const str = this.def.name + '(';\r\n\r\n    const parameters = _.map(this.params, (value, index) => {\r\n      let paramType;\r\n\r\n      if (index < this.def.params.length) {\r\n        paramType = this.def.params[index].type;\r\n      } else if (_.get(_.last(this.def.params), 'multiple')) {\r\n        paramType = _.get(_.last(this.def.params), 'type');\r\n      }\r\n\r\n      // param types that should never be quoted\r\n      if (_.includes(['value_or_series', 'boolean', 'int', 'float', 'node'], paramType)) {\r\n        return value;\r\n      }\r\n\r\n      const valueInterpolated = _.isString(value) ? replaceVariables(value) : value;\r\n\r\n      // param types that might be quoted\r\n      // To quote variables correctly we need to interpolate it to check if it contains a numeric or string value\r\n      if (_.includes(['int_or_interval', 'node_or_tag'], paramType) && _.isFinite(+valueInterpolated)) {\r\n        return _.toString(value);\r\n      }\r\n\r\n      return \"'\" + value + \"'\";\r\n    });\r\n\r\n    // don't send any blank parameters to graphite\r\n    while (parameters[parameters.length - 1] === '') {\r\n      parameters.pop();\r\n    }\r\n\r\n    if (metricExp) {\r\n      parameters.unshift(metricExp);\r\n    }\r\n\r\n    return str + parameters.join(', ') + ')';\r\n  }\r\n\r\n  _hasMultipleParamsInString(strValue: any, index: number) {\r\n    if (strValue.indexOf(',') === -1) {\r\n      return false;\r\n    }\r\n\r\n    if (this.def.params[index + 1] && this.def.params[index + 1].optional) {\r\n      return true;\r\n    }\r\n\r\n    if (index + 1 >= this.def.params.length && _.get(_.last(this.def.params), 'multiple')) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  updateParam(strValue: any, index: any) {\r\n    // handle optional parameters\r\n    // if string contains ',' and next param is optional, split and update both\r\n    if (this._hasMultipleParamsInString(strValue, index)) {\r\n      _.each(strValue.split(','), (partVal, idx) => {\r\n        this.updateParam(partVal.trim(), index + idx);\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (strValue === '' && (index >= this.def.params.length || this.def.params[index].optional)) {\r\n      this.params.splice(index, 1);\r\n    } else {\r\n      this.params[index] = strValue;\r\n    }\r\n\r\n    this.updateText();\r\n  }\r\n\r\n  updateText() {\r\n    if (this.params.length === 0) {\r\n      this.text = this.def.name + '()';\r\n      return;\r\n    }\r\n\r\n    let text = this.def.name + '(';\r\n    text += this.params.join(', ');\r\n    text += ')';\r\n    this.text = text;\r\n  }\r\n}\r\n\r\nfunction createFuncInstance(funcDef: any, options?: { withDefaultParams: any }, idx?: any) {\r\n  if (_.isString(funcDef)) {\r\n    funcDef = getFuncDef(funcDef, idx);\r\n  }\r\n  return new FuncInstance(funcDef, options);\r\n}\r\n\r\nfunction getFuncDef(name: string, idx?: any) {\r\n  if (!(idx || index)[name]) {\r\n    throw { message: 'Method not found ' + name };\r\n  }\r\n  return (idx || index)[name];\r\n}\r\n\r\nfunction getFuncDefs(graphiteVersion: string, idx?: any) {\r\n  const funcs: any = {};\r\n  _.forEach(idx || index, funcDef => {\r\n    if (isVersionRelatedFunction(funcDef, graphiteVersion)) {\r\n      funcs[funcDef.name] = _.assign({}, funcDef, {\r\n        params: _.filter(funcDef.params, param => {\r\n          return isVersionRelatedFunction(param, graphiteVersion);\r\n        }),\r\n      });\r\n    }\r\n  });\r\n  return funcs;\r\n}\r\n\r\n// parse response from graphite /functions endpoint into internal format\r\nfunction parseFuncDefs(rawDefs: any) {\r\n  const funcDefs: any = {};\r\n\r\n  _.forEach(rawDefs || {}, (funcDef, funcName) => {\r\n    // skip graphite graph functions\r\n    if (funcDef.group === 'Graph') {\r\n      return;\r\n    }\r\n\r\n    let description = funcDef.description;\r\n    if (description) {\r\n      // tidy up some pydoc syntax that rst2html can't handle\r\n      description = description\r\n        .replace(/:py:func:`(.+)( <[^>]*>)?`/g, '``$1``')\r\n        .replace(/.. seealso:: /g, 'See also: ')\r\n        .replace(/.. code-block *:: *none/g, '.. code-block::');\r\n    }\r\n\r\n    const func: FuncDef = {\r\n      name: funcDef.name,\r\n      description,\r\n      category: funcDef.group,\r\n      params: [],\r\n      defaultParams: [],\r\n      fake: false,\r\n    };\r\n\r\n    // get rid of the first \"seriesList\" param\r\n    if (/^seriesLists?$/.test(_.get(funcDef, 'params[0].type', ''))) {\r\n      // handle functions that accept multiple seriesLists\r\n      // we leave the param in place but mark it optional, so users can add more series if they wish\r\n      if (funcDef.params[0].multiple) {\r\n        funcDef.params[0].required = false;\r\n        // otherwise chop off the first param, it'll be handled separately\r\n      } else {\r\n        funcDef.params.shift();\r\n      }\r\n      // tag function as fake\r\n    } else {\r\n      func.fake = true;\r\n    }\r\n\r\n    _.forEach(funcDef.params, rawParam => {\r\n      const param: any = {\r\n        name: rawParam.name,\r\n        type: 'string',\r\n        optional: !rawParam.required,\r\n        multiple: !!rawParam.multiple,\r\n        options: undefined,\r\n      };\r\n\r\n      if (rawParam.default !== undefined) {\r\n        func.defaultParams.push(_.toString(rawParam.default));\r\n      } else if (rawParam.suggestions) {\r\n        func.defaultParams.push(_.toString(rawParam.suggestions[0]));\r\n      } else {\r\n        func.defaultParams.push('');\r\n      }\r\n\r\n      if (rawParam.type === 'boolean') {\r\n        param.type = 'boolean';\r\n        param.options = ['true', 'false'];\r\n      } else if (rawParam.type === 'integer') {\r\n        param.type = 'int';\r\n      } else if (rawParam.type === 'float') {\r\n        param.type = 'float';\r\n      } else if (rawParam.type === 'node') {\r\n        param.type = 'node';\r\n        param.options = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\r\n      } else if (rawParam.type === 'nodeOrTag') {\r\n        param.type = 'node_or_tag';\r\n        param.options = ['name', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\r\n      } else if (rawParam.type === 'intOrInterval') {\r\n        param.type = 'int_or_interval';\r\n      } else if (rawParam.type === 'seriesList') {\r\n        param.type = 'value_or_series';\r\n      }\r\n\r\n      if (rawParam.options) {\r\n        param.options = _.map(rawParam.options, _.toString);\r\n      } else if (rawParam.suggestions) {\r\n        param.options = _.map(rawParam.suggestions, _.toString);\r\n      }\r\n\r\n      func.params.push(param);\r\n    });\r\n\r\n    funcDefs[funcName] = func;\r\n  });\r\n\r\n  return funcDefs;\r\n}\r\n\r\nexport default {\r\n  createFuncInstance: createFuncInstance,\r\n  getFuncDef: getFuncDef,\r\n  getFuncDefs: getFuncDefs,\r\n  parseFuncDefs: parseFuncDefs,\r\n};\r\n","import _ from 'lodash';\r\nimport { Parser } from './parser';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\n\r\nexport default class GraphiteQuery {\r\n  datasource: any;\r\n  target: any;\r\n  functions: any[];\r\n  segments: any[];\r\n  tags: any[];\r\n  error: any;\r\n  seriesByTagUsed: boolean;\r\n  checkOtherSegmentsIndex: number;\r\n  removeTagValue: string;\r\n  templateSrv: any;\r\n  scopedVars: any;\r\n\r\n  /** @ngInject */\r\n  constructor(datasource: any, target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\r\n    this.datasource = datasource;\r\n    this.target = target;\r\n    this.templateSrv = templateSrv;\r\n    this.scopedVars = scopedVars;\r\n    this.parseTarget();\r\n\r\n    this.removeTagValue = '-- remove tag --';\r\n  }\r\n\r\n  parseTarget() {\r\n    this.functions = [];\r\n    this.segments = [];\r\n    this.tags = [];\r\n    this.seriesByTagUsed = false;\r\n    this.error = null;\r\n\r\n    if (this.target.textEditor) {\r\n      return;\r\n    }\r\n\r\n    const parser = new Parser(this.target.target);\r\n    const astNode = parser.getAst();\r\n    if (astNode === null) {\r\n      this.checkOtherSegmentsIndex = 0;\r\n      return;\r\n    }\r\n\r\n    if (astNode.type === 'error') {\r\n      this.error = astNode.message + ' at position: ' + astNode.pos;\r\n      this.target.textEditor = true;\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.parseTargetRecursive(astNode, null);\r\n    } catch (err) {\r\n      console.log('error parsing target:', err.message);\r\n      this.error = err.message;\r\n      this.target.textEditor = true;\r\n    }\r\n\r\n    this.checkOtherSegmentsIndex = this.segments.length - 1;\r\n  }\r\n\r\n  getSegmentPathUpTo(index: number) {\r\n    const arr = this.segments.slice(0, index);\r\n\r\n    return _.reduce(\r\n      arr,\r\n      (result, segment) => {\r\n        return result ? result + '.' + segment.value : segment.value;\r\n      },\r\n      ''\r\n    );\r\n  }\r\n\r\n  parseTargetRecursive(astNode: any, func: any): any {\r\n    if (astNode === null) {\r\n      return null;\r\n    }\r\n\r\n    switch (astNode.type) {\r\n      case 'function':\r\n        const innerFunc = this.datasource.createFuncInstance(astNode.name, {\r\n          withDefaultParams: false,\r\n        });\r\n        _.each(astNode.params, param => {\r\n          this.parseTargetRecursive(param, innerFunc);\r\n        });\r\n\r\n        innerFunc.updateText();\r\n        this.functions.push(innerFunc);\r\n\r\n        // extract tags from seriesByTag function and hide function\r\n        if (innerFunc.def.name === 'seriesByTag' && !this.seriesByTagUsed) {\r\n          this.seriesByTagUsed = true;\r\n          innerFunc.hidden = true;\r\n          this.tags = this.splitSeriesByTagParams(innerFunc);\r\n        }\r\n\r\n        break;\r\n      case 'series-ref':\r\n        if (this.segments.length > 0 || this.getSeriesByTagFuncIndex() >= 0) {\r\n          this.addFunctionParameter(func, astNode.value);\r\n        } else {\r\n          this.segments.push(astNode);\r\n        }\r\n        break;\r\n      case 'bool':\r\n      case 'string':\r\n      case 'number':\r\n        this.addFunctionParameter(func, astNode.value);\r\n        break;\r\n      case 'metric':\r\n        if (this.segments.length || this.tags.length) {\r\n          this.addFunctionParameter(func, _.join(_.map(astNode.segments, 'value'), '.'));\r\n        } else {\r\n          this.segments = astNode.segments;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  updateSegmentValue(segment: any, index: number) {\r\n    this.segments[index].value = segment.value;\r\n  }\r\n\r\n  addSelectMetricSegment() {\r\n    this.segments.push({ value: 'select metric' });\r\n  }\r\n\r\n  addFunction(newFunc: any) {\r\n    this.functions.push(newFunc);\r\n  }\r\n\r\n  addFunctionParameter(func: any, value: string) {\r\n    if (func.params.length >= func.def.params.length && !_.get(_.last(func.def.params), 'multiple', false)) {\r\n      throw { message: 'too many parameters for function ' + func.def.name };\r\n    }\r\n    func.params.push(value);\r\n  }\r\n\r\n  removeFunction(func: any) {\r\n    this.functions = _.without(this.functions, func);\r\n  }\r\n\r\n  moveFunction(func: any, offset: number) {\r\n    const index = this.functions.indexOf(func);\r\n    // @ts-ignore\r\n    _.move(this.functions, index, index + offset);\r\n  }\r\n\r\n  updateModelTarget(targets: any) {\r\n    const wrapFunction = (target: string, func: any) => {\r\n      return func.render(target, (value: string) => {\r\n        return this.templateSrv.replace(value, this.scopedVars);\r\n      });\r\n    };\r\n\r\n    if (!this.target.textEditor) {\r\n      const metricPath = this.getSegmentPathUpTo(this.segments.length).replace(/\\.select metric$/, '');\r\n      this.target.target = _.reduce(this.functions, wrapFunction, metricPath);\r\n    }\r\n\r\n    this.updateRenderedTarget(this.target, targets);\r\n\r\n    // loop through other queries and update targetFull as needed\r\n    for (const target of targets || []) {\r\n      if (target.refId !== this.target.refId) {\r\n        this.updateRenderedTarget(target, targets);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateRenderedTarget(target: { refId: string | number; target: any; targetFull: any }, targets: any) {\r\n    // render nested query\r\n    const targetsByRefId = _.keyBy(targets, 'refId');\r\n\r\n    // no references to self\r\n    delete targetsByRefId[target.refId];\r\n\r\n    const nestedSeriesRefRegex = /\\#([A-Z])/g;\r\n    let targetWithNestedQueries = target.target;\r\n\r\n    // Use ref count to track circular references\r\n    function countTargetRefs(targetsByRefId: any, refId: string) {\r\n      let refCount = 0;\r\n      _.each(targetsByRefId, (t, id) => {\r\n        if (id !== refId) {\r\n          const match = nestedSeriesRefRegex.exec(t.target);\r\n          const count = match && match.length ? match.length - 1 : 0;\r\n          refCount += count;\r\n        }\r\n      });\r\n      targetsByRefId[refId].refCount = refCount;\r\n    }\r\n    _.each(targetsByRefId, (t, id) => {\r\n      countTargetRefs(targetsByRefId, id);\r\n    });\r\n\r\n    // Keep interpolating until there are no query references\r\n    // The reason for the loop is that the referenced query might contain another reference to another query\r\n    while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {\r\n      const updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, (match: string, g1: string) => {\r\n        const t = targetsByRefId[g1];\r\n        if (!t) {\r\n          return match;\r\n        }\r\n\r\n        // no circular references\r\n        if (t.refCount === 0) {\r\n          delete targetsByRefId[g1];\r\n        }\r\n        t.refCount--;\r\n\r\n        return t.target;\r\n      });\r\n\r\n      if (updated === targetWithNestedQueries) {\r\n        break;\r\n      }\r\n\r\n      targetWithNestedQueries = updated;\r\n    }\r\n\r\n    delete target.targetFull;\r\n    if (target.target !== targetWithNestedQueries) {\r\n      target.targetFull = targetWithNestedQueries;\r\n    }\r\n  }\r\n\r\n  splitSeriesByTagParams(func: { params: any }) {\r\n    const tagPattern = /([^\\!=~]+)(\\!?=~?)(.*)/;\r\n    return _.flatten(\r\n      _.map(func.params, (param: string) => {\r\n        const matches = tagPattern.exec(param);\r\n        if (matches) {\r\n          const tag = matches.slice(1);\r\n          if (tag.length === 3) {\r\n            return {\r\n              key: tag[0],\r\n              operator: tag[1],\r\n              value: tag[2],\r\n            };\r\n          }\r\n        }\r\n        return [];\r\n      })\r\n    );\r\n  }\r\n\r\n  getSeriesByTagFuncIndex() {\r\n    return _.findIndex(this.functions, func => func.def.name === 'seriesByTag');\r\n  }\r\n\r\n  getSeriesByTagFunc() {\r\n    const seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();\r\n    if (seriesByTagFuncIndex >= 0) {\r\n      return this.functions[seriesByTagFuncIndex];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  addTag(tag: { key: any; operator: string; value: string }) {\r\n    const newTagParam = renderTagString(tag);\r\n    this.getSeriesByTagFunc().params.push(newTagParam);\r\n    this.tags.push(tag);\r\n  }\r\n\r\n  removeTag(index: number) {\r\n    this.getSeriesByTagFunc().params.splice(index, 1);\r\n    this.tags.splice(index, 1);\r\n  }\r\n\r\n  updateTag(tag: { key: string }, tagIndex: number) {\r\n    this.error = null;\r\n\r\n    if (tag.key === this.removeTagValue) {\r\n      this.removeTag(tagIndex);\r\n      return;\r\n    }\r\n\r\n    const newTagParam = renderTagString(tag);\r\n    this.getSeriesByTagFunc().params[tagIndex] = newTagParam;\r\n    this.tags[tagIndex] = tag;\r\n  }\r\n\r\n  renderTagExpressions(excludeIndex = -1) {\r\n    return _.compact(\r\n      _.map(this.tags, (tagExpr, index) => {\r\n        // Don't render tag that we want to lookup\r\n        if (index !== excludeIndex) {\r\n          return tagExpr.key + tagExpr.operator + tagExpr.value;\r\n        }\r\n      })\r\n    );\r\n  }\r\n}\r\n\r\nfunction renderTagString(tag: { key: any; operator?: any; value?: any }) {\r\n  return tag.key + tag.operator + tag.value;\r\n}\r\n","import _ from 'lodash';\r\n\r\n// This is auto generated from the unicode tables.\r\n// The tables are at:\r\n// http://www.fileformat.info/info/unicode/category/Lu/list.htm\r\n// http://www.fileformat.info/info/unicode/category/Ll/list.htm\r\n// http://www.fileformat.info/info/unicode/category/Lt/list.htm\r\n// http://www.fileformat.info/info/unicode/category/Lm/list.htm\r\n// http://www.fileformat.info/info/unicode/category/Lo/list.htm\r\n// http://www.fileformat.info/info/unicode/category/Nl/list.htm\r\n\r\nconst unicodeLetterTable = [\r\n  170,\r\n  170,\r\n  181,\r\n  181,\r\n  186,\r\n  186,\r\n  192,\r\n  214,\r\n  216,\r\n  246,\r\n  248,\r\n  705,\r\n  710,\r\n  721,\r\n  736,\r\n  740,\r\n  748,\r\n  748,\r\n  750,\r\n  750,\r\n  880,\r\n  884,\r\n  886,\r\n  887,\r\n  890,\r\n  893,\r\n  902,\r\n  902,\r\n  904,\r\n  906,\r\n  908,\r\n  908,\r\n  910,\r\n  929,\r\n  931,\r\n  1013,\r\n  1015,\r\n  1153,\r\n  1162,\r\n  1319,\r\n  1329,\r\n  1366,\r\n  1369,\r\n  1369,\r\n  1377,\r\n  1415,\r\n  1488,\r\n  1514,\r\n  1520,\r\n  1522,\r\n  1568,\r\n  1610,\r\n  1646,\r\n  1647,\r\n  1649,\r\n  1747,\r\n  1749,\r\n  1749,\r\n  1765,\r\n  1766,\r\n  1774,\r\n  1775,\r\n  1786,\r\n  1788,\r\n  1791,\r\n  1791,\r\n  1808,\r\n  1808,\r\n  1810,\r\n  1839,\r\n  1869,\r\n  1957,\r\n  1969,\r\n  1969,\r\n  1994,\r\n  2026,\r\n  2036,\r\n  2037,\r\n  2042,\r\n  2042,\r\n  2048,\r\n  2069,\r\n  2074,\r\n  2074,\r\n  2084,\r\n  2084,\r\n  2088,\r\n  2088,\r\n  2112,\r\n  2136,\r\n  2308,\r\n  2361,\r\n  2365,\r\n  2365,\r\n  2384,\r\n  2384,\r\n  2392,\r\n  2401,\r\n  2417,\r\n  2423,\r\n  2425,\r\n  2431,\r\n  2437,\r\n  2444,\r\n  2447,\r\n  2448,\r\n  2451,\r\n  2472,\r\n  2474,\r\n  2480,\r\n  2482,\r\n  2482,\r\n  2486,\r\n  2489,\r\n  2493,\r\n  2493,\r\n  2510,\r\n  2510,\r\n  2524,\r\n  2525,\r\n  2527,\r\n  2529,\r\n  2544,\r\n  2545,\r\n  2565,\r\n  2570,\r\n  2575,\r\n  2576,\r\n  2579,\r\n  2600,\r\n  2602,\r\n  2608,\r\n  2610,\r\n  2611,\r\n  2613,\r\n  2614,\r\n  2616,\r\n  2617,\r\n  2649,\r\n  2652,\r\n  2654,\r\n  2654,\r\n  2674,\r\n  2676,\r\n  2693,\r\n  2701,\r\n  2703,\r\n  2705,\r\n  2707,\r\n  2728,\r\n  2730,\r\n  2736,\r\n  2738,\r\n  2739,\r\n  2741,\r\n  2745,\r\n  2749,\r\n  2749,\r\n  2768,\r\n  2768,\r\n  2784,\r\n  2785,\r\n  2821,\r\n  2828,\r\n  2831,\r\n  2832,\r\n  2835,\r\n  2856,\r\n  2858,\r\n  2864,\r\n  2866,\r\n  2867,\r\n  2869,\r\n  2873,\r\n  2877,\r\n  2877,\r\n  2908,\r\n  2909,\r\n  2911,\r\n  2913,\r\n  2929,\r\n  2929,\r\n  2947,\r\n  2947,\r\n  2949,\r\n  2954,\r\n  2958,\r\n  2960,\r\n  2962,\r\n  2965,\r\n  2969,\r\n  2970,\r\n  2972,\r\n  2972,\r\n  2974,\r\n  2975,\r\n  2979,\r\n  2980,\r\n  2984,\r\n  2986,\r\n  2990,\r\n  3001,\r\n  3024,\r\n  3024,\r\n  3077,\r\n  3084,\r\n  3086,\r\n  3088,\r\n  3090,\r\n  3112,\r\n  3114,\r\n  3123,\r\n  3125,\r\n  3129,\r\n  3133,\r\n  3133,\r\n  3160,\r\n  3161,\r\n  3168,\r\n  3169,\r\n  3205,\r\n  3212,\r\n  3214,\r\n  3216,\r\n  3218,\r\n  3240,\r\n  3242,\r\n  3251,\r\n  3253,\r\n  3257,\r\n  3261,\r\n  3261,\r\n  3294,\r\n  3294,\r\n  3296,\r\n  3297,\r\n  3313,\r\n  3314,\r\n  3333,\r\n  3340,\r\n  3342,\r\n  3344,\r\n  3346,\r\n  3386,\r\n  3389,\r\n  3389,\r\n  3406,\r\n  3406,\r\n  3424,\r\n  3425,\r\n  3450,\r\n  3455,\r\n  3461,\r\n  3478,\r\n  3482,\r\n  3505,\r\n  3507,\r\n  3515,\r\n  3517,\r\n  3517,\r\n  3520,\r\n  3526,\r\n  3585,\r\n  3632,\r\n  3634,\r\n  3635,\r\n  3648,\r\n  3654,\r\n  3713,\r\n  3714,\r\n  3716,\r\n  3716,\r\n  3719,\r\n  3720,\r\n  3722,\r\n  3722,\r\n  3725,\r\n  3725,\r\n  3732,\r\n  3735,\r\n  3737,\r\n  3743,\r\n  3745,\r\n  3747,\r\n  3749,\r\n  3749,\r\n  3751,\r\n  3751,\r\n  3754,\r\n  3755,\r\n  3757,\r\n  3760,\r\n  3762,\r\n  3763,\r\n  3773,\r\n  3773,\r\n  3776,\r\n  3780,\r\n  3782,\r\n  3782,\r\n  3804,\r\n  3805,\r\n  3840,\r\n  3840,\r\n  3904,\r\n  3911,\r\n  3913,\r\n  3948,\r\n  3976,\r\n  3980,\r\n  4096,\r\n  4138,\r\n  4159,\r\n  4159,\r\n  4176,\r\n  4181,\r\n  4186,\r\n  4189,\r\n  4193,\r\n  4193,\r\n  4197,\r\n  4198,\r\n  4206,\r\n  4208,\r\n  4213,\r\n  4225,\r\n  4238,\r\n  4238,\r\n  4256,\r\n  4293,\r\n  4304,\r\n  4346,\r\n  4348,\r\n  4348,\r\n  4352,\r\n  4680,\r\n  4682,\r\n  4685,\r\n  4688,\r\n  4694,\r\n  4696,\r\n  4696,\r\n  4698,\r\n  4701,\r\n  4704,\r\n  4744,\r\n  4746,\r\n  4749,\r\n  4752,\r\n  4784,\r\n  4786,\r\n  4789,\r\n  4792,\r\n  4798,\r\n  4800,\r\n  4800,\r\n  4802,\r\n  4805,\r\n  4808,\r\n  4822,\r\n  4824,\r\n  4880,\r\n  4882,\r\n  4885,\r\n  4888,\r\n  4954,\r\n  4992,\r\n  5007,\r\n  5024,\r\n  5108,\r\n  5121,\r\n  5740,\r\n  5743,\r\n  5759,\r\n  5761,\r\n  5786,\r\n  5792,\r\n  5866,\r\n  5870,\r\n  5872,\r\n  5888,\r\n  5900,\r\n  5902,\r\n  5905,\r\n  5920,\r\n  5937,\r\n  5952,\r\n  5969,\r\n  5984,\r\n  5996,\r\n  5998,\r\n  6000,\r\n  6016,\r\n  6067,\r\n  6103,\r\n  6103,\r\n  6108,\r\n  6108,\r\n  6176,\r\n  6263,\r\n  6272,\r\n  6312,\r\n  6314,\r\n  6314,\r\n  6320,\r\n  6389,\r\n  6400,\r\n  6428,\r\n  6480,\r\n  6509,\r\n  6512,\r\n  6516,\r\n  6528,\r\n  6571,\r\n  6593,\r\n  6599,\r\n  6656,\r\n  6678,\r\n  6688,\r\n  6740,\r\n  6823,\r\n  6823,\r\n  6917,\r\n  6963,\r\n  6981,\r\n  6987,\r\n  7043,\r\n  7072,\r\n  7086,\r\n  7087,\r\n  7104,\r\n  7141,\r\n  7168,\r\n  7203,\r\n  7245,\r\n  7247,\r\n  7258,\r\n  7293,\r\n  7401,\r\n  7404,\r\n  7406,\r\n  7409,\r\n  7424,\r\n  7615,\r\n  7680,\r\n  7957,\r\n  7960,\r\n  7965,\r\n  7968,\r\n  8005,\r\n  8008,\r\n  8013,\r\n  8016,\r\n  8023,\r\n  8025,\r\n  8025,\r\n  8027,\r\n  8027,\r\n  8029,\r\n  8029,\r\n  8031,\r\n  8061,\r\n  8064,\r\n  8116,\r\n  8118,\r\n  8124,\r\n  8126,\r\n  8126,\r\n  8130,\r\n  8132,\r\n  8134,\r\n  8140,\r\n  8144,\r\n  8147,\r\n  8150,\r\n  8155,\r\n  8160,\r\n  8172,\r\n  8178,\r\n  8180,\r\n  8182,\r\n  8188,\r\n  8305,\r\n  8305,\r\n  8319,\r\n  8319,\r\n  8336,\r\n  8348,\r\n  8450,\r\n  8450,\r\n  8455,\r\n  8455,\r\n  8458,\r\n  8467,\r\n  8469,\r\n  8469,\r\n  8473,\r\n  8477,\r\n  8484,\r\n  8484,\r\n  8486,\r\n  8486,\r\n  8488,\r\n  8488,\r\n  8490,\r\n  8493,\r\n  8495,\r\n  8505,\r\n  8508,\r\n  8511,\r\n  8517,\r\n  8521,\r\n  8526,\r\n  8526,\r\n  8544,\r\n  8584,\r\n  11264,\r\n  11310,\r\n  11312,\r\n  11358,\r\n  11360,\r\n  11492,\r\n  11499,\r\n  11502,\r\n  11520,\r\n  11557,\r\n  11568,\r\n  11621,\r\n  11631,\r\n  11631,\r\n  11648,\r\n  11670,\r\n  11680,\r\n  11686,\r\n  11688,\r\n  11694,\r\n  11696,\r\n  11702,\r\n  11704,\r\n  11710,\r\n  11712,\r\n  11718,\r\n  11720,\r\n  11726,\r\n  11728,\r\n  11734,\r\n  11736,\r\n  11742,\r\n  11823,\r\n  11823,\r\n  12293,\r\n  12295,\r\n  12321,\r\n  12329,\r\n  12337,\r\n  12341,\r\n  12344,\r\n  12348,\r\n  12353,\r\n  12438,\r\n  12445,\r\n  12447,\r\n  12449,\r\n  12538,\r\n  12540,\r\n  12543,\r\n  12549,\r\n  12589,\r\n  12593,\r\n  12686,\r\n  12704,\r\n  12730,\r\n  12784,\r\n  12799,\r\n  13312,\r\n  13312,\r\n  19893,\r\n  19893,\r\n  19968,\r\n  19968,\r\n  40907,\r\n  40907,\r\n  40960,\r\n  42124,\r\n  42192,\r\n  42237,\r\n  42240,\r\n  42508,\r\n  42512,\r\n  42527,\r\n  42538,\r\n  42539,\r\n  42560,\r\n  42606,\r\n  42623,\r\n  42647,\r\n  42656,\r\n  42735,\r\n  42775,\r\n  42783,\r\n  42786,\r\n  42888,\r\n  42891,\r\n  42894,\r\n  42896,\r\n  42897,\r\n  42912,\r\n  42921,\r\n  43002,\r\n  43009,\r\n  43011,\r\n  43013,\r\n  43015,\r\n  43018,\r\n  43020,\r\n  43042,\r\n  43072,\r\n  43123,\r\n  43138,\r\n  43187,\r\n  43250,\r\n  43255,\r\n  43259,\r\n  43259,\r\n  43274,\r\n  43301,\r\n  43312,\r\n  43334,\r\n  43360,\r\n  43388,\r\n  43396,\r\n  43442,\r\n  43471,\r\n  43471,\r\n  43520,\r\n  43560,\r\n  43584,\r\n  43586,\r\n  43588,\r\n  43595,\r\n  43616,\r\n  43638,\r\n  43642,\r\n  43642,\r\n  43648,\r\n  43695,\r\n  43697,\r\n  43697,\r\n  43701,\r\n  43702,\r\n  43705,\r\n  43709,\r\n  43712,\r\n  43712,\r\n  43714,\r\n  43714,\r\n  43739,\r\n  43741,\r\n  43777,\r\n  43782,\r\n  43785,\r\n  43790,\r\n  43793,\r\n  43798,\r\n  43808,\r\n  43814,\r\n  43816,\r\n  43822,\r\n  43968,\r\n  44002,\r\n  44032,\r\n  44032,\r\n  55203,\r\n  55203,\r\n  55216,\r\n  55238,\r\n  55243,\r\n  55291,\r\n  63744,\r\n  64045,\r\n  64048,\r\n  64109,\r\n  64112,\r\n  64217,\r\n  64256,\r\n  64262,\r\n  64275,\r\n  64279,\r\n  64285,\r\n  64285,\r\n  64287,\r\n  64296,\r\n  64298,\r\n  64310,\r\n  64312,\r\n  64316,\r\n  64318,\r\n  64318,\r\n  64320,\r\n  64321,\r\n  64323,\r\n  64324,\r\n  64326,\r\n  64433,\r\n  64467,\r\n  64829,\r\n  64848,\r\n  64911,\r\n  64914,\r\n  64967,\r\n  65008,\r\n  65019,\r\n  65136,\r\n  65140,\r\n  65142,\r\n  65276,\r\n  65313,\r\n  65338,\r\n  65345,\r\n  65370,\r\n  65382,\r\n  65470,\r\n  65474,\r\n  65479,\r\n  65482,\r\n  65487,\r\n  65490,\r\n  65495,\r\n  65498,\r\n  65500,\r\n  65536,\r\n  65547,\r\n  65549,\r\n  65574,\r\n  65576,\r\n  65594,\r\n  65596,\r\n  65597,\r\n  65599,\r\n  65613,\r\n  65616,\r\n  65629,\r\n  65664,\r\n  65786,\r\n  65856,\r\n  65908,\r\n  66176,\r\n  66204,\r\n  66208,\r\n  66256,\r\n  66304,\r\n  66334,\r\n  66352,\r\n  66378,\r\n  66432,\r\n  66461,\r\n  66464,\r\n  66499,\r\n  66504,\r\n  66511,\r\n  66513,\r\n  66517,\r\n  66560,\r\n  66717,\r\n  67584,\r\n  67589,\r\n  67592,\r\n  67592,\r\n  67594,\r\n  67637,\r\n  67639,\r\n  67640,\r\n  67644,\r\n  67644,\r\n  67647,\r\n  67669,\r\n  67840,\r\n  67861,\r\n  67872,\r\n  67897,\r\n  68096,\r\n  68096,\r\n  68112,\r\n  68115,\r\n  68117,\r\n  68119,\r\n  68121,\r\n  68147,\r\n  68192,\r\n  68220,\r\n  68352,\r\n  68405,\r\n  68416,\r\n  68437,\r\n  68448,\r\n  68466,\r\n  68608,\r\n  68680,\r\n  69635,\r\n  69687,\r\n  69763,\r\n  69807,\r\n  73728,\r\n  74606,\r\n  74752,\r\n  74850,\r\n  77824,\r\n  78894,\r\n  92160,\r\n  92728,\r\n  110592,\r\n  110593,\r\n  119808,\r\n  119892,\r\n  119894,\r\n  119964,\r\n  119966,\r\n  119967,\r\n  119970,\r\n  119970,\r\n  119973,\r\n  119974,\r\n  119977,\r\n  119980,\r\n  119982,\r\n  119993,\r\n  119995,\r\n  119995,\r\n  119997,\r\n  120003,\r\n  120005,\r\n  120069,\r\n  120071,\r\n  120074,\r\n  120077,\r\n  120084,\r\n  120086,\r\n  120092,\r\n  120094,\r\n  120121,\r\n  120123,\r\n  120126,\r\n  120128,\r\n  120132,\r\n  120134,\r\n  120134,\r\n  120138,\r\n  120144,\r\n  120146,\r\n  120485,\r\n  120488,\r\n  120512,\r\n  120514,\r\n  120538,\r\n  120540,\r\n  120570,\r\n  120572,\r\n  120596,\r\n  120598,\r\n  120628,\r\n  120630,\r\n  120654,\r\n  120656,\r\n  120686,\r\n  120688,\r\n  120712,\r\n  120714,\r\n  120744,\r\n  120746,\r\n  120770,\r\n  120772,\r\n  120779,\r\n  131072,\r\n  131072,\r\n  173782,\r\n  173782,\r\n  173824,\r\n  173824,\r\n  177972,\r\n  177972,\r\n  177984,\r\n  177984,\r\n  178205,\r\n  178205,\r\n  194560,\r\n  195101,\r\n];\r\n\r\nconst identifierStartTable: any[] = [];\r\n\r\nfor (let i = 0; i < 128; i++) {\r\n  identifierStartTable[i] =\r\n    (i >= 48 && i <= 57) || // 0-9\r\n    i === 36 || // $\r\n    i === 126 || // ~\r\n    i === 124 || // |\r\n    (i >= 65 && i <= 90) || // A-Z\r\n    i === 95 || // _\r\n    i === 45 || // -\r\n    i === 42 || // *\r\n    i === 58 || // :\r\n    i === 91 || // templateStart [\r\n    i === 93 || // templateEnd ]\r\n    i === 63 || // ?\r\n    i === 37 || // %\r\n    i === 35 || // #\r\n    i === 61 || // =\r\n    (i >= 97 && i <= 122); // a-z\r\n}\r\n\r\nconst identifierPartTable = identifierStartTable;\r\n\r\nexport class Lexer {\r\n  input: any;\r\n  char: number;\r\n  from: number;\r\n\r\n  constructor(expression: any) {\r\n    this.input = expression;\r\n    this.char = 1;\r\n    this.from = 1;\r\n  }\r\n\r\n  peek(i?: number) {\r\n    return this.input.charAt(i || 0);\r\n  }\r\n\r\n  skip(i?: number) {\r\n    i = i || 1;\r\n    this.char += i;\r\n    this.input = this.input.slice(i);\r\n  }\r\n\r\n  tokenize() {\r\n    const list = [];\r\n    let token = this.next();\r\n    while (token) {\r\n      list.push(token);\r\n      token = this.next();\r\n    }\r\n    return list;\r\n  }\r\n\r\n  next() {\r\n    this.from = this.char;\r\n\r\n    // Move to the next non-space character.\r\n    if (/\\s/.test(this.peek())) {\r\n      while (/\\s/.test(this.peek())) {\r\n        this.from += 1;\r\n        this.skip();\r\n      }\r\n\r\n      if (this.peek() === '') {\r\n        // EOL\r\n        return null;\r\n      }\r\n    }\r\n\r\n    let match = this.scanStringLiteral();\r\n    if (match) {\r\n      return match;\r\n    }\r\n\r\n    match = this.scanPunctuator() || this.scanNumericLiteral() || this.scanIdentifier() || this.scanTemplateSequence();\r\n\r\n    if (match) {\r\n      this.skip(match.value.length);\r\n      return match;\r\n    }\r\n\r\n    // No token could be matched, give up.\r\n    return null;\r\n  }\r\n\r\n  scanTemplateSequence() {\r\n    if (this.peek() === '[' && this.peek(1) === '[') {\r\n      return {\r\n        type: 'templateStart',\r\n        value: '[[',\r\n        pos: this.char,\r\n      };\r\n    }\r\n\r\n    if (this.peek() === ']' && this.peek(1) === ']') {\r\n      return {\r\n        type: 'templateEnd',\r\n        value: '[[',\r\n        pos: this.char,\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /*\r\n   * Extract a JavaScript identifier out of the next sequence of\r\n   * characters or return 'null' if its not possible. In addition,\r\n   * to Identifier this method can also produce BooleanLiteral\r\n   * (true/false) and NullLiteral (null).\r\n   */\r\n  scanIdentifier() {\r\n    let id = '';\r\n    let index = 0;\r\n    let type, char;\r\n\r\n    // Detects any character in the Unicode categories \"Uppercase\r\n    // letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\r\n    // (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\r\n    // \"Letter number (Nl)\".\r\n    //\r\n    // Both approach and unicodeLetterTable were borrowed from\r\n    // Google's Traceur.\r\n\r\n    function isUnicodeLetter(code: number) {\r\n      for (let i = 0; i < unicodeLetterTable.length; ) {\r\n        if (code < unicodeLetterTable[i++]) {\r\n          return false;\r\n        }\r\n\r\n        if (code <= unicodeLetterTable[i++]) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    function isHexDigit(str: string) {\r\n      return /^[0-9a-fA-F]$/.test(str);\r\n    }\r\n\r\n    const readUnicodeEscapeSequence = _.bind(function(this: any) {\r\n      /*jshint validthis:true */\r\n      index += 1;\r\n\r\n      if (this.peek(index) !== 'u') {\r\n        return null;\r\n      }\r\n\r\n      const ch1 = this.peek(index + 1);\r\n      const ch2 = this.peek(index + 2);\r\n      const ch3 = this.peek(index + 3);\r\n      const ch4 = this.peek(index + 4);\r\n      let code;\r\n\r\n      if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\r\n        code = parseInt(ch1 + ch2 + ch3 + ch4, 16);\r\n\r\n        if (isUnicodeLetter(code)) {\r\n          index += 5;\r\n          return '\\\\u' + ch1 + ch2 + ch3 + ch4;\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      return null;\r\n    }, this);\r\n\r\n    const getIdentifierStart = _.bind(function(this: any) {\r\n      /*jshint validthis:true */\r\n      const chr = this.peek(index);\r\n      const code = chr.charCodeAt(0);\r\n\r\n      if (chr === '*') {\r\n        index += 1;\r\n        return chr;\r\n      }\r\n\r\n      if (code === 92) {\r\n        return readUnicodeEscapeSequence();\r\n      }\r\n\r\n      if (code < 128) {\r\n        if (identifierStartTable[code]) {\r\n          index += 1;\r\n          return chr;\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      if (isUnicodeLetter(code)) {\r\n        index += 1;\r\n        return chr;\r\n      }\r\n\r\n      return null;\r\n    }, this);\r\n\r\n    const getIdentifierPart = _.bind(function(this: any) {\r\n      /*jshint validthis:true */\r\n      const chr = this.peek(index);\r\n      const code = chr.charCodeAt(0);\r\n\r\n      if (code === 92) {\r\n        return readUnicodeEscapeSequence();\r\n      }\r\n\r\n      if (code < 128) {\r\n        if (identifierPartTable[code]) {\r\n          index += 1;\r\n          return chr;\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      if (isUnicodeLetter(code)) {\r\n        index += 1;\r\n        return chr;\r\n      }\r\n\r\n      return null;\r\n    }, this);\r\n\r\n    char = getIdentifierStart();\r\n    if (char === null) {\r\n      return null;\r\n    }\r\n\r\n    id = char;\r\n    for (;;) {\r\n      char = getIdentifierPart();\r\n\r\n      if (char === null) {\r\n        break;\r\n      }\r\n\r\n      id += char;\r\n    }\r\n\r\n    switch (id) {\r\n      case 'true': {\r\n        type = 'bool';\r\n        break;\r\n      }\r\n      case 'false': {\r\n        type = 'bool';\r\n        break;\r\n      }\r\n      default:\r\n        type = 'identifier';\r\n    }\r\n\r\n    return {\r\n      type: type,\r\n      value: id,\r\n      pos: this.char,\r\n    };\r\n  }\r\n\r\n  /*\r\n   * Extract a numeric literal out of the next sequence of\r\n   * characters or return 'null' if its not possible. This method\r\n   * supports all numeric literals described in section 7.8.3\r\n   * of the EcmaScript 5 specification.\r\n   *\r\n   * This method's implementation was heavily influenced by the\r\n   * scanNumericLiteral function in the Esprima parser's source code.\r\n   */\r\n  scanNumericLiteral(): any {\r\n    let index = 0;\r\n    let value = '';\r\n    const length = this.input.length;\r\n    let char = this.peek(index);\r\n    let bad;\r\n\r\n    function isDecimalDigit(str: string) {\r\n      return /^[0-9]$/.test(str);\r\n    }\r\n\r\n    function isOctalDigit(str: string) {\r\n      return /^[0-7]$/.test(str);\r\n    }\r\n\r\n    function isHexDigit(str: string) {\r\n      return /^[0-9a-fA-F]$/.test(str);\r\n    }\r\n\r\n    function isIdentifierStart(ch: string) {\r\n      return ch === '$' || ch === '_' || ch === '\\\\' || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\r\n    }\r\n\r\n    // handle negative num literals\r\n    if (char === '-') {\r\n      value += char;\r\n      index += 1;\r\n      char = this.peek(index);\r\n    }\r\n\r\n    // Numbers must start either with a decimal digit or a point.\r\n    if (char !== '.' && !isDecimalDigit(char)) {\r\n      return null;\r\n    }\r\n\r\n    if (char !== '.') {\r\n      value += this.peek(index);\r\n      index += 1;\r\n      char = this.peek(index);\r\n\r\n      if (value === '0') {\r\n        // Base-16 numbers.\r\n        if (char === 'x' || char === 'X') {\r\n          index += 1;\r\n          value += char;\r\n\r\n          while (index < length) {\r\n            char = this.peek(index);\r\n            if (!isHexDigit(char)) {\r\n              break;\r\n            }\r\n            value += char;\r\n            index += 1;\r\n          }\r\n\r\n          if (value.length <= 2) {\r\n            // 0x\r\n            return {\r\n              type: 'number',\r\n              value: value,\r\n              isMalformed: true,\r\n              pos: this.char,\r\n            };\r\n          }\r\n\r\n          if (index < length) {\r\n            char = this.peek(index);\r\n            if (isIdentifierStart(char)) {\r\n              return null;\r\n            }\r\n          }\r\n\r\n          return {\r\n            type: 'number',\r\n            value: value,\r\n            base: 16,\r\n            isMalformed: false,\r\n            pos: this.char,\r\n          };\r\n        }\r\n\r\n        // Base-8 numbers.\r\n        if (isOctalDigit(char)) {\r\n          index += 1;\r\n          value += char;\r\n          bad = false;\r\n\r\n          while (index < length) {\r\n            char = this.peek(index);\r\n\r\n            // Numbers like '019' (note the 9) are not valid octals\r\n            // but we still parse them and mark as malformed.\r\n\r\n            if (isDecimalDigit(char)) {\r\n              bad = true;\r\n            }\r\n            if (!isOctalDigit(char)) {\r\n              // if the char is a non punctuator then its not a valid number\r\n              if (!this.isPunctuator(char)) {\r\n                return null;\r\n              }\r\n              break;\r\n            }\r\n            value += char;\r\n            index += 1;\r\n          }\r\n\r\n          if (index < length) {\r\n            char = this.peek(index);\r\n            if (isIdentifierStart(char)) {\r\n              return null;\r\n            }\r\n          }\r\n\r\n          return {\r\n            type: 'number',\r\n            value: value,\r\n            base: 8,\r\n            isMalformed: bad,\r\n          };\r\n        }\r\n\r\n        // Decimal numbers that start with '0' such as '09' are illegal\r\n        // but we still parse them and return as malformed.\r\n\r\n        if (isDecimalDigit(char)) {\r\n          index += 1;\r\n          value += char;\r\n        }\r\n      }\r\n\r\n      while (index < length) {\r\n        char = this.peek(index);\r\n        if (!isDecimalDigit(char)) {\r\n          break;\r\n        }\r\n        value += char;\r\n        index += 1;\r\n      }\r\n    }\r\n\r\n    // Decimal digits.\r\n\r\n    if (char === '.') {\r\n      value += char;\r\n      index += 1;\r\n\r\n      while (index < length) {\r\n        char = this.peek(index);\r\n        if (!isDecimalDigit(char)) {\r\n          break;\r\n        }\r\n        value += char;\r\n        index += 1;\r\n      }\r\n    }\r\n\r\n    // Exponent part.\r\n\r\n    if (char === 'e' || char === 'E') {\r\n      value += char;\r\n      index += 1;\r\n      char = this.peek(index);\r\n\r\n      if (char === '+' || char === '-') {\r\n        value += this.peek(index);\r\n        index += 1;\r\n      }\r\n\r\n      char = this.peek(index);\r\n      if (isDecimalDigit(char)) {\r\n        value += char;\r\n        index += 1;\r\n\r\n        while (index < length) {\r\n          char = this.peek(index);\r\n          if (!isDecimalDigit(char)) {\r\n            break;\r\n          }\r\n          value += char;\r\n          index += 1;\r\n        }\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    if (index < length) {\r\n      char = this.peek(index);\r\n      if (!this.isPunctuator(char)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return {\r\n      type: 'number',\r\n      value: value,\r\n      base: 10,\r\n      pos: this.char,\r\n      isMalformed: !isFinite(+value),\r\n    };\r\n  }\r\n\r\n  isPunctuator(ch1: string) {\r\n    switch (ch1) {\r\n      case '.':\r\n      case '(':\r\n      case ')':\r\n      case ',':\r\n      case '{':\r\n      case '}':\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  scanPunctuator() {\r\n    const ch1 = this.peek();\r\n\r\n    if (this.isPunctuator(ch1)) {\r\n      return {\r\n        type: ch1,\r\n        value: ch1,\r\n        pos: this.char,\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /*\r\n   * Extract a string out of the next sequence of characters and/or\r\n   * lines or return 'null' if its not possible. Since strings can\r\n   * span across multiple lines this method has to move the char\r\n   * pointer.\r\n   *\r\n   * This method recognizes pseudo-multiline JavaScript strings:\r\n   *\r\n   *   var str = \"hello\\\r\n   *   world\";\r\n   */\r\n  scanStringLiteral() {\r\n    /*jshint loopfunc:true */\r\n    const quote = this.peek();\r\n\r\n    // String must start with a quote.\r\n    if (quote !== '\"' && quote !== \"'\") {\r\n      return null;\r\n    }\r\n\r\n    let value = '';\r\n\r\n    this.skip();\r\n\r\n    while (this.peek() !== quote) {\r\n      if (this.peek() === '') {\r\n        // End Of Line\r\n        return {\r\n          type: 'string',\r\n          value: value,\r\n          isUnclosed: true,\r\n          quote: quote,\r\n          pos: this.char,\r\n        };\r\n      }\r\n\r\n      const char = this.peek();\r\n      const jump = 1; // A length of a jump, after we're done\r\n      // parsing this character.\r\n\r\n      value += char;\r\n      this.skip(jump);\r\n    }\r\n\r\n    this.skip();\r\n    return {\r\n      type: 'string',\r\n      value: value,\r\n      isUnclosed: false,\r\n      quote: quote,\r\n      pos: this.char,\r\n    };\r\n  }\r\n}\r\n","export interface MetricTankResultMeta {\r\n  'schema-name': string;\r\n  'schema-retentions': string; //\"1s:35d:20min:5:1542274085,1min:38d:2h:1:true,10min:120d:6h:1:true,2h:2y:6h:2\",\r\n}\r\n\r\n// https://github.com/grafana/metrictank/blob/master/scripts/config/storage-schemas.conf#L15-L46\r\n\r\nexport interface RetentionInfo {\r\n  interval: string;\r\n  retention?: string;\r\n  chunkspan?: string;\r\n  numchunks?: number;\r\n  ready?: boolean | number; // whether, or as of what data timestamp, the archive is ready for querying.\r\n}\r\n\r\nfunction toInteger(val?: string): number | undefined {\r\n  if (val) {\r\n    return parseInt(val, 10);\r\n  }\r\n  return undefined;\r\n}\r\nfunction toBooleanOrTimestamp(val?: string): number | boolean | undefined {\r\n  if (val) {\r\n    if (val === 'true') {\r\n      return true;\r\n    }\r\n    if (val === 'false') {\r\n      return false;\r\n    }\r\n    return parseInt(val, 10);\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function parseSchemaRetentions(spec: string): RetentionInfo[] {\r\n  if (!spec) {\r\n    return [];\r\n  }\r\n  return spec.split(',').map(str => {\r\n    const vals = str.split(':');\r\n    return {\r\n      interval: vals[0],\r\n      retention: vals[1],\r\n      chunkspan: vals[2],\r\n      numchunks: toInteger(vals[3]),\r\n      ready: toBooleanOrTimestamp(vals[4]),\r\n    };\r\n  });\r\n}\r\n","import { GraphiteDatasource } from './datasource';\r\nimport { GraphiteQueryCtrl } from './query_ctrl';\r\nimport { DataSourcePlugin } from '@grafana/data';\r\nimport { ConfigEditor } from './configuration/ConfigEditor';\r\nimport { MetricTankMetaInspector } from './MetricTankMetaInspector';\r\n\r\nclass AnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n}\r\n\r\nexport const plugin = new DataSourcePlugin(GraphiteDatasource)\r\n  .setQueryCtrl(GraphiteQueryCtrl)\r\n  .setConfigEditor(ConfigEditor)\r\n  .setMetadataInspector(MetricTankMetaInspector)\r\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\r\n","import { Lexer } from './lexer';\n\nexport class Parser {\n  expression: any;\n  lexer: Lexer;\n  tokens: any;\n  index: number;\n\n  constructor(expression: any) {\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  getAst() {\n    return this.start();\n  }\n\n  start() {\n    try {\n      return this.functionCall() || this.metricExpression();\n    } catch (e) {\n      return {\n        type: 'error',\n        message: e.message,\n        pos: e.pos,\n      };\n    }\n  }\n\n  curlyBraceSegment() {\n    if (this.match('identifier', '{') || this.match('{')) {\n      let curlySegment = '';\n\n      while (!this.match('') && !this.match('}')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      if (!this.match('}')) {\n        this.errorMark(\"Expected closing '}'\");\n      }\n\n      curlySegment += this.consumeToken().value;\n\n      // if curly segment is directly followed by identifier\n      // include it in the segment\n      if (this.match('identifier')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      return {\n        type: 'segment',\n        value: curlySegment,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  metricSegment() {\n    const curly = this.curlyBraceSegment();\n    if (curly) {\n      return curly;\n    }\n\n    if (this.match('identifier') || this.match('number')) {\n      // hack to handle float numbers in metric segments\n      const parts = this.consumeToken().value.split('.');\n      if (parts.length === 2) {\n        this.tokens.splice(this.index, 0, { type: '.' });\n        this.tokens.splice(this.index + 1, 0, {\n          type: 'number',\n          value: parts[1],\n        });\n      }\n\n      return {\n        type: 'segment',\n        value: parts[0],\n      };\n    }\n\n    if (!this.match('templateStart')) {\n      this.errorMark('Expected metric identifier');\n    }\n\n    this.consumeToken();\n\n    if (!this.match('identifier')) {\n      this.errorMark('Expected identifier after templateStart');\n    }\n\n    const node = {\n      type: 'template',\n      value: this.consumeToken().value,\n    };\n\n    if (!this.match('templateEnd')) {\n      this.errorMark('Expected templateEnd');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  metricExpression() {\n    if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'metric',\n      segments: [],\n    };\n\n    node.segments.push(this.metricSegment());\n\n    while (this.match('.')) {\n      this.consumeToken();\n\n      const segment = this.metricSegment();\n      if (!segment) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      node.segments.push(segment);\n    }\n\n    return node;\n  }\n\n  functionCall() {\n    if (!this.match('identifier', '(')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'function',\n      name: this.consumeToken().value,\n    };\n\n    // consume left parenthesis\n    this.consumeToken();\n\n    node.params = this.functionParameters();\n\n    if (!this.match(')')) {\n      this.errorMark('Expected closing parenthesis');\n    }\n\n    this.consumeToken();\n\n    return node;\n  }\n\n  boolExpression() {\n    if (!this.match('bool')) {\n      return null;\n    }\n\n    return {\n      type: 'bool',\n      value: this.consumeToken().value === 'true',\n    };\n  }\n\n  functionParameters(): any {\n    if (this.match(')') || this.match('')) {\n      return [];\n    }\n\n    const param =\n      this.functionCall() ||\n      this.numericLiteral() ||\n      this.seriesRefExpression() ||\n      this.boolExpression() ||\n      this.metricExpression() ||\n      this.stringLiteral();\n\n    if (!this.match(',')) {\n      return [param];\n    }\n\n    this.consumeToken();\n    return [param].concat(this.functionParameters());\n  }\n\n  seriesRefExpression() {\n    if (!this.match('identifier')) {\n      return null;\n    }\n\n    const value = this.tokens[this.index].value;\n    if (!value.match(/\\#[A-Z]/)) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n\n    return {\n      type: 'series-ref',\n      value: token.value,\n    };\n  }\n\n  numericLiteral() {\n    if (!this.match('number')) {\n      return null;\n    }\n\n    return {\n      type: 'number',\n      value: parseFloat(this.consumeToken().value),\n    };\n  }\n\n  stringLiteral() {\n    if (!this.match('string')) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n    if (token.isUnclosed) {\n      throw { message: 'Unclosed string parameter', pos: token.pos };\n    }\n\n    return {\n      type: 'string',\n      value: token.value,\n    };\n  }\n\n  errorMark(text: string) {\n    const currentToken = this.tokens[this.index];\n    const type = currentToken ? currentToken.type : 'end of string';\n    throw {\n      message: text + ' instead found ' + type,\n      pos: currentToken ? currentToken.pos : this.lexer.char,\n    };\n  }\n\n  // returns token value and incre\n  consumeToken() {\n    this.index++;\n    return this.tokens[this.index - 1];\n  }\n\n  matchToken(type: any, index: number) {\n    const token = this.tokens[this.index + index];\n    return (token === undefined && type === '') || (token && token.type === type);\n  }\n\n  match(token1: any, token2?: any) {\n    return this.matchToken(token1, 0) && (!token2 || this.matchToken(token2, 1));\n  }\n}\n","import './add_graphite_func';\r\nimport './func_editor';\r\n\r\nimport _ from 'lodash';\r\nimport GraphiteQuery from './graphite_query';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport appEvents from 'app/core/app_events';\r\nimport { auto } from 'angular';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { AppEvents } from '@grafana/data';\r\n\r\nconst GRAPHITE_TAG_OPERATORS = ['=', '!=', '=~', '!=~'];\r\nconst TAG_PREFIX = 'tag: ';\r\n\r\nexport class GraphiteQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  queryModel: GraphiteQuery;\r\n  segments: any[];\r\n  addTagSegments: any[];\r\n  removeTagValue: string;\r\n  supportsTags: boolean;\r\n  paused: boolean;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    $scope: any,\r\n    $injector: auto.IInjectorService,\r\n    private uiSegmentSrv: any,\r\n    private templateSrv: TemplateSrv,\r\n    $timeout: any\r\n  ) {\r\n    super($scope, $injector);\r\n    this.supportsTags = this.datasource.supportsTags;\r\n    this.paused = false;\r\n    this.target.target = this.target.target || '';\r\n\r\n    this.datasource.waitForFuncDefsLoaded().then(() => {\r\n      this.queryModel = new GraphiteQuery(this.datasource, this.target, templateSrv);\r\n      this.buildSegments(false);\r\n    });\r\n\r\n    this.removeTagValue = '-- remove tag --';\r\n  }\r\n\r\n  parseTarget() {\r\n    this.queryModel.parseTarget();\r\n    this.buildSegments();\r\n  }\r\n\r\n  toggleEditorMode() {\r\n    this.target.textEditor = !this.target.textEditor;\r\n    this.parseTarget();\r\n  }\r\n\r\n  buildSegments(modifyLastSegment = true) {\r\n    this.segments = _.map(this.queryModel.segments, segment => {\r\n      return this.uiSegmentSrv.newSegment(segment);\r\n    });\r\n\r\n    const checkOtherSegmentsIndex = this.queryModel.checkOtherSegmentsIndex || 0;\r\n    this.checkOtherSegments(checkOtherSegmentsIndex, modifyLastSegment);\r\n\r\n    if (this.queryModel.seriesByTagUsed) {\r\n      this.fixTagSegments();\r\n    }\r\n  }\r\n\r\n  addSelectMetricSegment() {\r\n    this.queryModel.addSelectMetricSegment();\r\n    this.segments.push(this.uiSegmentSrv.newSelectMetric());\r\n  }\r\n\r\n  checkOtherSegments(fromIndex: number, modifyLastSegment = true) {\r\n    if (this.queryModel.segments.length === 1 && this.queryModel.segments[0].type === 'series-ref') {\r\n      return;\r\n    }\r\n\r\n    if (fromIndex === 0) {\r\n      this.addSelectMetricSegment();\r\n      return;\r\n    }\r\n\r\n    const path = this.queryModel.getSegmentPathUpTo(fromIndex + 1);\r\n    if (path === '') {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return this.datasource\r\n      .metricFindQuery(path)\r\n      .then((segments: any) => {\r\n        if (segments.length === 0) {\r\n          if (path !== '' && modifyLastSegment) {\r\n            this.queryModel.segments = this.queryModel.segments.splice(0, fromIndex);\r\n            this.segments = this.segments.splice(0, fromIndex);\r\n            this.addSelectMetricSegment();\r\n          }\r\n        } else if (segments[0].expandable) {\r\n          if (this.segments.length === fromIndex) {\r\n            this.addSelectMetricSegment();\r\n          } else {\r\n            return this.checkOtherSegments(fromIndex + 1);\r\n          }\r\n        }\r\n      })\r\n      .catch((err: any) => {\r\n        appEvents.emit(AppEvents.alertError, ['Error', err]);\r\n      });\r\n  }\r\n\r\n  setSegmentFocus(segmentIndex: any) {\r\n    _.each(this.segments, (segment, index) => {\r\n      segment.focus = segmentIndex === index;\r\n    });\r\n  }\r\n\r\n  getAltSegments(index: number, prefix: string) {\r\n    let query = prefix && prefix.length > 0 ? '*' + prefix + '*' : '*';\r\n    if (index > 0) {\r\n      query = this.queryModel.getSegmentPathUpTo(index) + '.' + query;\r\n    }\r\n    const options = {\r\n      range: this.panelCtrl.range,\r\n      requestId: 'get-alt-segments',\r\n    };\r\n\r\n    return this.datasource\r\n      .metricFindQuery(query, options)\r\n      .then((segments: any[]) => {\r\n        const altSegments = _.map(segments, segment => {\r\n          return this.uiSegmentSrv.newSegment({\r\n            value: segment.text,\r\n            expandable: segment.expandable,\r\n          });\r\n        });\r\n\r\n        if (index > 0 && altSegments.length === 0) {\r\n          return altSegments;\r\n        }\r\n\r\n        // add query references\r\n        if (index === 0) {\r\n          _.eachRight(this.panelCtrl.panel.targets, target => {\r\n            if (target.refId === this.queryModel.target.refId) {\r\n              return;\r\n            }\r\n\r\n            altSegments.unshift(\r\n              this.uiSegmentSrv.newSegment({\r\n                type: 'series-ref',\r\n                value: '#' + target.refId,\r\n                expandable: false,\r\n              })\r\n            );\r\n          });\r\n        }\r\n\r\n        // add template variables\r\n        _.eachRight(this.templateSrv.variables, variable => {\r\n          altSegments.unshift(\r\n            this.uiSegmentSrv.newSegment({\r\n              type: 'template',\r\n              value: '$' + variable.name,\r\n              expandable: true,\r\n            })\r\n          );\r\n        });\r\n\r\n        // add wildcard option\r\n        altSegments.unshift(this.uiSegmentSrv.newSegment('*'));\r\n\r\n        if (this.supportsTags && index === 0) {\r\n          this.removeTaggedEntry(altSegments);\r\n          return this.addAltTagSegments(prefix, altSegments);\r\n        } else {\r\n          return altSegments;\r\n        }\r\n      })\r\n      .catch((err: any): any[] => {\r\n        return [];\r\n      });\r\n  }\r\n\r\n  addAltTagSegments(prefix: string, altSegments: any[]) {\r\n    return this.getTagsAsSegments(prefix).then((tagSegments: any[]) => {\r\n      tagSegments = _.map(tagSegments, segment => {\r\n        segment.value = TAG_PREFIX + segment.value;\r\n        return segment;\r\n      });\r\n      return altSegments.concat(...tagSegments);\r\n    });\r\n  }\r\n\r\n  removeTaggedEntry(altSegments: any[]) {\r\n    altSegments = _.remove(altSegments, s => s.value === '_tagged');\r\n  }\r\n\r\n  segmentValueChanged(segment: { type: string; value: string; expandable: any }, segmentIndex: number) {\r\n    this.error = null;\r\n    this.queryModel.updateSegmentValue(segment, segmentIndex);\r\n\r\n    if (this.queryModel.functions.length > 0 && this.queryModel.functions[0].def.fake) {\r\n      this.queryModel.functions = [];\r\n    }\r\n\r\n    if (segment.type === 'tag') {\r\n      const tag = removeTagPrefix(segment.value);\r\n      this.pause();\r\n      this.addSeriesByTagFunc(tag);\r\n      return;\r\n    }\r\n\r\n    if (segment.expandable) {\r\n      return this.checkOtherSegments(segmentIndex + 1).then(() => {\r\n        this.setSegmentFocus(segmentIndex + 1);\r\n        this.targetChanged();\r\n      });\r\n    } else {\r\n      this.spliceSegments(segmentIndex + 1);\r\n    }\r\n\r\n    this.setSegmentFocus(segmentIndex + 1);\r\n    this.targetChanged();\r\n  }\r\n\r\n  spliceSegments(index: any) {\r\n    this.segments = this.segments.splice(0, index);\r\n    this.queryModel.segments = this.queryModel.segments.splice(0, index);\r\n  }\r\n\r\n  emptySegments() {\r\n    this.queryModel.segments = [];\r\n    this.segments = [];\r\n  }\r\n\r\n  targetTextChanged() {\r\n    this.updateModelTarget();\r\n    this.refresh();\r\n  }\r\n\r\n  updateModelTarget() {\r\n    this.queryModel.updateModelTarget(this.panelCtrl.panel.targets);\r\n  }\r\n\r\n  targetChanged() {\r\n    if (this.queryModel.error) {\r\n      return;\r\n    }\r\n\r\n    const oldTarget = this.queryModel.target.target;\r\n    this.updateModelTarget();\r\n\r\n    if (this.queryModel.target !== oldTarget && !this.paused) {\r\n      this.panelCtrl.refresh();\r\n    }\r\n  }\r\n\r\n  addFunction(funcDef: any) {\r\n    const newFunc = this.datasource.createFuncInstance(funcDef, {\r\n      withDefaultParams: true,\r\n    });\r\n    newFunc.added = true;\r\n    this.queryModel.addFunction(newFunc);\r\n    this.smartlyHandleNewAliasByNode(newFunc);\r\n\r\n    if (this.segments.length === 1 && this.segments[0].fake) {\r\n      this.emptySegments();\r\n    }\r\n\r\n    if (!newFunc.params.length && newFunc.added) {\r\n      this.targetChanged();\r\n    }\r\n\r\n    if (newFunc.def.name === 'seriesByTag') {\r\n      this.parseTarget();\r\n    }\r\n  }\r\n\r\n  removeFunction(func: any) {\r\n    this.queryModel.removeFunction(func);\r\n    this.targetChanged();\r\n  }\r\n\r\n  moveFunction(func: any, offset: any) {\r\n    this.queryModel.moveFunction(func, offset);\r\n    this.targetChanged();\r\n  }\r\n\r\n  addSeriesByTagFunc(tag: string) {\r\n    const newFunc = this.datasource.createFuncInstance('seriesByTag', {\r\n      withDefaultParams: false,\r\n    });\r\n    const tagParam = `${tag}=`;\r\n    newFunc.params = [tagParam];\r\n    this.queryModel.addFunction(newFunc);\r\n    newFunc.added = true;\r\n\r\n    this.emptySegments();\r\n    this.targetChanged();\r\n    this.parseTarget();\r\n  }\r\n\r\n  smartlyHandleNewAliasByNode(func: { def: { name: string }; params: number[]; added: boolean }) {\r\n    if (func.def.name !== 'aliasByNode') {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < this.segments.length; i++) {\r\n      if (this.segments[i].value.indexOf('*') >= 0) {\r\n        func.params[0] = i;\r\n        func.added = false;\r\n        this.targetChanged();\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  getAllTags() {\r\n    return this.datasource.getTags().then((values: any[]) => {\r\n      const altTags = _.map(values, 'text');\r\n      altTags.splice(0, 0, this.removeTagValue);\r\n      return mapToDropdownOptions(altTags);\r\n    });\r\n  }\r\n\r\n  getTags(index: number, tagPrefix: any) {\r\n    const tagExpressions = this.queryModel.renderTagExpressions(index);\r\n    return this.datasource.getTagsAutoComplete(tagExpressions, tagPrefix).then((values: any) => {\r\n      const altTags = _.map(values, 'text');\r\n      altTags.splice(0, 0, this.removeTagValue);\r\n      return mapToDropdownOptions(altTags);\r\n    });\r\n  }\r\n\r\n  getTagsAsSegments(tagPrefix: string) {\r\n    const tagExpressions = this.queryModel.renderTagExpressions();\r\n    return this.datasource.getTagsAutoComplete(tagExpressions, tagPrefix).then((values: any) => {\r\n      return _.map(values, val => {\r\n        return this.uiSegmentSrv.newSegment({\r\n          value: val.text,\r\n          type: 'tag',\r\n          expandable: false,\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  getTagOperators() {\r\n    return mapToDropdownOptions(GRAPHITE_TAG_OPERATORS);\r\n  }\r\n\r\n  getAllTagValues(tag: { key: any }) {\r\n    const tagKey = tag.key;\r\n    return this.datasource.getTagValues(tagKey).then((values: any[]) => {\r\n      const altValues = _.map(values, 'text');\r\n      return mapToDropdownOptions(altValues);\r\n    });\r\n  }\r\n\r\n  getTagValues(tag: { key: any }, index: number, valuePrefix: any) {\r\n    const tagExpressions = this.queryModel.renderTagExpressions(index);\r\n    const tagKey = tag.key;\r\n    return this.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix).then((values: any[]) => {\r\n      const altValues = _.map(values, 'text');\r\n      // Add template variables as additional values\r\n      _.eachRight(this.templateSrv.variables, variable => {\r\n        altValues.push('${' + variable.name + ':regex}');\r\n      });\r\n      return mapToDropdownOptions(altValues);\r\n    });\r\n  }\r\n\r\n  tagChanged(tag: any, tagIndex: any) {\r\n    this.queryModel.updateTag(tag, tagIndex);\r\n    this.targetChanged();\r\n  }\r\n\r\n  addNewTag(segment: { value: any }) {\r\n    const newTagKey = segment.value;\r\n    const newTag = { key: newTagKey, operator: '=', value: '' };\r\n    this.queryModel.addTag(newTag);\r\n    this.targetChanged();\r\n    this.fixTagSegments();\r\n  }\r\n\r\n  removeTag(index: any) {\r\n    this.queryModel.removeTag(index);\r\n    this.targetChanged();\r\n  }\r\n\r\n  fixTagSegments() {\r\n    // Adding tag with the same name as just removed works incorrectly if single segment is used (instead of array)\r\n    this.addTagSegments = [this.uiSegmentSrv.newPlusButton()];\r\n  }\r\n\r\n  showDelimiter(index: number) {\r\n    return index !== this.queryModel.tags.length - 1;\r\n  }\r\n\r\n  pause() {\r\n    this.paused = true;\r\n  }\r\n\r\n  unpause() {\r\n    this.paused = false;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  getCollapsedText() {\r\n    return this.target.target;\r\n  }\r\n}\r\n\r\nfunction mapToDropdownOptions(results: any[]) {\r\n  return _.map(results, value => {\r\n    return { text: value, value: value };\r\n  });\r\n}\r\n\r\nfunction removeTagPrefix(value: string): string {\r\n  return value.replace(TAG_PREFIX, '');\r\n}\r\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\r\n\r\nexport interface GraphiteQuery extends DataQuery {\r\n  target?: string;\r\n}\r\n\r\nexport interface GraphiteOptions extends DataSourceJsonData {\r\n  graphiteVersion: string;\r\n  graphiteType: GraphiteType;\r\n}\r\n\r\nexport enum GraphiteType {\r\n  Default = 'default',\r\n  Metrictank = 'metrictank',\r\n}\r\n\r\nexport interface MetricTankRequestMeta {\r\n  [key: string]: any; // TODO -- fill this with real values from metrictank\r\n}\r\n\r\nexport interface MetricTankResultMeta {\r\n  'schema-name': string;\r\n  'schema-retentions': string; //\"1s:35d:20min:5:1542274085,1min:38d:2h:1:true,10min:120d:6h:1:true,2h:2y:6h:2\",\r\n  'archive-read': number;\r\n  'archive-interval': number;\r\n  'aggnum-norm': number;\r\n  'consolidate-normfetch': string; //\"MaximumConsolidator\",\r\n  'aggnum-rc': number;\r\n  'consolidate-rc': string; //\"MaximumConsolidator\",\r\n  count: number;\r\n}\r\n\r\nexport interface MetricTankMeta {\r\n  request: MetricTankRequestMeta;\r\n  info: MetricTankResultMeta[];\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AACA;AAAA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9CA;AAIA;AAQA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAKA;AAGA;;AAqBA;AAnBA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;AClKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AAKA;AAGA;;;;;;;;;;;;;;;;;;;;;ACnBA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAWA;AAAA;AACA;AAAA;AAQA;;AACA;AACA;AAOA;AAdA;AACA;AACA;;AACA;AAaA;AAAA;;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AAOA;AACA;AACA;AAOA;AAKA;AAAA;;AAGA;AAGA;AAEA;AACA;;AAEA;AACA;AAEA;AAGA;AAOA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AACA;AASA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AAaA;AACA;AAAA;AAAA;AAAA;AALA;AACA;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACzoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnrCA;AACA;AAIA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9SA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACn6CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AChQA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAAA;AAUA;AACA;AAAA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3YA;AA4YA;AAAA;AA7YA;AA+YA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AC1ZA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;A","sourceRoot":""}