{"version":3,"file":"influxdbPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/features/explore/AdHocFilter.tsx","webpack:///webpack:///./public/app/features/explore/AdHocFilterField.tsx","webpack:///webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///webpack:///./public/app/plugins/datasource/influxdb/components/InfluxLogsQueryField.tsx","webpack:///webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/module.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts"],"sourcesContent":["import React, { useContext } from 'react';\r\nimport { Select, ThemeContext } from '@grafana/ui';\r\nimport { css, cx } from 'emotion';\r\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\r\n\r\nconst getStyles = (theme: GrafanaTheme) => ({\r\n  keyValueContainer: css`\r\n    label: key-value-container;\r\n    display: flex;\r\n    flex-flow: row nowrap;\r\n  `,\r\n});\r\n\r\nenum ChangeType {\r\n  Key = 'key',\r\n  Value = 'value',\r\n  Operator = 'operator',\r\n}\r\n\r\nexport interface Props {\r\n  keys: string[];\r\n  keysPlaceHolder?: string;\r\n  initialKey?: string;\r\n  initialOperator?: string;\r\n  initialValue?: string;\r\n  values?: string[];\r\n  valuesPlaceHolder?: string;\r\n  onKeyChanged: (key: string) => void;\r\n  onValueChanged: (value: string) => void;\r\n  onOperatorChanged: (operator: string) => void;\r\n}\r\n\r\nexport const AdHocFilter: React.FunctionComponent<Props> = props => {\r\n  const theme = useContext(ThemeContext);\r\n  const styles = getStyles(theme);\r\n\r\n  const onChange = (changeType: ChangeType) => (item: SelectableValue<string>) => {\r\n    const { onKeyChanged, onValueChanged, onOperatorChanged } = props;\r\n\r\n    if (!item.value) {\r\n      return;\r\n    }\r\n\r\n    switch (changeType) {\r\n      case ChangeType.Key:\r\n        onKeyChanged(item.value);\r\n        break;\r\n      case ChangeType.Operator:\r\n        onOperatorChanged(item.value);\r\n        break;\r\n      case ChangeType.Value:\r\n        onValueChanged(item.value);\r\n        break;\r\n    }\r\n  };\r\n\r\n  const stringToOption = (value: string) => ({ label: value, value: value });\r\n\r\n  const { keys, initialKey, keysPlaceHolder, initialOperator, values, initialValue, valuesPlaceHolder } = props;\r\n  const operators = ['=', '!='];\r\n  const keysAsOptions = keys ? keys.map(stringToOption) : [];\r\n  const selectedKey = initialKey ? keysAsOptions.filter(option => option.value === initialKey) : undefined;\r\n  const valuesAsOptions = values ? values.map(stringToOption) : [];\r\n  const selectedValue = initialValue ? valuesAsOptions.filter(option => option.value === initialValue) : undefined;\r\n  const operatorsAsOptions = operators.map(stringToOption);\r\n  const selectedOperator = initialOperator\r\n    ? operatorsAsOptions.filter(option => option.value === initialOperator)\r\n    : undefined;\r\n\r\n  return (\r\n    <div className={cx([styles.keyValueContainer])}>\r\n      <Select\r\n        options={keysAsOptions}\r\n        isSearchable\r\n        value={selectedKey}\r\n        onChange={onChange(ChangeType.Key)}\r\n        placeholder={keysPlaceHolder}\r\n      />\r\n      <Select options={operatorsAsOptions} value={selectedOperator} onChange={onChange(ChangeType.Operator)} />\r\n      <Select\r\n        options={valuesAsOptions}\r\n        isSearchable\r\n        value={selectedValue}\r\n        onChange={onChange(ChangeType.Value)}\r\n        placeholder={valuesPlaceHolder}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport _ from 'lodash';\r\nimport { DataSourceApi, DataQuery, DataSourceJsonData } from '@grafana/data';\r\nimport { AdHocFilter } from './AdHocFilter';\r\nexport const DEFAULT_REMOVE_FILTER_VALUE = '-- remove filter --';\r\n\r\nconst addFilterButton = (onAddFilter: (event: React.MouseEvent) => void) => (\r\n  <button className=\"gf-form-label gf-form-label--btn query-part\" onClick={onAddFilter}>\r\n    <i className=\"fa fa-plus\" />\r\n  </button>\r\n);\r\n\r\nexport interface KeyValuePair {\r\n  keys: string[];\r\n  key: string;\r\n  operator: string;\r\n  value: string;\r\n  values: string[];\r\n}\r\n\r\nexport interface Props<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {\r\n  datasource: DataSourceApi<TQuery, TOptions>;\r\n  onPairsChanged: (pairs: KeyValuePair[]) => void;\r\n  extendedOptions?: any;\r\n}\r\n\r\nexport interface State {\r\n  pairs: KeyValuePair[];\r\n}\r\n\r\nexport class AdHocFilterField<\r\n  TQuery extends DataQuery = DataQuery,\r\n  TOptions extends DataSourceJsonData = DataSourceJsonData\r\n> extends React.PureComponent<Props<TQuery, TOptions>, State> {\r\n  state: State = { pairs: [] };\r\n\r\n  componentDidUpdate(prevProps: Props<TQuery, TOptions>) {\r\n    if (_.isEqual(prevProps.extendedOptions, this.props.extendedOptions) === false) {\r\n      const pairs: any[] = [];\r\n\r\n      this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\r\n    }\r\n  }\r\n\r\n  loadTagKeys = async () => {\r\n    const { datasource, extendedOptions } = this.props;\r\n    const options = extendedOptions || {};\r\n    const tagKeys = datasource.getTagKeys ? await datasource.getTagKeys(options) : [];\r\n    const keys = tagKeys.map(tagKey => tagKey.text);\r\n\r\n    return keys;\r\n  };\r\n\r\n  loadTagValues = async (key: string) => {\r\n    const { datasource, extendedOptions } = this.props;\r\n    const options = extendedOptions || {};\r\n    const tagValues = datasource.getTagValues ? await datasource.getTagValues({ ...options, key }) : [];\r\n    const values = tagValues.map(tagValue => tagValue.text);\r\n\r\n    return values;\r\n  };\r\n\r\n  updatePairs(pairs: KeyValuePair[], index: number, pair: Partial<KeyValuePair>) {\r\n    if (pairs.length === 0) {\r\n      return [\r\n        {\r\n          key: pair.key || '',\r\n          keys: pair.keys || [],\r\n          operator: pair.operator || '',\r\n          value: pair.value || '',\r\n          values: pair.values || [],\r\n        },\r\n      ];\r\n    }\r\n\r\n    const newPairs: KeyValuePair[] = [];\r\n    for (let pairIndex = 0; pairIndex < pairs.length; pairIndex++) {\r\n      const newPair = pairs[pairIndex];\r\n      if (index === pairIndex) {\r\n        newPairs.push({\r\n          ...newPair,\r\n          key: pair.key || newPair.key,\r\n          value: pair.value || newPair.value,\r\n          operator: pair.operator || newPair.operator,\r\n          keys: pair.keys || newPair.keys,\r\n          values: pair.values || newPair.values,\r\n        });\r\n        continue;\r\n      }\r\n\r\n      newPairs.push(newPair);\r\n    }\r\n\r\n    return newPairs;\r\n  }\r\n\r\n  onKeyChanged = (index: number) => async (key: string) => {\r\n    if (key !== DEFAULT_REMOVE_FILTER_VALUE) {\r\n      const { onPairsChanged } = this.props;\r\n      const values = await this.loadTagValues(key);\r\n      const pairs = this.updatePairs(this.state.pairs, index, { key, values });\r\n\r\n      this.setState({ pairs }, () => onPairsChanged(pairs));\r\n    } else {\r\n      this.onRemoveFilter(index);\r\n    }\r\n  };\r\n\r\n  onValueChanged = (index: number) => (value: string) => {\r\n    const pairs = this.updatePairs(this.state.pairs, index, { value });\r\n\r\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\r\n  };\r\n\r\n  onOperatorChanged = (index: number) => (operator: string) => {\r\n    const pairs = this.updatePairs(this.state.pairs, index, { operator });\r\n\r\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\r\n  };\r\n\r\n  onAddFilter = async () => {\r\n    const keys = await this.loadTagKeys();\r\n    const pairs = this.state.pairs.concat(this.updatePairs([], 0, { keys }));\r\n\r\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\r\n  };\r\n\r\n  onRemoveFilter = async (index: number) => {\r\n    const pairs = this.state.pairs.reduce((allPairs, pair, pairIndex) => {\r\n      if (pairIndex === index) {\r\n        return allPairs;\r\n      }\r\n      return allPairs.concat(pair);\r\n    }, [] as KeyValuePair[]);\r\n\r\n    this.setState({ pairs });\r\n  };\r\n\r\n  render() {\r\n    const { pairs } = this.state;\r\n    return (\r\n      <>\r\n        {pairs.length < 1 && addFilterButton(this.onAddFilter)}\r\n        {pairs.map((pair, index) => {\r\n          const adHocKey = `adhoc-filter-${index}-${pair.key}-${pair.value}`;\r\n          return (\r\n            <div className=\"align-items-center flex-grow-1\" key={adHocKey}>\r\n              <AdHocFilter\r\n                keys={[DEFAULT_REMOVE_FILTER_VALUE].concat(pair.keys)}\r\n                values={pair.values}\r\n                initialKey={pair.key}\r\n                initialOperator={pair.operator}\r\n                initialValue={pair.value}\r\n                onKeyChanged={this.onKeyChanged(index)}\r\n                onOperatorChanged={this.onOperatorChanged(index)}\r\n                onValueChanged={this.onValueChanged(index)}\r\n              />\r\n              {index < pairs.length - 1 && <span>&nbsp;AND&nbsp;</span>}\r\n              {index === pairs.length - 1 && addFilterButton(this.onAddFilter)}\r\n            </div>\r\n          );\r\n        })}\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react';\r\nimport {\r\n  DataSourcePluginOptionsEditorProps,\r\n  SelectableValue,\r\n  onUpdateDatasourceOption,\r\n  updateDatasourcePluginResetOption,\r\n  onUpdateDatasourceJsonDataOption,\r\n  onUpdateDatasourceJsonDataOptionSelect,\r\n  onUpdateDatasourceSecureJsonDataOption,\r\n} from '@grafana/data';\r\nimport { DataSourceHttpSettings, FormLabel, Input, SecretFormField, Select } from '@grafana/ui';\r\nimport { InfluxOptions, InfluxSecureJsonData } from '../types';\r\n\r\nconst httpModes = [\r\n  { label: 'GET', value: 'GET' },\r\n  { label: 'POST', value: 'POST' },\r\n] as SelectableValue[];\r\n\r\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\r\n\r\nexport class ConfigEditor extends PureComponent<Props> {\r\n  onResetPassword = () => {\r\n    updateDatasourcePluginResetOption(this.props, 'password');\r\n  };\r\n\r\n  render() {\r\n    const { options, onOptionsChange } = this.props;\r\n    const { secureJsonFields } = options;\r\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\r\n    return (\r\n      <>\r\n        <DataSourceHttpSettings\r\n          showAccessOptions={true}\r\n          dataSourceConfig={options}\r\n          defaultUrl=\"http://localhost:8086\"\r\n          onChange={onOptionsChange}\r\n        />\r\n\r\n        <h3 className=\"page-heading\">InfluxDB Details</h3>\r\n        <div className=\"gf-form-group\">\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form\">\r\n              <FormLabel className=\"width-10\">Database</FormLabel>\r\n              <div className=\"width-20\">\r\n                <Input\r\n                  className=\"width-20\"\r\n                  value={options.database || ''}\r\n                  onChange={onUpdateDatasourceOption(this.props, 'database')}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form\">\r\n              <FormLabel className=\"width-10\">User</FormLabel>\r\n              <div className=\"width-10\">\r\n                <Input\r\n                  className=\"width-20\"\r\n                  value={options.user || ''}\r\n                  onChange={onUpdateDatasourceOption(this.props, 'user')}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form\">\r\n              <SecretFormField\r\n                isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\r\n                value={secureJsonData.password || ''}\r\n                label=\"Password\"\r\n                labelWidth={10}\r\n                inputWidth={20}\r\n                onReset={this.onResetPassword}\r\n                onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\r\n              />\r\n            </div>\r\n          </div>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form\">\r\n              <FormLabel\r\n                className=\"width-10\"\r\n                tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\r\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\r\n          will restrict you and return an error if the query is too large.\"\r\n              >\r\n                HTTP Method\r\n              </FormLabel>\r\n              <Select\r\n                className=\"width-10\"\r\n                value={httpModes.find(httpMode => httpMode.value === options.jsonData.httpMode)}\r\n                options={httpModes}\r\n                defaultValue={options.jsonData.httpMode}\r\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"gf-form-group\">\r\n          <div className=\"grafana-info-box\">\r\n            <h5>Database Access</h5>\r\n            <p>\r\n              Setting the database for this datasource does not deny access to other databases. The InfluxDB query\r\n              syntax allows switching the database in the query. For example:\r\n              <code>SHOW MEASUREMENTS ON _internal</code> or <code>SELECT * FROM \"_internal\"..\"database\" LIMIT 10</code>\r\n              <br />\r\n              <br />\r\n              To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\r\n            </p>\r\n          </div>\r\n        </div>\r\n        <div className=\"gf-form-group\">\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form\">\r\n              <FormLabel\r\n                className=\"width-10\"\r\n                tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\r\n\t\t\t\tfor example 1m if your data is written every minute.\"\r\n              >\r\n                Min time interval\r\n              </FormLabel>\r\n              <div className=\"width-10\">\r\n                <Input\r\n                  className=\"width-10\"\r\n                  placeholder=\"10s\"\r\n                  value={options.jsonData.timeInterval || ''}\r\n                  onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ConfigEditor;\r\n","import React from 'react';\r\n\r\nconst CHEAT_SHEET_ITEMS = [\r\n  {\r\n    title: 'Getting started',\r\n    label:\r\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\r\n  },\r\n];\r\n\r\nexport default (props: any) => (\r\n  <div>\r\n    <h2>InfluxDB Cheat Sheet</h2>\r\n    {CHEAT_SHEET_ITEMS.map(item => (\r\n      <div className=\"cheat-sheet-item\" key={item.title}>\r\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\r\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\r\n      </div>\r\n    ))}\r\n  </div>\r\n);\r\n","import React from 'react';\r\nimport { ExploreQueryFieldProps } from '@grafana/data';\r\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\r\n\r\nimport InfluxQueryModel from '../influx_query_model';\r\nimport { AdHocFilterField, KeyValuePair } from 'app/features/explore/AdHocFilterField';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport InfluxDatasource from '../datasource';\r\nimport { InfluxQueryBuilder } from '../query_builder';\r\nimport { InfluxQuery, InfluxOptions } from '../types';\r\n\r\nexport interface Props extends ExploreQueryFieldProps<InfluxDatasource, InfluxQuery, InfluxOptions> {}\r\n\r\nexport interface State {\r\n  measurements: CascaderOption[];\r\n  measurement: string;\r\n  field: string;\r\n  error: string;\r\n}\r\n\r\ninterface ChooserOptions {\r\n  measurement: string;\r\n  field: string;\r\n  error: string;\r\n}\r\n\r\n// Helper function for determining if a collection of pairs are valid\r\n// where a valid pair is either fully defined, or not defined at all, but not partially defined\r\nexport function pairsAreValid(pairs: KeyValuePair[]) {\r\n  return (\r\n    !pairs ||\r\n    pairs.every(pair => {\r\n      const allDefined = !!(pair.key && pair.operator && pair.value);\r\n      const allEmpty = pair.key === undefined && pair.operator === undefined && pair.value === undefined;\r\n      return allDefined || allEmpty;\r\n    })\r\n  );\r\n}\r\n\r\nfunction getChooserText({ measurement, field, error }: ChooserOptions): string {\r\n  if (error) {\r\n    return '(No measurement found)';\r\n  }\r\n  if (measurement) {\r\n    return `Measurements (${measurement}/${field})`;\r\n  }\r\n  return 'Measurements';\r\n}\r\n\r\nexport class InfluxLogsQueryField extends React.PureComponent<Props, State> {\r\n  templateSrv: TemplateSrv = new TemplateSrv();\r\n  state: State = { measurements: [], measurement: null, field: null, error: null };\r\n\r\n  async componentDidMount() {\r\n    const { datasource } = this.props;\r\n    try {\r\n      const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, datasource.database);\r\n      const measureMentsQuery = queryBuilder.buildExploreQuery('MEASUREMENTS');\r\n      const influxMeasurements = await datasource.metricFindQuery(measureMentsQuery);\r\n\r\n      const measurements = [];\r\n      for (let index = 0; index < influxMeasurements.length; index++) {\r\n        const measurementObj = influxMeasurements[index];\r\n        const queryBuilder = new InfluxQueryBuilder(\r\n          { measurement: measurementObj.text, tags: [] },\r\n          datasource.database\r\n        );\r\n        const fieldsQuery = queryBuilder.buildExploreQuery('FIELDS');\r\n        const influxFields = await datasource.metricFindQuery(fieldsQuery);\r\n        const fields: any[] = influxFields.map((field: any): any => ({\r\n          label: field.text,\r\n          value: field.text,\r\n          children: [],\r\n        }));\r\n        measurements.push({\r\n          label: measurementObj.text,\r\n          value: measurementObj.text,\r\n          items: fields,\r\n        });\r\n      }\r\n      this.setState({ measurements });\r\n    } catch (error) {\r\n      const message = error && error.message ? error.message : error;\r\n      this.setState({ error: message });\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps: Props) {\r\n    if (prevProps.query.measurement && !this.props.query.measurement) {\r\n      this.setState({ measurement: null, field: null });\r\n    }\r\n  }\r\n\r\n  onMeasurementsChange = async (values: string[]) => {\r\n    const { query } = this.props;\r\n    const measurement = values[0];\r\n    const field = values[1];\r\n\r\n    this.setState({ measurement, field }, () => {\r\n      this.onPairsChanged((query as any).tags);\r\n    });\r\n  };\r\n\r\n  onPairsChanged = (pairs: KeyValuePair[]) => {\r\n    const { query } = this.props;\r\n    const { measurement, field } = this.state;\r\n    const queryModel = new InfluxQueryModel(\r\n      {\r\n        ...query,\r\n        resultFormat: 'table',\r\n        groupBy: [],\r\n        select: [[{ type: 'field', params: [field] }]],\r\n        tags: pairs,\r\n        limit: '1000',\r\n        measurement,\r\n      },\r\n      this.templateSrv\r\n    );\r\n\r\n    this.props.onChange(queryModel.target);\r\n\r\n    // Only run the query if measurement & field are set, and there are no invalid pairs\r\n    if (measurement && field && pairsAreValid(pairs)) {\r\n      this.props.onRunQuery();\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { datasource } = this.props;\r\n    const { measurements, measurement, field, error } = this.state;\r\n    const cascadeText = getChooserText({ measurement, field, error });\r\n    const hasMeasurement = measurements && measurements.length > 0;\r\n\r\n    return (\r\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\r\n        <div className=\"gf-form flex-shrink-0\">\r\n          <ButtonCascader\r\n            options={measurements}\r\n            disabled={!hasMeasurement}\r\n            value={[measurement, field]}\r\n            onChange={this.onMeasurementsChange}\r\n          >\r\n            {cascadeText}\r\n          </ButtonCascader>\r\n        </div>\r\n        <div className=\"flex-shrink-1 flex-flow-column-nowrap\">\r\n          {measurement && (\r\n            <AdHocFilterField\r\n              onPairsChanged={this.onPairsChanged}\r\n              datasource={datasource}\r\n              extendedOptions={{ measurement }}\r\n            />\r\n          )}\r\n          {error ? (\r\n            <span className=\"gf-form-label gf-form-label--transparent gf-form-label--error m-l-2\">{error}</span>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react';\r\nimport { ExploreStartPageProps } from '@grafana/data';\r\nimport InfluxCheatSheet from './InfluxCheatSheet';\r\n\r\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\r\n  render() {\r\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\r\n  }\r\n}\r\n","import _ from 'lodash';\r\n\r\nimport { dateMath, DataSourceApi, DataSourceInstanceSettings, ScopedVars } from '@grafana/data';\r\nimport InfluxSeries from './influx_series';\r\nimport InfluxQueryModel from './influx_query_model';\r\nimport ResponseParser from './response_parser';\r\nimport { InfluxQueryBuilder } from './query_builder';\r\nimport { InfluxQuery, InfluxOptions } from './types';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\nexport default class InfluxDatasource extends DataSourceApi<InfluxQuery, InfluxOptions> {\r\n  type: string;\r\n  urls: any;\r\n  username: string;\r\n  password: string;\r\n  name: string;\r\n  database: any;\r\n  basicAuth: any;\r\n  withCredentials: any;\r\n  interval: any;\r\n  responseParser: any;\r\n  httpMode: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv\r\n  ) {\r\n    super(instanceSettings);\r\n    this.type = 'influxdb';\r\n    this.urls = _.map(instanceSettings.url.split(','), url => {\r\n      return url.trim();\r\n    });\r\n\r\n    this.username = instanceSettings.username;\r\n    this.password = instanceSettings.password;\r\n    this.name = instanceSettings.name;\r\n    this.database = instanceSettings.database;\r\n    this.basicAuth = instanceSettings.basicAuth;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\r\n    this.interval = settingsData.timeInterval;\r\n    this.httpMode = settingsData.httpMode || 'GET';\r\n    this.responseParser = new ResponseParser();\r\n  }\r\n\r\n  query(options: any) {\r\n    let timeFilter = this.getTimeFilter(options);\r\n    const scopedVars = options.scopedVars;\r\n    const targets = _.cloneDeep(options.targets);\r\n    const queryTargets: any[] = [];\r\n    let queryModel: InfluxQueryModel;\r\n    let i, y;\r\n\r\n    let allQueries = _.map(targets, target => {\r\n      if (target.hide) {\r\n        return '';\r\n      }\r\n\r\n      queryTargets.push(target);\r\n\r\n      // backward compatibility\r\n      scopedVars.interval = scopedVars.__interval;\r\n\r\n      queryModel = new InfluxQueryModel(target, this.templateSrv, scopedVars);\r\n      return queryModel.render(true);\r\n    }).reduce((acc, current) => {\r\n      if (current !== '') {\r\n        acc += ';' + current;\r\n      }\r\n      return acc;\r\n    });\r\n\r\n    if (allQueries === '') {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    // add global adhoc filters to timeFilter\r\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\r\n    if (adhocFilters.length > 0) {\r\n      timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);\r\n    }\r\n\r\n    // replace grafana variables\r\n    scopedVars.timeFilter = { value: timeFilter };\r\n\r\n    // replace templated variables\r\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\r\n\r\n    return this._seriesQuery(allQueries, options).then((data: any): any => {\r\n      if (!data || !data.results) {\r\n        return [];\r\n      }\r\n\r\n      const seriesList = [];\r\n      for (i = 0; i < data.results.length; i++) {\r\n        const result = data.results[i];\r\n        if (!result || !result.series) {\r\n          continue;\r\n        }\r\n\r\n        const target = queryTargets[i];\r\n        let alias = target.alias;\r\n        if (alias) {\r\n          alias = this.templateSrv.replace(target.alias, options.scopedVars);\r\n        }\r\n\r\n        const influxSeries = new InfluxSeries({\r\n          series: data.results[i].series,\r\n          alias: alias,\r\n        });\r\n\r\n        switch (target.resultFormat) {\r\n          case 'table': {\r\n            seriesList.push(influxSeries.getTable());\r\n            break;\r\n          }\r\n          default: {\r\n            const timeSeries = influxSeries.getTimeSeries();\r\n            for (y = 0; y < timeSeries.length; y++) {\r\n              seriesList.push(timeSeries[y]);\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return { data: seriesList };\r\n    });\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    if (!options.annotation.query) {\r\n      return Promise.reject({\r\n        message: 'Query missing in annotation definition',\r\n      });\r\n    }\r\n\r\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.timezone });\r\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\r\n    query = this.templateSrv.replace(query, null, 'regex');\r\n\r\n    return this._seriesQuery(query, options).then((data: any) => {\r\n      if (!data || !data.results || !data.results[0]) {\r\n        throw { message: 'No results in response from InfluxDB' };\r\n      }\r\n      return new InfluxSeries({\r\n        series: data.results[0].series,\r\n        annotation: options.annotation,\r\n      }).getAnnotations();\r\n    });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    for (const group of target.groupBy) {\r\n      for (const param of group.params) {\r\n        if (this.templateSrv.variableExists(param)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const i in target.tags) {\r\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\r\n    if (!queries || queries.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          measurement: this.templateSrv.replace(query.measurement, scopedVars, 'regex'),\r\n        };\r\n\r\n        if (query.rawQuery) {\r\n          expandedQuery.query = this.templateSrv.replace(query.query, scopedVars, 'regex');\r\n        }\r\n\r\n        if (query.tags) {\r\n          const expandedTags = query.tags.map(tag => {\r\n            const expandedTag = {\r\n              ...tag,\r\n              value: this.templateSrv.replace(tag.value, null, 'regex'),\r\n            };\r\n            return expandedTag;\r\n          });\r\n          expandedQuery.tags = expandedTags;\r\n        }\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  metricFindQuery(query: string, options?: any) {\r\n    const interpolated = this.templateSrv.replace(query, null, 'regex');\r\n\r\n    return this._seriesQuery(interpolated, options).then(_.curry(this.responseParser.parse)(query));\r\n  }\r\n\r\n  getTagKeys(options: any = {}) {\r\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\r\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\r\n    return this.metricFindQuery(query, options);\r\n  }\r\n\r\n  getTagValues(options: any = {}) {\r\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\r\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\r\n    return this.metricFindQuery(query, options);\r\n  }\r\n\r\n  _seriesQuery(query: string, options?: any) {\r\n    if (!query) {\r\n      return Promise.resolve({ results: [] });\r\n    }\r\n\r\n    if (options && options.range) {\r\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\r\n      query = query.replace('$timeFilter', timeFilter);\r\n    }\r\n\r\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\r\n  }\r\n\r\n  serializeParams(params: any) {\r\n    if (!params) {\r\n      return '';\r\n    }\r\n\r\n    return _.reduce(\r\n      params,\r\n      (memo, value, key) => {\r\n        if (value === null || value === undefined) {\r\n          return memo;\r\n        }\r\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        return memo;\r\n      },\r\n      []\r\n    ).join('&');\r\n  }\r\n\r\n  testDatasource() {\r\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\r\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\r\n\r\n    return this._seriesQuery(query)\r\n      .then((res: any) => {\r\n        const error = _.get(res, 'results[0].error');\r\n        if (error) {\r\n          return { status: 'error', message: error };\r\n        }\r\n        return { status: 'success', message: 'Data source is working' };\r\n      })\r\n      .catch((err: any) => {\r\n        return { status: 'error', message: err.message };\r\n      });\r\n  }\r\n\r\n  _influxRequest(method: string, url: string, data: any, options?: any) {\r\n    const currentUrl = this.urls.shift();\r\n    this.urls.push(currentUrl);\r\n\r\n    const params: any = {};\r\n\r\n    if (this.username) {\r\n      params.u = this.username;\r\n      params.p = this.password;\r\n    }\r\n\r\n    if (options && options.database) {\r\n      params.db = options.database;\r\n    } else if (this.database) {\r\n      params.db = this.database;\r\n    }\r\n\r\n    if (method === 'POST' && _.has(data, 'q')) {\r\n      // verb is POST and 'q' param is defined\r\n      _.extend(params, _.omit(data, ['q']));\r\n      data = this.serializeParams(_.pick(data, ['q']));\r\n    } else if (method === 'GET' || method === 'POST') {\r\n      // verb is GET, or POST without 'q' param\r\n      _.extend(params, data);\r\n      data = null;\r\n    }\r\n\r\n    const req: any = {\r\n      method: method,\r\n      url: currentUrl + url,\r\n      params: params,\r\n      data: data,\r\n      precision: 'ms',\r\n      inspect: { type: 'influxdb' },\r\n      paramSerializer: this.serializeParams,\r\n    };\r\n\r\n    req.headers = req.headers || {};\r\n    if (this.basicAuth || this.withCredentials) {\r\n      req.withCredentials = true;\r\n    }\r\n    if (this.basicAuth) {\r\n      req.headers.Authorization = this.basicAuth;\r\n    }\r\n\r\n    if (method === 'POST') {\r\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\r\n    }\r\n\r\n    return this.backendSrv.datasourceRequest(req).then(\r\n      (result: any) => {\r\n        return result.data;\r\n      },\r\n      (err: any) => {\r\n        if (err.status !== 0 || err.status >= 300) {\r\n          if (err.data && err.data.error) {\r\n            throw {\r\n              message: 'InfluxDB Error: ' + err.data.error,\r\n              data: err.data,\r\n              config: err.config,\r\n            };\r\n          } else {\r\n            throw {\r\n              message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\r\n              data: err.data,\r\n              config: err.config,\r\n            };\r\n          }\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  getTimeFilter(options: any) {\r\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\r\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\r\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\r\n\r\n    if (until === 'now()' && !fromIsAbsolute) {\r\n      return 'time >= ' + from;\r\n    }\r\n\r\n    return 'time >= ' + from + ' and time <= ' + until;\r\n  }\r\n\r\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\r\n    if (_.isString(date)) {\r\n      if (date === 'now') {\r\n        return 'now()';\r\n      }\r\n\r\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\r\n      if (parts) {\r\n        const amount = parseInt(parts[1], 10);\r\n        const unit = parts[2];\r\n        return 'now() - ' + amount + unit;\r\n      }\r\n      date = dateMath.parse(date, roundUp, timezone);\r\n    }\r\n\r\n    return date.valueOf() + 'ms';\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport queryPart from './query_part';\r\nimport kbn from 'app/core/utils/kbn';\r\nimport { InfluxQuery, InfluxQueryTag } from './types';\r\nimport { ScopedVars } from '@grafana/data';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\nexport default class InfluxQueryModel {\r\n  target: InfluxQuery;\r\n  selectModels: any[];\r\n  queryBuilder: any;\r\n  groupByParts: any;\r\n  templateSrv: any;\r\n  scopedVars: any;\r\n  refId: string;\r\n\r\n  /** @ngInject */\r\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\r\n    this.target = target;\r\n    this.templateSrv = templateSrv;\r\n    this.scopedVars = scopedVars;\r\n\r\n    target.policy = target.policy || 'default';\r\n    target.resultFormat = target.resultFormat || 'time_series';\r\n    target.orderByTime = target.orderByTime || 'ASC';\r\n    target.tags = target.tags || [];\r\n    target.groupBy = target.groupBy || [\r\n      { type: 'time', params: ['$__interval'] },\r\n      { type: 'fill', params: ['null'] },\r\n    ];\r\n    target.select = target.select || [\r\n      [\r\n        { type: 'field', params: ['value'] },\r\n        { type: 'mean', params: [] },\r\n      ],\r\n    ];\r\n\r\n    this.updateProjection();\r\n  }\r\n\r\n  updateProjection() {\r\n    this.selectModels = _.map(this.target.select, (parts: any) => {\r\n      return _.map(parts, queryPart.create);\r\n    });\r\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\r\n  }\r\n\r\n  updatePersistedParts() {\r\n    this.target.select = _.map(this.selectModels, selectParts => {\r\n      return _.map(selectParts, (part: any) => {\r\n        return { type: part.def.type, params: part.params };\r\n      });\r\n    });\r\n  }\r\n\r\n  hasGroupByTime() {\r\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\r\n  }\r\n\r\n  hasFill() {\r\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\r\n  }\r\n\r\n  addGroupBy(value: string) {\r\n    const stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\r\n    const typePart = stringParts[1];\r\n    const arg = stringParts[2];\r\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\r\n    const partCount = this.target.groupBy.length;\r\n\r\n    if (partCount === 0) {\r\n      this.target.groupBy.push(partModel.part);\r\n    } else if (typePart === 'time') {\r\n      this.target.groupBy.splice(0, 0, partModel.part);\r\n    } else if (typePart === 'tag') {\r\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\r\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\r\n      } else {\r\n        this.target.groupBy.push(partModel.part);\r\n      }\r\n    } else {\r\n      this.target.groupBy.push(partModel.part);\r\n    }\r\n\r\n    this.updateProjection();\r\n  }\r\n\r\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\r\n    const categories = queryPart.getCategories();\r\n\r\n    if (part.def.type === 'time') {\r\n      // remove fill\r\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\r\n      // remove aggregations\r\n      this.target.select = _.map(this.target.select, (s: any) => {\r\n        return _.filter(s, (part: any) => {\r\n          const partModel = queryPart.create(part);\r\n          if (partModel.def.category === categories.Aggregations) {\r\n            return false;\r\n          }\r\n          if (partModel.def.category === categories.Selectors) {\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n    }\r\n\r\n    this.target.groupBy.splice(index, 1);\r\n    this.updateProjection();\r\n  }\r\n\r\n  removeSelect(index: number) {\r\n    this.target.select.splice(index, 1);\r\n    this.updateProjection();\r\n  }\r\n\r\n  removeSelectPart(selectParts: any[], part: any) {\r\n    // if we remove the field remove the whole statement\r\n    if (part.def.type === 'field') {\r\n      if (this.selectModels.length > 1) {\r\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\r\n        this.selectModels.splice(modelsIndex, 1);\r\n      }\r\n    } else {\r\n      const partIndex = _.indexOf(selectParts, part);\r\n      selectParts.splice(partIndex, 1);\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  addSelectPart(selectParts: any[], type: string) {\r\n    const partModel = queryPart.create({ type: type });\r\n    partModel.def.addStrategy(selectParts, partModel, this);\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate: boolean) {\r\n    let str = '';\r\n    let operator = tag.operator;\r\n    let value = tag.value;\r\n    if (index > 0) {\r\n      str = (tag.condition || 'AND') + ' ';\r\n    }\r\n\r\n    if (!operator) {\r\n      if (/^\\/.*\\/$/.test(value)) {\r\n        operator = '=~';\r\n      } else {\r\n        operator = '=';\r\n      }\r\n    }\r\n\r\n    // quote value unless regex\r\n    if (operator !== '=~' && operator !== '!~') {\r\n      if (interpolate) {\r\n        value = this.templateSrv.replace(value, this.scopedVars);\r\n      }\r\n      if (operator !== '>' && operator !== '<') {\r\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\r\n      }\r\n    } else if (interpolate) {\r\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\r\n    }\r\n\r\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\r\n  }\r\n\r\n  getMeasurementAndPolicy(interpolate: any) {\r\n    let policy = this.target.policy;\r\n    let measurement = this.target.measurement || 'measurement';\r\n\r\n    if (!measurement.match('^/.*/$')) {\r\n      measurement = '\"' + measurement + '\"';\r\n    } else if (interpolate) {\r\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\r\n    }\r\n\r\n    if (policy !== 'default') {\r\n      policy = '\"' + this.target.policy + '\".';\r\n    } else {\r\n      policy = '';\r\n    }\r\n\r\n    return policy + measurement;\r\n  }\r\n\r\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\r\n    // if no multi or include all do not regexEscape\r\n    if (!variable.multi && !variable.includeAll) {\r\n      return value;\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return kbn.regexEscape(value);\r\n    }\r\n\r\n    const escapedValues = _.map(value, kbn.regexEscape);\r\n    return '(' + escapedValues.join('|') + ')';\r\n  }\r\n\r\n  render(interpolate?: boolean) {\r\n    const target = this.target;\r\n\r\n    if (target.rawQuery) {\r\n      if (interpolate) {\r\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\r\n      } else {\r\n        return target.query;\r\n      }\r\n    }\r\n\r\n    let query = 'SELECT ';\r\n    let i, y;\r\n    for (i = 0; i < this.selectModels.length; i++) {\r\n      const parts = this.selectModels[i];\r\n      let selectText = '';\r\n      for (y = 0; y < parts.length; y++) {\r\n        const part = parts[y];\r\n        selectText = part.render(selectText);\r\n      }\r\n\r\n      if (i > 0) {\r\n        query += ', ';\r\n      }\r\n      query += selectText;\r\n    }\r\n\r\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\r\n    const conditions = _.map(target.tags, (tag, index) => {\r\n      return this.renderTagCondition(tag, index, interpolate);\r\n    });\r\n\r\n    if (conditions.length > 0) {\r\n      query += '(' + conditions.join(' ') + ') AND ';\r\n    }\r\n\r\n    query += '$timeFilter';\r\n\r\n    let groupBySection = '';\r\n    for (i = 0; i < this.groupByParts.length; i++) {\r\n      const part = this.groupByParts[i];\r\n      if (i > 0) {\r\n        // for some reason fill has no separator\r\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\r\n      }\r\n      groupBySection += part.render('');\r\n    }\r\n\r\n    if (groupBySection.length) {\r\n      query += ' GROUP BY ' + groupBySection;\r\n    }\r\n\r\n    if (target.fill) {\r\n      query += ' fill(' + target.fill + ')';\r\n    }\r\n\r\n    if (target.orderByTime === 'DESC') {\r\n      query += ' ORDER BY time DESC';\r\n    }\r\n\r\n    if (target.limit) {\r\n      query += ' LIMIT ' + target.limit;\r\n    }\r\n\r\n    if (target.slimit) {\r\n      query += ' SLIMIT ' + target.slimit;\r\n    }\r\n\r\n    if (target.tz) {\r\n      query += \" tz('\" + target.tz + \"')\";\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  renderAdhocFilters(filters: any[]) {\r\n    const conditions = _.map(filters, (tag, index) => {\r\n      return this.renderTagCondition(tag, index, true);\r\n    });\r\n    return conditions.join(' ');\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport TableModel from 'app/core/table_model';\r\nimport { FieldType } from '@grafana/data';\r\n\r\nexport default class InfluxSeries {\r\n  series: any;\r\n  alias: any;\r\n  annotation: any;\r\n\r\n  constructor(options: { series: any; alias?: any; annotation?: any }) {\r\n    this.series = options.series;\r\n    this.alias = options.alias;\r\n    this.annotation = options.annotation;\r\n  }\r\n\r\n  getTimeSeries() {\r\n    const output: any[] = [];\r\n    let i, j;\r\n\r\n    if (this.series.length === 0) {\r\n      return output;\r\n    }\r\n\r\n    _.each(this.series, series => {\r\n      const columns = series.columns.length;\r\n      const tags = _.map(series.tags, (value, key) => {\r\n        return key + ': ' + value;\r\n      });\r\n\r\n      for (j = 1; j < columns; j++) {\r\n        let seriesName = series.name;\r\n        const columnName = series.columns[j];\r\n        if (columnName !== 'value') {\r\n          seriesName = seriesName + '.' + columnName;\r\n        }\r\n\r\n        if (this.alias) {\r\n          seriesName = this._getSeriesName(series, j);\r\n        } else if (series.tags) {\r\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\r\n        }\r\n\r\n        const datapoints = [];\r\n        if (series.values) {\r\n          for (i = 0; i < series.values.length; i++) {\r\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\r\n          }\r\n        }\r\n\r\n        output.push({ target: seriesName, datapoints: datapoints });\r\n      }\r\n    });\r\n\r\n    return output;\r\n  }\r\n\r\n  _getSeriesName(series: any, index: number) {\r\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\r\n    const segments = series.name.split('.');\r\n\r\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\r\n      const group = g1 || g2;\r\n      const segIndex = parseInt(group, 10);\r\n\r\n      if (group === 'm' || group === 'measurement') {\r\n        return series.name;\r\n      }\r\n      if (group === 'col') {\r\n        return series.columns[index];\r\n      }\r\n      if (!isNaN(segIndex)) {\r\n        return segments[segIndex];\r\n      }\r\n      if (group.indexOf('tag_') !== 0) {\r\n        return match;\r\n      }\r\n\r\n      const tag = group.replace('tag_', '');\r\n      if (!series.tags) {\r\n        return match;\r\n      }\r\n      return series.tags[tag];\r\n    });\r\n  }\r\n\r\n  getAnnotations() {\r\n    const list: any[] = [];\r\n\r\n    _.each(this.series, series => {\r\n      let titleCol: any = null;\r\n      let timeCol: any = null;\r\n      const tagsCol: any = [];\r\n      let textCol: any = null;\r\n\r\n      _.each(series.columns, (column, index) => {\r\n        if (column === 'time') {\r\n          timeCol = index;\r\n          return;\r\n        }\r\n        if (column === 'sequence_number') {\r\n          return;\r\n        }\r\n        if (column === this.annotation.titleColumn) {\r\n          titleCol = index;\r\n          return;\r\n        }\r\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\r\n          tagsCol.push(index);\r\n          return;\r\n        }\r\n        if (column === this.annotation.textColumn) {\r\n          textCol = index;\r\n          return;\r\n        }\r\n        // legacy case\r\n        if (!titleCol && textCol !== index) {\r\n          titleCol = index;\r\n        }\r\n      });\r\n\r\n      _.each(series.values, value => {\r\n        const data = {\r\n          annotation: this.annotation,\r\n          time: +new Date(value[timeCol]),\r\n          title: value[titleCol],\r\n          // Remove empty values, then split in different tags for comma separated values\r\n          tags: _.flatten(\r\n            tagsCol\r\n              .filter((t: any) => {\r\n                return value[t];\r\n              })\r\n              .map((t: any) => {\r\n                return value[t].split(',');\r\n              })\r\n          ),\r\n          text: value[textCol],\r\n        };\r\n\r\n        list.push(data);\r\n      });\r\n    });\r\n\r\n    return list;\r\n  }\r\n\r\n  getTable() {\r\n    const table = new TableModel();\r\n    let i, j;\r\n\r\n    if (this.series.length === 0) {\r\n      return table;\r\n    }\r\n\r\n    _.each(this.series, (series: any, seriesIndex: number) => {\r\n      if (seriesIndex === 0) {\r\n        j = 0;\r\n        // Check that the first column is indeed 'time'\r\n        if (series.columns[0] === 'time') {\r\n          // Push this now before the tags and with the right type\r\n          table.columns.push({ text: 'Time', type: FieldType.time });\r\n          j++;\r\n        }\r\n        _.each(_.keys(series.tags), key => {\r\n          table.columns.push({ text: key });\r\n        });\r\n        for (; j < series.columns.length; j++) {\r\n          table.columns.push({ text: series.columns[j] });\r\n        }\r\n      }\r\n\r\n      if (series.values) {\r\n        for (i = 0; i < series.values.length; i++) {\r\n          const values = series.values[i];\r\n          const reordered = [values[0]];\r\n          if (series.tags) {\r\n            for (const key in series.tags) {\r\n              if (series.tags.hasOwnProperty(key)) {\r\n                reordered.push(series.tags[key]);\r\n              }\r\n            }\r\n          }\r\n          for (j = 1; j < values.length; j++) {\r\n            reordered.push(values[j]);\r\n          }\r\n          table.rows.push(reordered);\r\n        }\r\n      }\r\n    });\r\n\r\n    return table;\r\n  }\r\n}\r\n","import InfluxDatasource from './datasource';\r\nimport { InfluxQueryCtrl } from './query_ctrl';\r\nimport { InfluxLogsQueryField } from './components/InfluxLogsQueryField';\r\nimport InfluxStartPage from './components/InfluxStartPage';\r\nimport { DataSourcePlugin } from '@grafana/data';\r\nimport ConfigEditor from './components/ConfigEditor';\r\n\r\nclass InfluxAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n}\r\n\r\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\r\n  .setConfigEditor(ConfigEditor)\r\n  .setQueryCtrl(InfluxQueryCtrl)\r\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\r\n  .setExploreLogsQueryField(InfluxLogsQueryField)\r\n  .setExploreStartPage(InfluxStartPage);\r\n","import _ from 'lodash';\r\nimport kbn from 'app/core/utils/kbn';\r\n\r\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\r\n  let str = '';\r\n  let operator = tag.operator;\r\n  let value = tag.value;\r\n  if (index > 0) {\r\n    str = (tag.condition || 'AND') + ' ';\r\n  }\r\n\r\n  if (!operator) {\r\n    if (/^\\/.*\\/$/.test(tag.value)) {\r\n      operator = '=~';\r\n    } else {\r\n      operator = '=';\r\n    }\r\n  }\r\n\r\n  // quote value unless regex or number\r\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\r\n    value = \"'\" + value + \"'\";\r\n  }\r\n\r\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\r\n}\r\n\r\nexport class InfluxQueryBuilder {\r\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\r\n\r\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string) {\r\n    let query;\r\n    let measurement;\r\n    let policy;\r\n\r\n    if (type === 'TAG_KEYS') {\r\n      query = 'SHOW TAG KEYS';\r\n      measurement = this.target.measurement;\r\n      policy = this.target.policy;\r\n    } else if (type === 'TAG_VALUES') {\r\n      query = 'SHOW TAG VALUES';\r\n      measurement = this.target.measurement;\r\n      policy = this.target.policy;\r\n    } else if (type === 'MEASUREMENTS') {\r\n      query = 'SHOW MEASUREMENTS';\r\n      if (withMeasurementFilter) {\r\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\r\n      }\r\n    } else if (type === 'FIELDS') {\r\n      measurement = this.target.measurement;\r\n      policy = this.target.policy;\r\n\r\n      if (!measurement.match('^/.*/')) {\r\n        measurement = '\"' + measurement + '\"';\r\n\r\n        if (policy && policy !== 'default') {\r\n          policy = '\"' + policy + '\"';\r\n          measurement = policy + '.' + measurement;\r\n        }\r\n      }\r\n\r\n      return 'SHOW FIELD KEYS FROM ' + measurement;\r\n    } else if (type === 'RETENTION POLICIES') {\r\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\r\n      return query;\r\n    }\r\n\r\n    if (measurement) {\r\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\r\n        measurement = '\"' + measurement + '\"';\r\n      }\r\n\r\n      if (policy && policy !== 'default') {\r\n        policy = '\"' + policy + '\"';\r\n        measurement = policy + '.' + measurement;\r\n      }\r\n\r\n      query += ' FROM ' + measurement;\r\n    }\r\n\r\n    if (withKey) {\r\n      query += ' WITH KEY = \"' + withKey + '\"';\r\n    }\r\n\r\n    if (this.target.tags && this.target.tags.length > 0) {\r\n      const whereConditions = _.reduce(\r\n        this.target.tags,\r\n        (memo, tag) => {\r\n          // do not add a condition for the key we want to explore for\r\n          if (tag.key === withKey) {\r\n            return memo;\r\n          }\r\n          memo.push(renderTagCondition(tag, memo.length));\r\n          return memo;\r\n        },\r\n        []\r\n      );\r\n\r\n      if (whereConditions.length > 0) {\r\n        query += ' WHERE ' + whereConditions.join(' ');\r\n      }\r\n    }\r\n    if (type === 'MEASUREMENTS') {\r\n      query += ' LIMIT 100';\r\n      //Solve issue #2524 by limiting the number of measurements returned\r\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\r\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\r\n    }\r\n    return query;\r\n  }\r\n}\r\n","import angular, { auto } from 'angular';\r\nimport _ from 'lodash';\r\nimport { InfluxQueryBuilder } from './query_builder';\r\nimport InfluxQueryModel from './influx_query_model';\r\nimport queryPart from './query_part';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\nexport class InfluxQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  queryModel: InfluxQueryModel;\r\n  queryBuilder: any;\r\n  groupBySegment: any;\r\n  resultFormats: any[];\r\n  orderByTime: any[];\r\n  policySegment: any;\r\n  tagSegments: any[];\r\n  selectMenu: any;\r\n  measurementSegment: any;\r\n  removeTagFilterSegment: any;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    $scope: any,\r\n    $injector: auto.IInjectorService,\r\n    private templateSrv: TemplateSrv,\r\n    private uiSegmentSrv: any\r\n  ) {\r\n    super($scope, $injector);\r\n    this.target = this.target;\r\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\r\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\r\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\r\n    this.resultFormats = [\r\n      { text: 'Time series', value: 'time_series' },\r\n      { text: 'Table', value: 'table' },\r\n    ];\r\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\r\n\r\n    if (!this.target.measurement) {\r\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\r\n    } else {\r\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\r\n    }\r\n\r\n    this.tagSegments = [];\r\n    for (const tag of this.target.tags) {\r\n      if (!tag.operator) {\r\n        if (/^\\/.*\\/$/.test(tag.value)) {\r\n          tag.operator = '=~';\r\n        } else {\r\n          tag.operator = '=';\r\n        }\r\n      }\r\n\r\n      if (tag.condition) {\r\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\r\n      }\r\n\r\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\r\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\r\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\r\n    }\r\n\r\n    this.fixTagSegments();\r\n    this.buildSelectMenu();\r\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\r\n      fake: true,\r\n      value: '-- remove tag filter --',\r\n    });\r\n  }\r\n\r\n  removeOrderByTime() {\r\n    this.target.orderByTime = 'ASC';\r\n  }\r\n\r\n  buildSelectMenu() {\r\n    const categories = queryPart.getCategories();\r\n    this.selectMenu = _.reduce(\r\n      categories,\r\n      (memo, cat, key) => {\r\n        const menu = {\r\n          text: key,\r\n          submenu: cat.map((item: any) => {\r\n            return { text: item.type, value: item.type };\r\n          }),\r\n        };\r\n        memo.push(menu);\r\n        return memo;\r\n      },\r\n      []\r\n    );\r\n  }\r\n\r\n  getGroupByOptions() {\r\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then((tags: any) => {\r\n        const options = [];\r\n        if (!this.queryModel.hasFill()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\r\n        }\r\n        if (!this.target.limit) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\r\n        }\r\n        if (!this.target.slimit) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\r\n        }\r\n        if (!this.target.tz) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\r\n        }\r\n        if (this.target.orderByTime === 'ASC') {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\r\n        }\r\n        if (!this.queryModel.hasGroupByTime()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\r\n        }\r\n        for (const tag of tags) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\r\n        }\r\n        return options;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  groupByAction() {\r\n    switch (this.groupBySegment.value) {\r\n      case 'LIMIT': {\r\n        this.target.limit = 10;\r\n        break;\r\n      }\r\n      case 'SLIMIT': {\r\n        this.target.slimit = 10;\r\n        break;\r\n      }\r\n      case 'tz': {\r\n        this.target.tz = 'UTC';\r\n        break;\r\n      }\r\n      case 'ORDER BY time DESC': {\r\n        this.target.orderByTime = 'DESC';\r\n        break;\r\n      }\r\n      default: {\r\n        this.queryModel.addGroupBy(this.groupBySegment.value);\r\n      }\r\n    }\r\n\r\n    const plusButton = this.uiSegmentSrv.newPlusButton();\r\n    this.groupBySegment.value = plusButton.value;\r\n    this.groupBySegment.html = plusButton.html;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\r\n    this.queryModel.addSelectPart(selectParts, subitem.value);\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\r\n        return this.datasource\r\n          .metricFindQuery(fieldsQuery)\r\n          .then(this.transformToSegments(true))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.queryModel.removeSelectPart(selectParts, part);\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n        return this.datasource\r\n          .metricFindQuery(tagsQuery)\r\n          .then(this.transformToSegments(true))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.queryModel.removeGroupByPart(part, index);\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  fixTagSegments() {\r\n    const count = this.tagSegments.length;\r\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\r\n\r\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\r\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n    }\r\n  }\r\n\r\n  measurementChanged() {\r\n    this.target.measurement = this.measurementSegment.value;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  getPolicySegments() {\r\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\r\n    return this.datasource\r\n      .metricFindQuery(policiesQuery)\r\n      .then(this.transformToSegments(false))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  policyChanged() {\r\n    this.target.policy = this.policySegment.value;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  toggleEditorMode() {\r\n    try {\r\n      this.target.query = this.queryModel.render(false);\r\n    } catch (err) {\r\n      console.log('query render error');\r\n    }\r\n    this.target.rawQuery = !this.target.rawQuery;\r\n  }\r\n\r\n  getMeasurements(measurementFilter: any) {\r\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then(this.transformToSegments(true))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  handleQueryError(err: any): any[] {\r\n    this.error = err.message || 'Failed to issue metric query';\r\n    return [];\r\n  }\r\n\r\n  transformToSegments(addTemplateVars: any) {\r\n    return (results: any) => {\r\n      const segments = _.map(results, segment => {\r\n        return this.uiSegmentSrv.newSegment({\r\n          value: segment.text,\r\n          expandable: segment.expandable,\r\n        });\r\n      });\r\n\r\n      if (addTemplateVars) {\r\n        for (const variable of this.templateSrv.variables) {\r\n          segments.unshift(\r\n            this.uiSegmentSrv.newSegment({\r\n              type: 'value',\r\n              value: '/^$' + variable.name + '$/',\r\n              expandable: true,\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      return segments;\r\n    };\r\n  }\r\n\r\n  getTagsOrValues(segment: { type: string }, index: number) {\r\n    if (segment.type === 'condition') {\r\n      return Promise.resolve([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\r\n    }\r\n    if (segment.type === 'operator') {\r\n      const nextValue = this.tagSegments[index + 1].value;\r\n      if (/^\\/.*\\/$/.test(nextValue)) {\r\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=~', '!~']));\r\n      } else {\r\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\r\n      }\r\n    }\r\n\r\n    let query, addTemplateVars;\r\n    if (segment.type === 'key' || segment.type === 'plus-button') {\r\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n      addTemplateVars = false;\r\n    } else if (segment.type === 'value') {\r\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\r\n      addTemplateVars = true;\r\n    }\r\n\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then(this.transformToSegments(addTemplateVars))\r\n      .then((results: any) => {\r\n        if (segment.type === 'key') {\r\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\r\n        }\r\n        return results;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  getFieldSegments() {\r\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\r\n    return this.datasource\r\n      .metricFindQuery(fieldsQuery)\r\n      .then(this.transformToSegments(false))\r\n      .catch(this.handleQueryError);\r\n  }\r\n\r\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\r\n    this.tagSegments[index] = segment;\r\n\r\n    // handle remove tag condition\r\n    if (segment.value === this.removeTagFilterSegment.value) {\r\n      this.tagSegments.splice(index, 3);\r\n      if (this.tagSegments.length === 0) {\r\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n      } else if (this.tagSegments.length > 2) {\r\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\r\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\r\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n        }\r\n      }\r\n    } else {\r\n      if (segment.type === 'plus-button') {\r\n        if (index > 2) {\r\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\r\n        }\r\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\r\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\r\n        segment.type = 'key';\r\n        segment.cssClass = 'query-segment-key';\r\n      }\r\n\r\n      if (index + 1 === this.tagSegments.length) {\r\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n      }\r\n    }\r\n\r\n    this.rebuildTargetTagConditions();\r\n  }\r\n\r\n  rebuildTargetTagConditions() {\r\n    const tags: any[] = [];\r\n    let tagIndex = 0;\r\n    let tagOperator = '';\r\n\r\n    _.each(this.tagSegments, (segment2, index) => {\r\n      if (segment2.type === 'key') {\r\n        if (tags.length === 0) {\r\n          tags.push({});\r\n        }\r\n        tags[tagIndex].key = segment2.value;\r\n      } else if (segment2.type === 'value') {\r\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\r\n        if (tagOperator) {\r\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\r\n          tags[tagIndex].operator = tagOperator;\r\n        }\r\n        tags[tagIndex].value = segment2.value;\r\n      } else if (segment2.type === 'condition') {\r\n        tags.push({ condition: segment2.value });\r\n        tagIndex += 1;\r\n      } else if (segment2.type === 'operator') {\r\n        tags[tagIndex].operator = segment2.value;\r\n      }\r\n    });\r\n\r\n    this.target.tags = tags;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  getTagValueOperator(tagValue: string, tagOperator: string): string {\r\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\r\n      return '=~';\r\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\r\n      return '=';\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getCollapsedText() {\r\n    return this.queryModel.render(false);\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\r\n\r\nconst index: any[] = [];\r\nconst categories: any = {\r\n  Aggregations: [],\r\n  Selectors: [],\r\n  Transformations: [],\r\n  Predictors: [],\r\n  Math: [],\r\n  Aliasing: [],\r\n  Fields: [],\r\n};\r\n\r\nfunction createPart(part: any): any {\r\n  const def = index[part.type];\r\n  if (!def) {\r\n    throw { message: 'Could not find query part ' + part.type };\r\n  }\r\n\r\n  return new QueryPart(part, def);\r\n}\r\n\r\nfunction register(options: any) {\r\n  index[options.type] = new QueryPartDef(options);\r\n  options.category.push(index[options.type]);\r\n}\r\n\r\nconst groupByTimeFunctions: any[] = [];\r\n\r\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\r\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\r\n}\r\n\r\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\r\n  if (part.params[0] === '*') {\r\n    return '*';\r\n  }\r\n  return '\"' + part.params[0] + '\"';\r\n}\r\n\r\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\r\n  // look for existing aggregation\r\n  for (let i = 0; i < selectParts.length; i++) {\r\n    const part = selectParts[i];\r\n    if (part.def.category === categories.Aggregations) {\r\n      if (part.def.type === partModel.def.type) {\r\n        return;\r\n      }\r\n      // count distinct is allowed\r\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\r\n        break;\r\n      }\r\n      // remove next aggregation if distinct was replaced\r\n      if (part.def.type === 'distinct') {\r\n        const morePartsAvailable = selectParts.length >= i + 2;\r\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\r\n          const nextPart = selectParts[i + 1];\r\n          if (nextPart.def.category === categories.Aggregations) {\r\n            selectParts.splice(i + 1, 1);\r\n          }\r\n        } else if (partModel.def.type === 'count') {\r\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\r\n            selectParts.splice(i + 1, 0, partModel);\r\n          }\r\n          return;\r\n        }\r\n      }\r\n      selectParts[i] = partModel;\r\n      return;\r\n    }\r\n    if (part.def.category === categories.Selectors) {\r\n      selectParts[i] = partModel;\r\n      return;\r\n    }\r\n  }\r\n\r\n  selectParts.splice(1, 0, partModel);\r\n}\r\n\r\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\r\n  let i;\r\n  // look for index to add transformation\r\n  for (i = 0; i < selectParts.length; i++) {\r\n    const part = selectParts[i];\r\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  selectParts.splice(i, 0, partModel);\r\n}\r\n\r\nfunction addMathStrategy(selectParts: any[], partModel: any) {\r\n  const partCount = selectParts.length;\r\n  if (partCount > 0) {\r\n    // if last is math, replace it\r\n    if (selectParts[partCount - 1].def.type === 'math') {\r\n      selectParts[partCount - 1] = partModel;\r\n      return;\r\n    }\r\n    // if next to last is math, replace it\r\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\r\n      selectParts[partCount - 2] = partModel;\r\n      return;\r\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\r\n      // if last is alias add it before\r\n      selectParts.splice(partCount - 1, 0, partModel);\r\n      return;\r\n    }\r\n  }\r\n  selectParts.push(partModel);\r\n}\r\n\r\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\r\n  const partCount = selectParts.length;\r\n  if (partCount > 0) {\r\n    // if last is alias, replace it\r\n    if (selectParts[partCount - 1].def.type === 'alias') {\r\n      selectParts[partCount - 1] = partModel;\r\n      return;\r\n    }\r\n  }\r\n  selectParts.push(partModel);\r\n}\r\n\r\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\r\n  // copy all parts\r\n  const parts = _.map(selectParts, (part: any) => {\r\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\r\n  });\r\n\r\n  query.selectModels.push(parts);\r\n}\r\n\r\nregister({\r\n  type: 'field',\r\n  addStrategy: addFieldStrategy,\r\n  category: categories.Fields,\r\n  params: [{ type: 'field', dynamicLookup: true }],\r\n  defaultParams: ['value'],\r\n  renderer: fieldRenderer,\r\n});\r\n\r\n// Aggregations\r\nregister({\r\n  type: 'count',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'distinct',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'integral',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'mean',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'median',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'mode',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'sum',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Aggregations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\n// transformations\r\n\r\nregister({\r\n  type: 'derivative',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [\r\n    {\r\n      name: 'duration',\r\n      type: 'interval',\r\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\r\n    },\r\n  ],\r\n  defaultParams: ['10s'],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'spread',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'non_negative_derivative',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [\r\n    {\r\n      name: 'duration',\r\n      type: 'interval',\r\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\r\n    },\r\n  ],\r\n  defaultParams: ['10s'],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'difference',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'non_negative_difference',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'moving_average',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\r\n  defaultParams: [10],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'cumulative_sum',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'stddev',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'time',\r\n  category: groupByTimeFunctions,\r\n  params: [\r\n    {\r\n      name: 'interval',\r\n      type: 'time',\r\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\r\n    },\r\n  ],\r\n  defaultParams: ['$__interval'],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'fill',\r\n  category: groupByTimeFunctions,\r\n  params: [\r\n    {\r\n      name: 'fill',\r\n      type: 'string',\r\n      options: ['none', 'null', '0', 'previous', 'linear'],\r\n    },\r\n  ],\r\n  defaultParams: ['null'],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'elapsed',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Transformations,\r\n  params: [\r\n    {\r\n      name: 'duration',\r\n      type: 'interval',\r\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\r\n    },\r\n  ],\r\n  defaultParams: ['10s'],\r\n  renderer: functionRenderer,\r\n});\r\n\r\n// predictions\r\nregister({\r\n  type: 'holt_winters',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Predictors,\r\n  params: [\r\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\r\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\r\n  ],\r\n  defaultParams: [10, 2],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'holt_winters_with_fit',\r\n  addStrategy: addTransformationStrategy,\r\n  category: categories.Predictors,\r\n  params: [\r\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\r\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\r\n  ],\r\n  defaultParams: [10, 2],\r\n  renderer: functionRenderer,\r\n});\r\n\r\n// Selectors\r\nregister({\r\n  type: 'bottom',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [3],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'first',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'last',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'max',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'min',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [],\r\n  defaultParams: [],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'percentile',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [{ name: 'nth', type: 'int' }],\r\n  defaultParams: [95],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'top',\r\n  addStrategy: replaceAggregationAddStrategy,\r\n  category: categories.Selectors,\r\n  params: [{ name: 'count', type: 'int' }],\r\n  defaultParams: [3],\r\n  renderer: functionRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'tag',\r\n  category: groupByTimeFunctions,\r\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\r\n  defaultParams: ['tag'],\r\n  renderer: fieldRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'math',\r\n  addStrategy: addMathStrategy,\r\n  category: categories.Math,\r\n  params: [{ name: 'expr', type: 'string' }],\r\n  defaultParams: [' / 100'],\r\n  renderer: suffixRenderer,\r\n});\r\n\r\nregister({\r\n  type: 'alias',\r\n  addStrategy: addAliasStrategy,\r\n  category: categories.Aliasing,\r\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\r\n  defaultParams: ['alias'],\r\n  renderMode: 'suffix',\r\n  renderer: aliasRenderer,\r\n});\r\n\r\nexport default {\r\n  create: createPart,\r\n  getCategories: () => {\r\n    return categories;\r\n  },\r\n  replaceAggregationAdd: replaceAggregationAddStrategy,\r\n};\r\n","import _ from 'lodash';\r\n\r\nexport default class ResponseParser {\r\n  parse(query: string, results: { results: any }) {\r\n    if (!results || results.results.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const influxResults = results.results[0];\r\n    if (!influxResults.series) {\r\n      return [];\r\n    }\r\n\r\n    const normalizedQuery = query.toLowerCase();\r\n    const isValueFirst =\r\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\r\n\r\n    const res = {};\r\n    _.each(influxResults.series, serie => {\r\n      _.each(serie.values, value => {\r\n        if (_.isArray(value)) {\r\n          // In general, there are 2 possible shapes for the returned value.\r\n          // The first one is a two-element array,\r\n          // where the first element is somewhat a metadata value:\r\n          // the tag name for SHOW TAG VALUES queries,\r\n          // the time field for SELECT queries, etc.\r\n          // The second shape is an one-element array,\r\n          // that is containing an immediate value.\r\n          // For example, SHOW FIELD KEYS queries return such shape.\r\n          // Note, pre-0.11 versions return\r\n          // the second shape for SHOW TAG VALUES queries\r\n          // (while the newer versions—first).\r\n\r\n          if (isValueFirst) {\r\n            addUnique(res, value[0]);\r\n          } else if (value[1] !== undefined) {\r\n            addUnique(res, value[1]);\r\n          } else {\r\n            addUnique(res, value[0]);\r\n          }\r\n        } else {\r\n          addUnique(res, value);\r\n        }\r\n      });\r\n    });\r\n\r\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\r\n    return _.map(res, value => {\r\n      // @ts-ignore\r\n      return { text: value.toString() };\r\n    });\r\n  }\r\n}\r\n\r\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\r\n  arr[value] = value;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAGA;AACA;AAKA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AASA;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AAEA;AACA;AAEA;AAEA;AAsBA;AAGA;AAHA;AAAA;AAIA;AAUA;;;;;AACA;AACA;AACA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAEA;;;AACA;AAEA;;;;;AACA;AACA;AACA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAEA;;;AACA;AAoCA;;;;;AACA;AACA;AACA;;AAAA;AACA;AAEA;;;AAEA;;;;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AACA;;AAAA;AACA;AAEA;;;;AACA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA;;AA6BA;AAjIA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AA4CA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAGA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AASA;AAGA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AA+GA;AA7GA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAWA;AACA;AACA;AAQA;AAUA;AACA;AACA;AACA;;AAGA;;AAAA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAOA;AACA;AAYA;AACA;AAAA;;AAEA;;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AAEA;AAEA;AACA;AACA;AAEA;AAkBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AA0CA;;;;AACA;AACA;AACA;AAEA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AAaA;AAEA;AACA;AACA;AACA;AACA;;AAmCA;AA3GA;;;;;;AACA;;;;AAEA;AACA;AACA;;AAAA;AAEA;AACA;;;AAAA;AACA;AACA;AAIA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAjBA;;;AAmBA;;;;AAEA;AACA;;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAoCA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AASA;AACA;AAOA;AAMA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AChKA;AAEA;AAEA;AAAA;AAAA;;AAIA;AAHA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAAA;AAaA;AACA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACvXA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC3RA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAcA;AACA;;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvYA;AAwYA;AAAA;AAzYA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3cA;AAAA;AAAA;AAAA;AAEA;AAAA;AAkDA;AAjDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;;;;;A","sourceRoot":""}