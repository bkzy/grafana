{"version":3,"file":"mixedPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/mixed/MixedDataSource.ts","webpack:///webpack:///./public/app/plugins/datasource/mixed/module.ts"],"sourcesContent":["import cloneDeep from 'lodash/cloneDeep';\r\nimport groupBy from 'lodash/groupBy';\r\nimport { from, of, Observable, merge } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\n\r\nimport {\r\n  LoadingState,\r\n  DataSourceApi,\r\n  DataQuery,\r\n  DataQueryRequest,\r\n  DataQueryResponse,\r\n  DataSourceInstanceSettings,\r\n} from '@grafana/data';\r\nimport { getDataSourceSrv } from '@grafana/runtime';\r\nimport { mergeMap, map } from 'rxjs/operators';\r\n\r\nexport const MIXED_DATASOURCE_NAME = '-- Mixed --';\r\n\r\nexport interface BatchedQueries {\r\n  datasource: Promise<DataSourceApi>;\r\n  targets: DataQuery[];\r\n}\r\n\r\nexport class MixedDatasource extends DataSourceApi<DataQuery> {\r\n  constructor(instanceSettings: DataSourceInstanceSettings) {\r\n    super(instanceSettings);\r\n  }\r\n\r\n  query(request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\r\n    // Remove any invalid queries\r\n    const queries = request.targets.filter(t => {\r\n      return t.datasource !== MIXED_DATASOURCE_NAME;\r\n    });\r\n\r\n    if (!queries.length) {\r\n      return of({ data: [] } as DataQueryResponse); // nothing\r\n    }\r\n\r\n    // Build groups of queries to run in parallel\r\n    const sets: { [key: string]: DataQuery[] } = groupBy(queries, 'datasource');\r\n    const mixed: BatchedQueries[] = [];\r\n    for (const key in sets) {\r\n      const targets = sets[key];\r\n      const dsName = targets[0].datasource;\r\n      mixed.push({\r\n        datasource: getDataSourceSrv().get(dsName),\r\n        targets,\r\n      });\r\n    }\r\n    return this.batchQueries(mixed, request);\r\n  }\r\n\r\n  batchQueries(mixed: BatchedQueries[], request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\r\n    const observables: Array<Observable<DataQueryResponse>> = [];\r\n    let runningSubRequests = 0;\r\n\r\n    for (let i = 0; i < mixed.length; i++) {\r\n      const query = mixed[i];\r\n      if (!query.targets || !query.targets.length) {\r\n        continue;\r\n      }\r\n      const observable = from(query.datasource).pipe(\r\n        mergeMap((dataSourceApi: DataSourceApi) => {\r\n          const datasourceRequest = cloneDeep(request);\r\n\r\n          datasourceRequest.requestId = `mixed-${i}-${datasourceRequest.requestId || ''}`;\r\n          datasourceRequest.targets = query.targets;\r\n\r\n          runningSubRequests++;\r\n          let hasCountedAsDone = false;\r\n\r\n          return from(dataSourceApi.query(datasourceRequest)).pipe(\r\n            tap(\r\n              (response: DataQueryResponse) => {\r\n                if (\r\n                  hasCountedAsDone ||\r\n                  response.state === LoadingState.Streaming ||\r\n                  response.state === LoadingState.Loading\r\n                ) {\r\n                  return;\r\n                }\r\n                runningSubRequests--;\r\n                hasCountedAsDone = true;\r\n              },\r\n              () => {\r\n                if (hasCountedAsDone) {\r\n                  return;\r\n                }\r\n                hasCountedAsDone = true;\r\n                runningSubRequests--;\r\n              }\r\n            ),\r\n            map((response: DataQueryResponse) => {\r\n              return {\r\n                ...response,\r\n                data: response.data || [],\r\n                state: runningSubRequests === 0 ? LoadingState.Done : LoadingState.Loading,\r\n                key: `mixed-${i}-${response.key || ''}`,\r\n              } as DataQueryResponse;\r\n            })\r\n          );\r\n        })\r\n      );\r\n\r\n      observables.push(observable);\r\n    }\r\n\r\n    return merge(...observables);\r\n  }\r\n\r\n  testDatasource() {\r\n    return Promise.resolve({});\r\n  }\r\n}\r\n","import { MixedDatasource } from './MixedDataSource';\nexport { MixedDatasource, MixedDatasource as Datasource };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AAOA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAMA;AAEA;AAGA;;AAhDA;AAAA;AAiDA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;A","sourceRoot":""}