{"version":3,"file":"mssqlPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/features/datasources/utils/passwordHandlers.ts","webpack:///webpack:///./public/app/plugins/datasource/mssql/config_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/mssql/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/mssql/module.ts","webpack:///webpack:///./public/app/plugins/datasource/mssql/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/mssql/response_parser.ts"],"sourcesContent":["/**\r\n * Set of handlers for secure password field in Angular components. They handle backward compatibility with\r\n * passwords stored in plain text fields.\r\n */\r\n\r\nimport { SyntheticEvent } from 'react';\r\n\r\nexport enum PasswordFieldEnum {\r\n  Password = 'password',\r\n  BasicAuthPassword = 'basicAuthPassword',\r\n}\r\n\r\n/**\r\n * Basic shape for settings controllers in at the moment mostly angular datasource plugins.\r\n */\r\nexport type Ctrl = {\r\n  current: {\r\n    secureJsonFields: {\r\n      [key: string]: boolean;\r\n    };\r\n    secureJsonData?: {\r\n      [key: string]: string;\r\n    };\r\n    password?: string;\r\n    basicAuthPassword?: string;\r\n  };\r\n};\r\n\r\nexport const createResetHandler = (ctrl: Ctrl, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  event.preventDefault();\r\n  // Reset also normal plain text password to remove it and only save it in secureJsonData.\r\n  ctrl.current[field] = null;\r\n  ctrl.current.secureJsonFields[field] = false;\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = '';\r\n};\r\n\r\nexport const createChangeHandler = (ctrl: any, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = event.currentTarget.value;\r\n};\r\n","import {\r\n  createChangeHandler,\r\n  createResetHandler,\r\n  PasswordFieldEnum,\r\n} from '../../../features/datasources/utils/passwordHandlers';\r\n\r\nexport class MssqlConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n\r\n  current: any;\r\n  onPasswordReset: ReturnType<typeof createResetHandler>;\r\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any) {\r\n    this.current.jsonData.encrypt = this.current.jsonData.encrypt || 'false';\r\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\r\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport ResponseParser from './response_parser';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\n//Types\r\nimport { MssqlQueryForInterpolation } from './types';\r\n\r\nexport class MssqlDatasource {\r\n  id: any;\r\n  name: any;\r\n  responseParser: ResponseParser;\r\n  interval: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: any,\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv,\r\n    private timeSrv: TimeSrv\r\n  ) {\r\n    this.name = instanceSettings.name;\r\n    this.id = instanceSettings.id;\r\n    this.responseParser = new ResponseParser();\r\n    this.interval = (instanceSettings.jsonData || {}).timeInterval || '1m';\r\n  }\r\n\r\n  interpolateVariable(value: any, variable: any) {\r\n    if (typeof value === 'string') {\r\n      if (variable.multi || variable.includeAll) {\r\n        return \"'\" + value.replace(/'/g, `''`) + \"'\";\r\n      } else {\r\n        return value;\r\n      }\r\n    }\r\n\r\n    if (typeof value === 'number') {\r\n      return value;\r\n    }\r\n\r\n    const quotedValues = _.map(value, val => {\r\n      if (typeof value === 'number') {\r\n        return value;\r\n      }\r\n\r\n      return \"'\" + val.replace(/'/g, `''`) + \"'\";\r\n    });\r\n    return quotedValues.join(',');\r\n  }\r\n\r\n  interpolateVariablesInQueries(\r\n    queries: MssqlQueryForInterpolation[],\r\n    scopedVars: ScopedVars\r\n  ): MssqlQueryForInterpolation[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          rawSql: this.templateSrv.replace(query.rawSql, scopedVars, this.interpolateVariable),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  query(options: any) {\r\n    const queries = _.filter(options.targets, item => {\r\n      return item.hide !== true;\r\n    }).map(item => {\r\n      return {\r\n        refId: item.refId,\r\n        intervalMs: options.intervalMs,\r\n        maxDataPoints: options.maxDataPoints,\r\n        datasourceId: this.id,\r\n        rawSql: this.templateSrv.replace(item.rawSql, options.scopedVars, this.interpolateVariable),\r\n        format: item.format,\r\n      };\r\n    });\r\n\r\n    if (queries.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: queries,\r\n        },\r\n      })\r\n      .then(this.responseParser.processQueryResult);\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    if (!options.annotation.rawQuery) {\r\n      return Promise.reject({ message: 'Query missing in annotation definition' });\r\n    }\r\n\r\n    const query = {\r\n      refId: options.annotation.name,\r\n      datasourceId: this.id,\r\n      rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),\r\n      format: 'table',\r\n    };\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: [query],\r\n        },\r\n      })\r\n      .then((data: any) => this.responseParser.transformAnnotationResponse(options, data));\r\n  }\r\n\r\n  metricFindQuery(query: string, optionalOptions: { variable: { name: string } }) {\r\n    let refId = 'tempvar';\r\n    if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {\r\n      refId = optionalOptions.variable.name;\r\n    }\r\n\r\n    const interpolatedQuery = {\r\n      refId: refId,\r\n      datasourceId: this.id,\r\n      rawSql: this.templateSrv.replace(query, {}, this.interpolateVariable),\r\n      format: 'table',\r\n    };\r\n\r\n    const range = this.timeSrv.timeRange();\r\n    const data = {\r\n      queries: [interpolatedQuery],\r\n      from: range.from.valueOf().toString(),\r\n      to: range.to.valueOf().toString(),\r\n    };\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: data,\r\n      })\r\n      .then((data: any) => this.responseParser.parseMetricFindQueryResult(refId, data));\r\n  }\r\n\r\n  testDatasource() {\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: '5m',\r\n          to: 'now',\r\n          queries: [\r\n            {\r\n              refId: 'A',\r\n              intervalMs: 1,\r\n              maxDataPoints: 1,\r\n              datasourceId: this.id,\r\n              rawSql: 'SELECT 1',\r\n              format: 'table',\r\n            },\r\n          ],\r\n        },\r\n      })\r\n      .then((res: any) => {\r\n        return { status: 'success', message: 'Database Connection OK' };\r\n      })\r\n      .catch((err: any) => {\r\n        console.log(err);\r\n        if (err.data && err.data.message) {\r\n          return { status: 'error', message: err.data.message };\r\n        } else {\r\n          return { status: 'error', message: err.status };\r\n        }\r\n      });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    const rawSql = target.rawSql.replace('$__', '');\r\n    return this.templateSrv.variableExists(rawSql);\r\n  }\r\n}\r\n","import { MssqlDatasource } from './datasource';\r\nimport { MssqlQueryCtrl } from './query_ctrl';\r\nimport { MssqlConfigCtrl } from './config_ctrl';\r\n\r\nconst defaultQuery = `SELECT\r\n    <time_column> as time,\r\n    <text_column> as text,\r\n    <tags_column> as tags\r\n  FROM\r\n    <table name>\r\n  WHERE\r\n    $__timeFilter(time_column)\r\n  ORDER BY\r\n    <time_column> ASC`;\r\n\r\nclass MssqlAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n\r\n  annotation: any;\r\n\r\n  /** @ngInject */\r\n  constructor() {\r\n    this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;\r\n  }\r\n}\r\n\r\nexport {\r\n  MssqlDatasource,\r\n  MssqlDatasource as Datasource,\r\n  MssqlQueryCtrl as QueryCtrl,\r\n  MssqlConfigCtrl as ConfigCtrl,\r\n  MssqlAnnotationsQueryCtrl as AnnotationsQueryCtrl,\r\n};\r\n","import _ from 'lodash';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { auto } from 'angular';\r\nimport { PanelEvents } from '@grafana/data';\r\n\r\nexport interface MssqlQuery {\r\n  refId: string;\r\n  format: string;\r\n  alias: string;\r\n  rawSql: string;\r\n}\r\n\r\nexport interface QueryMeta {\r\n  sql: string;\r\n}\r\n\r\nconst defaultQuery = `SELECT\r\n  $__timeEpoch(<time_column>),\r\n  <value column> as value,\r\n  <series name column> as metric\r\nFROM\r\n  <table name>\r\nWHERE\r\n  $__timeFilter(time_column)\r\nORDER BY\r\n  <time_column> ASC`;\r\n\r\nexport class MssqlQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  showLastQuerySQL: boolean;\r\n  formats: any[];\r\n  target: MssqlQuery;\r\n  lastQueryMeta: QueryMeta;\r\n  lastQueryError: string;\r\n  showHelp: boolean;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any, $injector: auto.IInjectorService) {\r\n    super($scope, $injector);\r\n\r\n    this.target.format = this.target.format || 'time_series';\r\n    this.target.alias = '';\r\n    this.formats = [\r\n      { text: 'Time series', value: 'time_series' },\r\n      { text: 'Table', value: 'table' },\r\n    ];\r\n\r\n    if (!this.target.rawSql) {\r\n      // special handling when in table panel\r\n      if (this.panelCtrl.panel.type === 'table') {\r\n        this.target.format = 'table';\r\n        this.target.rawSql = 'SELECT 1';\r\n      } else {\r\n        this.target.rawSql = defaultQuery;\r\n      }\r\n    }\r\n\r\n    this.panelCtrl.events.on(PanelEvents.dataReceived, this.onDataReceived.bind(this), $scope);\r\n    this.panelCtrl.events.on(PanelEvents.dataError, this.onDataError.bind(this), $scope);\r\n  }\r\n\r\n  onDataReceived(dataList: any) {\r\n    this.lastQueryMeta = null;\r\n    this.lastQueryError = null;\r\n\r\n    const anySeriesFromQuery: any = _.find(dataList, { refId: this.target.refId });\r\n    if (anySeriesFromQuery) {\r\n      this.lastQueryMeta = anySeriesFromQuery.meta;\r\n    }\r\n  }\r\n\r\n  onDataError(err: any) {\r\n    if (err.data && err.data.results) {\r\n      const queryRes = err.data.results[this.target.refId];\r\n      if (queryRes) {\r\n        this.lastQueryMeta = queryRes.meta;\r\n        this.lastQueryError = queryRes.error;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import _ from 'lodash';\r\n\r\nexport default class ResponseParser {\r\n  processQueryResult(res: any) {\r\n    const data: any[] = [];\r\n\r\n    if (!res.data.results) {\r\n      return { data };\r\n    }\r\n\r\n    for (const key in res.data.results) {\r\n      const queryRes = res.data.results[key];\r\n\r\n      if (queryRes.series) {\r\n        for (const series of queryRes.series) {\r\n          data.push({\r\n            target: series.name,\r\n            datapoints: series.points,\r\n            refId: queryRes.refId,\r\n            meta: queryRes.meta,\r\n          });\r\n        }\r\n      }\r\n\r\n      if (queryRes.tables) {\r\n        for (const table of queryRes.tables) {\r\n          table.type = 'table';\r\n          table.refId = queryRes.refId;\r\n          table.meta = queryRes.meta;\r\n          data.push(table);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { data: data };\r\n  }\r\n\r\n  parseMetricFindQueryResult(refId: string, results: any) {\r\n    if (!results || results.data.length === 0 || results.data.results[refId].meta.rowCount === 0) {\r\n      return [];\r\n    }\r\n\r\n    const columns = results.data.results[refId].tables[0].columns;\r\n    const rows = results.data.results[refId].tables[0].rows;\r\n    const textColIndex = this.findColIndex(columns, '__text');\r\n    const valueColIndex = this.findColIndex(columns, '__value');\r\n\r\n    if (columns.length === 2 && textColIndex !== -1 && valueColIndex !== -1) {\r\n      return this.transformToKeyValueList(rows, textColIndex, valueColIndex);\r\n    }\r\n\r\n    return this.transformToSimpleList(rows);\r\n  }\r\n\r\n  transformToKeyValueList(rows: any, textColIndex: number, valueColIndex: number) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      if (!this.containsKey(res, rows[i][textColIndex])) {\r\n        res.push({ text: rows[i][textColIndex], value: rows[i][valueColIndex] });\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  transformToSimpleList(rows: any) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      for (let j = 0; j < rows[i].length; j++) {\r\n        const value = rows[i][j];\r\n        if (res.indexOf(value) === -1) {\r\n          res.push(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return _.map(res, value => {\r\n      return { text: value };\r\n    });\r\n  }\r\n\r\n  findColIndex(columns: any[], colName: string) {\r\n    for (let i = 0; i < columns.length; i++) {\r\n      if (columns[i].text === colName) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  containsKey(res: any[], key: any) {\r\n    for (let i = 0; i < res.length; i++) {\r\n      if (res[i].text === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  transformAnnotationResponse(options: any, data: any) {\r\n    const table = data.data.results[options.annotation.name].tables[0];\r\n\r\n    let timeColumnIndex = -1;\r\n    let timeEndColumnIndex = -1;\r\n    let textColumnIndex = -1;\r\n    let tagsColumnIndex = -1;\r\n\r\n    for (let i = 0; i < table.columns.length; i++) {\r\n      if (table.columns[i].text === 'time') {\r\n        timeColumnIndex = i;\r\n      } else if (table.columns[i].text === 'timeend') {\r\n        timeEndColumnIndex = i;\r\n      } else if (table.columns[i].text === 'text') {\r\n        textColumnIndex = i;\r\n      } else if (table.columns[i].text === 'tags') {\r\n        tagsColumnIndex = i;\r\n      }\r\n    }\r\n\r\n    if (timeColumnIndex === -1) {\r\n      return Promise.reject({ message: 'Missing mandatory time column (with time column alias) in annotation query.' });\r\n    }\r\n\r\n    const list = [];\r\n    for (let i = 0; i < table.rows.length; i++) {\r\n      const row = table.rows[i];\r\n      const timeEnd =\r\n        timeEndColumnIndex !== -1 && row[timeEndColumnIndex] ? Math.floor(row[timeEndColumnIndex]) : undefined;\r\n      list.push({\r\n        annotation: options.annotation,\r\n        time: Math.floor(row[timeColumnIndex]),\r\n        timeEnd,\r\n        text: row[textColumnIndex],\r\n        tags: row[tagsColumnIndex] ? row[tagsColumnIndex].trim().split(/\\s*,\\s*/) : [],\r\n      });\r\n    }\r\n\r\n    return list;\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAIA;AAAA;AACA;AACA;AACA;AAkBA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAMA;AAOA;AACA;AACA;AACA;AACA;AACA;AAXA;AAYA;AAAA;AAbA;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAQA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAWA;AAKA;AACA;AACA;AACA;AAPA;AAQA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AAEA;AAaA;AAWA;AAAA;AAUA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AAqDA;AAAA;AAtDA;;;;;;;;;;;;;;;;;;AC3BA;AAEA;AAAA;AA4IA;AA3IA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;A","sourceRoot":""}