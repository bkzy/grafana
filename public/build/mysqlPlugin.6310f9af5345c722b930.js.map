{"version":3,"file":"mysqlPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/core/components/sql_part/sql_part.ts","webpack:///webpack:///./public/app/features/datasources/utils/passwordHandlers.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/meta_query.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/module.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/mysql_query.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/response_parser.ts","webpack:///webpack:///./public/app/plugins/datasource/mysql/sql_part.ts"],"sourcesContent":["import _ from 'lodash';\r\n\r\nexport class SqlPartDef {\r\n  type: string;\r\n  style: string;\r\n  label: string;\r\n  params: any[];\r\n  defaultParams: any[];\r\n  wrapOpen: string;\r\n  wrapClose: string;\r\n  separator: string;\r\n\r\n  constructor(options: any) {\r\n    this.type = options.type;\r\n    if (options.label) {\r\n      this.label = options.label;\r\n    } else {\r\n      this.label = this.type[0].toUpperCase() + this.type.substring(1) + ':';\r\n    }\r\n    this.style = options.style;\r\n    if (this.style === 'function') {\r\n      this.wrapOpen = '(';\r\n      this.wrapClose = ')';\r\n      this.separator = ', ';\r\n    } else {\r\n      this.wrapOpen = ' ';\r\n      this.wrapClose = ' ';\r\n      this.separator = ' ';\r\n    }\r\n    this.params = options.params;\r\n    this.defaultParams = options.defaultParams;\r\n  }\r\n}\r\n\r\nexport class SqlPart {\r\n  part: any;\r\n  def: SqlPartDef;\r\n  params: any[];\r\n  label: string;\r\n  name: string;\r\n  datatype: string;\r\n\r\n  constructor(part: any, def: any) {\r\n    this.part = part;\r\n    this.def = def;\r\n    if (!this.def) {\r\n      throw { message: 'Could not find sql part ' + part.type };\r\n    }\r\n\r\n    this.datatype = part.datatype;\r\n\r\n    if (part.name) {\r\n      this.name = part.name;\r\n      this.label = def.label + ' ' + part.name;\r\n    } else {\r\n      this.name = '';\r\n      this.label = def.label;\r\n    }\r\n\r\n    part.params = part.params || _.clone(this.def.defaultParams);\r\n    this.params = part.params;\r\n  }\r\n\r\n  updateParam(strValue: string, index: number) {\r\n    // handle optional parameters\r\n    if (strValue === '' && this.def.params[index].optional) {\r\n      this.params.splice(index, 1);\r\n    } else {\r\n      this.params[index] = strValue;\r\n    }\r\n\r\n    this.part.params = this.params;\r\n  }\r\n}\r\n","/**\r\n * Set of handlers for secure password field in Angular components. They handle backward compatibility with\r\n * passwords stored in plain text fields.\r\n */\r\n\r\nimport { SyntheticEvent } from 'react';\r\n\r\nexport enum PasswordFieldEnum {\r\n  Password = 'password',\r\n  BasicAuthPassword = 'basicAuthPassword',\r\n}\r\n\r\n/**\r\n * Basic shape for settings controllers in at the moment mostly angular datasource plugins.\r\n */\r\nexport type Ctrl = {\r\n  current: {\r\n    secureJsonFields: {\r\n      [key: string]: boolean;\r\n    };\r\n    secureJsonData?: {\r\n      [key: string]: string;\r\n    };\r\n    password?: string;\r\n    basicAuthPassword?: string;\r\n  };\r\n};\r\n\r\nexport const createResetHandler = (ctrl: Ctrl, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  event.preventDefault();\r\n  // Reset also normal plain text password to remove it and only save it in secureJsonData.\r\n  ctrl.current[field] = null;\r\n  ctrl.current.secureJsonFields[field] = false;\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = '';\r\n};\r\n\r\nexport const createChangeHandler = (ctrl: any, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = event.currentTarget.value;\r\n};\r\n","import _ from 'lodash';\r\nimport ResponseParser from './response_parser';\r\nimport MysqlQuery from 'app/plugins/datasource/mysql/mysql_query';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\n//Types\r\nimport { MysqlQueryForInterpolation } from './types';\r\nimport { getSearchFilterScopedVar } from '../../../features/templating/variable';\r\n\r\nexport class MysqlDatasource {\r\n  id: any;\r\n  name: any;\r\n  responseParser: ResponseParser;\r\n  queryModel: MysqlQuery;\r\n  interval: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: any,\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv,\r\n    private timeSrv: TimeSrv\r\n  ) {\r\n    this.name = instanceSettings.name;\r\n    this.id = instanceSettings.id;\r\n    this.responseParser = new ResponseParser();\r\n    this.queryModel = new MysqlQuery({});\r\n    this.interval = (instanceSettings.jsonData || {}).timeInterval || '1m';\r\n  }\r\n\r\n  interpolateVariable = (value: string, variable: any) => {\r\n    if (typeof value === 'string') {\r\n      if (variable.multi || variable.includeAll) {\r\n        const result = this.queryModel.quoteLiteral(value);\r\n        return result;\r\n      } else {\r\n        return value;\r\n      }\r\n    }\r\n\r\n    if (typeof value === 'number') {\r\n      return value;\r\n    }\r\n\r\n    const quotedValues = _.map(value, (v: any) => {\r\n      return this.queryModel.quoteLiteral(v);\r\n    });\r\n    return quotedValues.join(',');\r\n  };\r\n\r\n  interpolateVariablesInQueries(\r\n    queries: MysqlQueryForInterpolation[],\r\n    scopedVars: ScopedVars\r\n  ): MysqlQueryForInterpolation[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          rawSql: this.templateSrv.replace(query.rawSql, scopedVars, this.interpolateVariable),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  query(options: any) {\r\n    const queries = _.filter(options.targets, target => {\r\n      return target.hide !== true;\r\n    }).map(target => {\r\n      const queryModel = new MysqlQuery(target, this.templateSrv, options.scopedVars);\r\n\r\n      return {\r\n        refId: target.refId,\r\n        intervalMs: options.intervalMs,\r\n        maxDataPoints: options.maxDataPoints,\r\n        datasourceId: this.id,\r\n        rawSql: queryModel.render(this.interpolateVariable as any),\r\n        format: target.format,\r\n      };\r\n    });\r\n\r\n    if (queries.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: queries,\r\n        },\r\n      })\r\n      .then(this.responseParser.processQueryResult);\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    if (!options.annotation.rawQuery) {\r\n      return Promise.reject({\r\n        message: 'Query missing in annotation definition',\r\n      });\r\n    }\r\n\r\n    const query = {\r\n      refId: options.annotation.name,\r\n      datasourceId: this.id,\r\n      rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),\r\n      format: 'table',\r\n    };\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: [query],\r\n        },\r\n      })\r\n      .then((data: any) => this.responseParser.transformAnnotationResponse(options, data));\r\n  }\r\n\r\n  metricFindQuery(query: string, optionalOptions: any) {\r\n    let refId = 'tempvar';\r\n    if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {\r\n      refId = optionalOptions.variable.name;\r\n    }\r\n\r\n    const rawSql = this.templateSrv.replace(\r\n      query,\r\n      getSearchFilterScopedVar({ query, wildcardChar: '%', options: optionalOptions }),\r\n      this.interpolateVariable\r\n    );\r\n\r\n    const interpolatedQuery = {\r\n      refId: refId,\r\n      datasourceId: this.id,\r\n      rawSql,\r\n      format: 'table',\r\n    };\r\n\r\n    const range = this.timeSrv.timeRange();\r\n    const data = {\r\n      queries: [interpolatedQuery],\r\n      from: range.from.valueOf().toString(),\r\n      to: range.to.valueOf().toString(),\r\n    };\r\n\r\n    if (optionalOptions && optionalOptions.range && optionalOptions.range.from) {\r\n      data['from'] = optionalOptions.range.from.valueOf().toString();\r\n    }\r\n    if (optionalOptions && optionalOptions.range && optionalOptions.range.to) {\r\n      data['to'] = optionalOptions.range.to.valueOf().toString();\r\n    }\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: data,\r\n      })\r\n      .then((data: any) => this.responseParser.parseMetricFindQueryResult(refId, data));\r\n  }\r\n\r\n  testDatasource() {\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: '5m',\r\n          to: 'now',\r\n          queries: [\r\n            {\r\n              refId: 'A',\r\n              intervalMs: 1,\r\n              maxDataPoints: 1,\r\n              datasourceId: this.id,\r\n              rawSql: 'SELECT 1',\r\n              format: 'table',\r\n            },\r\n          ],\r\n        },\r\n      })\r\n      .then((res: any) => {\r\n        return { status: 'success', message: 'Database Connection OK' };\r\n      })\r\n      .catch((err: any) => {\r\n        console.log(err);\r\n        if (err.data && err.data.message) {\r\n          return { status: 'error', message: err.data.message };\r\n        } else {\r\n          return { status: 'error', message: err.status };\r\n        }\r\n      });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    let rawSql = '';\r\n\r\n    if (target.rawQuery) {\r\n      rawSql = target.rawSql;\r\n    } else {\r\n      const query = new MysqlQuery(target);\r\n      rawSql = query.buildQuery();\r\n    }\r\n\r\n    rawSql = rawSql.replace('$__', '');\r\n\r\n    return this.templateSrv.variableExists(rawSql);\r\n  }\r\n}\r\n","export class MysqlMetaQuery {\n  constructor(private target: any, private queryModel: any) {}\n\n  getOperators(datatype: string) {\n    switch (datatype) {\n      case 'double':\n      case 'float': {\n        return ['=', '!=', '<', '<=', '>', '>='];\n      }\n      case 'text':\n      case 'tinytext':\n      case 'mediumtext':\n      case 'longtext':\n      case 'varchar':\n      case 'char': {\n        return ['=', '!=', '<', '<=', '>', '>=', 'IN', 'NOT IN', 'LIKE', 'NOT LIKE'];\n      }\n      default: {\n        return ['=', '!=', '<', '<=', '>', '>=', 'IN', 'NOT IN'];\n      }\n    }\n  }\n\n  // quote identifier as literal to use in metadata queries\n  quoteIdentAsLiteral(value: string) {\n    return this.queryModel.quoteLiteral(this.queryModel.unquoteIdentifier(value));\n  }\n\n  findMetricTable() {\n    // query that returns first table found that has a timestamp(tz) column and a float column\n    const query = `\n  SELECT\n    table_name as table_name,\n    ( SELECT\n        column_name as column_name\n      FROM information_schema.columns c\n      WHERE\n        c.table_schema = t.table_schema AND\n        c.table_name = t.table_name AND\n        c.data_type IN ('timestamp', 'datetime')\n      ORDER BY ordinal_position LIMIT 1\n    ) AS time_column,\n    ( SELECT\n        column_name AS column_name\n      FROM information_schema.columns c\n      WHERE\n        c.table_schema = t.table_schema AND\n        c.table_name = t.table_name AND\n        c.data_type IN('float', 'int', 'bigint')\n      ORDER BY ordinal_position LIMIT 1\n    ) AS value_column\n  FROM information_schema.tables t\n  WHERE\n    t.table_schema = database() AND\n    EXISTS\n    ( SELECT 1\n      FROM information_schema.columns c\n      WHERE\n        c.table_schema = t.table_schema AND\n        c.table_name = t.table_name AND\n        c.data_type IN ('timestamp', 'datetime')\n    ) AND\n    EXISTS\n    ( SELECT 1\n      FROM information_schema.columns c\n      WHERE\n        c.table_schema = t.table_schema AND\n        c.table_name = t.table_name AND\n        c.data_type IN('float', 'int', 'bigint')\n    )\n  LIMIT 1\n;`;\n    return query;\n  }\n\n  buildTableConstraint(table: string) {\n    let query = '';\n\n    // check for schema qualified table\n    if (table.includes('.')) {\n      const parts = table.split('.');\n      query = 'table_schema = ' + this.quoteIdentAsLiteral(parts[0]);\n      query += ' AND table_name = ' + this.quoteIdentAsLiteral(parts[1]);\n      return query;\n    } else {\n      query = 'table_schema = database() AND table_name = ' + this.quoteIdentAsLiteral(table);\n\n      return query;\n    }\n  }\n\n  buildTableQuery() {\n    return 'SELECT table_name FROM information_schema.tables WHERE table_schema = database() ORDER BY table_name';\n  }\n\n  buildColumnQuery(type?: string) {\n    let query = 'SELECT column_name FROM information_schema.columns WHERE ';\n    query += this.buildTableConstraint(this.target.table);\n\n    switch (type) {\n      case 'time': {\n        query += \" AND data_type IN ('timestamp','datetime','bigint','int','double','float')\";\n        break;\n      }\n      case 'metric': {\n        query += \" AND data_type IN ('text','tinytext','mediumtext','longtext','varchar','char')\";\n        break;\n      }\n      case 'value': {\n        query += \" AND data_type IN ('bigint','int','smallint','mediumint','tinyint','double','decimal','float')\";\n        query += ' AND column_name <> ' + this.quoteIdentAsLiteral(this.target.timeColumn);\n        break;\n      }\n      case 'group': {\n        query += \" AND data_type IN ('text','tinytext','mediumtext','longtext','varchar','char')\";\n        break;\n      }\n    }\n\n    query += ' ORDER BY column_name';\n\n    return query;\n  }\n\n  buildValueQuery(column: string) {\n    let query = 'SELECT DISTINCT QUOTE(' + column + ')';\n    query += ' FROM ' + this.target.table;\n    query += ' WHERE $__timeFilter(' + this.target.timeColumn + ')';\n    query += ' ORDER BY 1 LIMIT 100';\n    return query;\n  }\n\n  buildDatatypeQuery(column: string) {\n    let query = `\nSELECT data_type\nFROM information_schema.columns\nWHERE `;\n    query += ' table_name = ' + this.quoteIdentAsLiteral(this.target.table);\n    query += ' AND column_name = ' + this.quoteIdentAsLiteral(column);\n    return query;\n  }\n}\n","import { MysqlDatasource } from './datasource';\r\nimport { MysqlQueryCtrl } from './query_ctrl';\r\nimport {\r\n  createChangeHandler,\r\n  createResetHandler,\r\n  PasswordFieldEnum,\r\n} from '../../../features/datasources/utils/passwordHandlers';\r\n\r\nclass MysqlConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n  current: any;\r\n  onPasswordReset: ReturnType<typeof createResetHandler>;\r\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\r\n\r\n  constructor() {\r\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\r\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\r\n  }\r\n}\r\n\r\nconst defaultQuery = `SELECT\r\n    UNIX_TIMESTAMP(<time_column>) as time_sec,\r\n    <text_column> as text,\r\n    <tags_column> as tags\r\n  FROM <table name>\r\n  WHERE $__timeFilter(time_column)\r\n  ORDER BY <time_column> ASC\r\n  LIMIT 100\r\n  `;\r\n\r\nclass MysqlAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n\r\n  annotation: any;\r\n\r\n  /** @ngInject */\r\n  constructor() {\r\n    this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;\r\n  }\r\n}\r\n\r\nexport {\r\n  MysqlDatasource,\r\n  MysqlDatasource as Datasource,\r\n  MysqlQueryCtrl as QueryCtrl,\r\n  MysqlConfigCtrl as ConfigCtrl,\r\n  MysqlAnnotationsQueryCtrl as AnnotationsQueryCtrl,\r\n};\r\n","import _ from 'lodash';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\n\r\nexport default class MysqlQuery {\r\n  target: any;\r\n  templateSrv: any;\r\n  scopedVars: any;\r\n\r\n  /** @ngInject */\r\n  constructor(target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\r\n    this.target = target;\r\n    this.templateSrv = templateSrv;\r\n    this.scopedVars = scopedVars;\r\n\r\n    target.format = target.format || 'time_series';\r\n    target.timeColumn = target.timeColumn || 'time';\r\n    target.metricColumn = target.metricColumn || 'none';\r\n\r\n    target.group = target.group || [];\r\n    target.where = target.where || [{ type: 'macro', name: '$__timeFilter', params: [] }];\r\n    target.select = target.select || [[{ type: 'column', params: ['value'] }]];\r\n\r\n    // handle pre query gui panels gracefully\r\n    if (!('rawQuery' in this.target)) {\r\n      if ('rawSql' in target) {\r\n        // pre query gui panel\r\n        target.rawQuery = true;\r\n      } else {\r\n        // new panel\r\n        target.rawQuery = false;\r\n      }\r\n    }\r\n\r\n    // give interpolateQueryStr access to this\r\n    this.interpolateQueryStr = this.interpolateQueryStr.bind(this);\r\n  }\r\n\r\n  // remove identifier quoting from identifier to use in metadata queries\r\n  unquoteIdentifier(value: string) {\r\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\r\n      return value.substring(1, value.length - 1).replace(/\"\"/g, '\"');\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  quoteIdentifier(value: string) {\r\n    return '\"' + value.replace(/\"/g, '\"\"') + '\"';\r\n  }\r\n\r\n  quoteLiteral(value: string) {\r\n    return \"'\" + value.replace(/'/g, \"''\") + \"'\";\r\n  }\r\n\r\n  escapeLiteral(value: any) {\r\n    return String(value).replace(/'/g, \"''\");\r\n  }\r\n\r\n  hasTimeGroup() {\r\n    return _.find(this.target.group, (g: any) => g.type === 'time');\r\n  }\r\n\r\n  hasMetricColumn() {\r\n    return this.target.metricColumn !== 'none';\r\n  }\r\n\r\n  interpolateQueryStr(value: string, variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\r\n    // if no multi or include all do not regexEscape\r\n    if (!variable.multi && !variable.includeAll) {\r\n      return this.escapeLiteral(value);\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return this.quoteLiteral(value);\r\n    }\r\n\r\n    const escapedValues = _.map(value, this.quoteLiteral);\r\n    return escapedValues.join(',');\r\n  }\r\n\r\n  render(interpolate?: boolean) {\r\n    const target = this.target;\r\n\r\n    // new query with no table set yet\r\n    if (!this.target.rawQuery && !('table' in this.target)) {\r\n      return '';\r\n    }\r\n\r\n    if (!target.rawQuery) {\r\n      target.rawSql = this.buildQuery();\r\n    }\r\n\r\n    if (interpolate) {\r\n      return this.templateSrv.replace(target.rawSql, this.scopedVars, this.interpolateQueryStr);\r\n    } else {\r\n      return target.rawSql;\r\n    }\r\n  }\r\n\r\n  hasUnixEpochTimecolumn() {\r\n    return ['int', 'bigint', 'double'].indexOf(this.target.timeColumnType) > -1;\r\n  }\r\n\r\n  buildTimeColumn(alias = true) {\r\n    const timeGroup = this.hasTimeGroup();\r\n    let query;\r\n    let macro = '$__timeGroup';\r\n\r\n    if (timeGroup) {\r\n      let args;\r\n      if (timeGroup.params.length > 1 && timeGroup.params[1] !== 'none') {\r\n        args = timeGroup.params.join(',');\r\n      } else {\r\n        args = timeGroup.params[0];\r\n      }\r\n      if (this.hasUnixEpochTimecolumn()) {\r\n        macro = '$__unixEpochGroup';\r\n      }\r\n      if (alias) {\r\n        macro += 'Alias';\r\n      }\r\n      query = macro + '(' + this.target.timeColumn + ',' + args + ')';\r\n    } else {\r\n      query = this.target.timeColumn;\r\n      if (alias) {\r\n        query += ' AS \"time\"';\r\n      }\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildMetricColumn() {\r\n    if (this.hasMetricColumn()) {\r\n      return this.target.metricColumn + ' AS metric';\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  buildValueColumns() {\r\n    let query = '';\r\n    for (const column of this.target.select) {\r\n      query += ',\\n  ' + this.buildValueColumn(column);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildValueColumn(column: any) {\r\n    let query = '';\r\n\r\n    const columnName: any = _.find(column, (g: any) => g.type === 'column');\r\n    query = columnName.params[0];\r\n\r\n    const aggregate: any = _.find(column, (g: any) => g.type === 'aggregate');\r\n\r\n    if (aggregate) {\r\n      const func = aggregate.params[0];\r\n      query = func + '(' + query + ')';\r\n    }\r\n\r\n    const alias: any = _.find(column, (g: any) => g.type === 'alias');\r\n    if (alias) {\r\n      query += ' AS ' + this.quoteIdentifier(alias.params[0]);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildWhereClause() {\r\n    let query = '';\r\n    const conditions = _.map(this.target.where, (tag, index) => {\r\n      switch (tag.type) {\r\n        case 'macro':\r\n          return tag.name + '(' + this.target.timeColumn + ')';\r\n          break;\r\n        case 'expression':\r\n          return tag.params.join(' ');\r\n          break;\r\n      }\r\n    });\r\n\r\n    if (conditions.length > 0) {\r\n      query = '\\nWHERE\\n  ' + conditions.join(' AND\\n  ');\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildGroupClause() {\r\n    let query = '';\r\n    let groupSection = '';\r\n\r\n    for (let i = 0; i < this.target.group.length; i++) {\r\n      const part = this.target.group[i];\r\n      if (i > 0) {\r\n        groupSection += ', ';\r\n      }\r\n      if (part.type === 'time') {\r\n        groupSection += '1';\r\n      } else {\r\n        groupSection += part.params[0];\r\n      }\r\n    }\r\n\r\n    if (groupSection.length) {\r\n      query = '\\nGROUP BY ' + groupSection;\r\n      if (this.hasMetricColumn()) {\r\n        query += ',2';\r\n      }\r\n    }\r\n    return query;\r\n  }\r\n\r\n  buildQuery() {\r\n    let query = 'SELECT';\r\n\r\n    query += '\\n  ' + this.buildTimeColumn();\r\n    if (this.hasMetricColumn()) {\r\n      query += ',\\n  ' + this.buildMetricColumn();\r\n    }\r\n    query += this.buildValueColumns();\r\n\r\n    query += '\\nFROM ' + this.target.table;\r\n\r\n    query += this.buildWhereClause();\r\n    query += this.buildGroupClause();\r\n\r\n    query += '\\nORDER BY ' + this.buildTimeColumn(false);\r\n\r\n    return query;\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport appEvents from 'app/core/app_events';\r\nimport { MysqlMetaQuery } from './meta_query';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { SqlPart } from 'app/core/components/sql_part/sql_part';\r\nimport MysqlQuery from './mysql_query';\r\nimport sqlPart from './sql_part';\r\nimport { auto } from 'angular';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { CoreEvents } from 'app/types';\r\nimport { PanelEvents } from '@grafana/data';\r\n\r\nexport interface QueryMeta {\r\n  sql: string;\r\n}\r\n\r\nconst defaultQuery = `SELECT\r\n  UNIX_TIMESTAMP(<time_column>) as time_sec,\r\n  <value column> as value,\r\n  <series name column> as metric\r\nFROM <table name>\r\nWHERE $__timeFilter(time_column)\r\nORDER BY <time_column> ASC\r\n`;\r\n\r\nexport class MysqlQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  showLastQuerySQL: boolean;\r\n  formats: any[];\r\n  lastQueryMeta: QueryMeta;\r\n  lastQueryError: string;\r\n  showHelp: boolean;\r\n\r\n  queryModel: MysqlQuery;\r\n  metaBuilder: MysqlMetaQuery;\r\n  tableSegment: any;\r\n  whereAdd: any;\r\n  timeColumnSegment: any;\r\n  metricColumnSegment: any;\r\n  selectMenu: any[];\r\n  selectParts: SqlPart[][];\r\n  groupParts: SqlPart[];\r\n  whereParts: SqlPart[];\r\n  groupAdd: any;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    $scope: any,\r\n    $injector: auto.IInjectorService,\r\n    private templateSrv: TemplateSrv,\r\n    private uiSegmentSrv: any\r\n  ) {\r\n    super($scope, $injector);\r\n\r\n    this.target = this.target;\r\n    this.queryModel = new MysqlQuery(this.target, templateSrv, this.panel.scopedVars);\r\n    this.metaBuilder = new MysqlMetaQuery(this.target, this.queryModel);\r\n    this.updateProjection();\r\n\r\n    this.formats = [\r\n      { text: 'Time series', value: 'time_series' },\r\n      { text: 'Table', value: 'table' },\r\n    ];\r\n\r\n    if (!this.target.rawSql) {\r\n      // special handling when in table panel\r\n      if (this.panelCtrl.panel.type === 'table') {\r\n        this.target.format = 'table';\r\n        this.target.rawSql = 'SELECT 1';\r\n        this.target.rawQuery = true;\r\n      } else {\r\n        this.target.rawSql = defaultQuery;\r\n        this.datasource.metricFindQuery(this.metaBuilder.findMetricTable()).then((result: any) => {\r\n          if (result.length > 0) {\r\n            this.target.table = result[0].text;\r\n            let segment = this.uiSegmentSrv.newSegment(this.target.table);\r\n            this.tableSegment.html = segment.html;\r\n            this.tableSegment.value = segment.value;\r\n\r\n            this.target.timeColumn = result[1].text;\r\n            segment = this.uiSegmentSrv.newSegment(this.target.timeColumn);\r\n            this.timeColumnSegment.html = segment.html;\r\n            this.timeColumnSegment.value = segment.value;\r\n\r\n            this.target.timeColumnType = 'timestamp';\r\n            this.target.select = [[{ type: 'column', params: [result[2].text] }]];\r\n            this.updateProjection();\r\n            this.updateRawSqlAndRefresh();\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!this.target.table) {\r\n      this.tableSegment = uiSegmentSrv.newSegment({ value: 'select table', fake: true });\r\n    } else {\r\n      this.tableSegment = uiSegmentSrv.newSegment(this.target.table);\r\n    }\r\n\r\n    this.timeColumnSegment = uiSegmentSrv.newSegment(this.target.timeColumn);\r\n    this.metricColumnSegment = uiSegmentSrv.newSegment(this.target.metricColumn);\r\n\r\n    this.buildSelectMenu();\r\n    this.whereAdd = this.uiSegmentSrv.newPlusButton();\r\n    this.groupAdd = this.uiSegmentSrv.newPlusButton();\r\n\r\n    this.panelCtrl.events.on(PanelEvents.dataReceived, this.onDataReceived.bind(this), $scope);\r\n    this.panelCtrl.events.on(PanelEvents.dataError, this.onDataError.bind(this), $scope);\r\n  }\r\n\r\n  updateRawSqlAndRefresh() {\r\n    if (!this.target.rawQuery) {\r\n      this.target.rawSql = this.queryModel.buildQuery();\r\n    }\r\n\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  updateProjection() {\r\n    this.selectParts = _.map(this.target.select, (parts: any) => {\r\n      return _.map(parts, sqlPart.create).filter(n => n);\r\n    });\r\n    this.whereParts = _.map(this.target.where, sqlPart.create).filter(n => n);\r\n    this.groupParts = _.map(this.target.group, sqlPart.create).filter(n => n);\r\n  }\r\n\r\n  updatePersistedParts() {\r\n    this.target.select = _.map(this.selectParts, selectParts => {\r\n      return _.map(selectParts, (part: any) => {\r\n        return { type: part.def.type, datatype: part.datatype, params: part.params };\r\n      });\r\n    });\r\n    this.target.where = _.map(this.whereParts, (part: any) => {\r\n      return { type: part.def.type, datatype: part.datatype, name: part.name, params: part.params };\r\n    });\r\n    this.target.group = _.map(this.groupParts, (part: any) => {\r\n      return { type: part.def.type, datatype: part.datatype, params: part.params };\r\n    });\r\n  }\r\n\r\n  buildSelectMenu() {\r\n    this.selectMenu = [];\r\n    const aggregates = {\r\n      text: 'Aggregate Functions',\r\n      value: 'aggregate',\r\n      submenu: [\r\n        { text: 'Average', value: 'avg' },\r\n        { text: 'Count', value: 'count' },\r\n        { text: 'Maximum', value: 'max' },\r\n        { text: 'Minimum', value: 'min' },\r\n        { text: 'Sum', value: 'sum' },\r\n        { text: 'Standard deviation', value: 'stddev' },\r\n        { text: 'Variance', value: 'variance' },\r\n      ],\r\n    };\r\n\r\n    this.selectMenu.push(aggregates);\r\n    this.selectMenu.push({ text: 'Alias', value: 'alias' });\r\n    this.selectMenu.push({ text: 'Column', value: 'column' });\r\n  }\r\n\r\n  toggleEditorMode() {\r\n    if (this.target.rawQuery) {\r\n      appEvents.emit(CoreEvents.showConfirmModal, {\r\n        title: 'Warning',\r\n        text2: 'Switching to query builder may overwrite your raw SQL.',\r\n        icon: 'fa-exclamation',\r\n        yesText: 'Switch',\r\n        onConfirm: () => {\r\n          this.target.rawQuery = !this.target.rawQuery;\r\n        },\r\n      });\r\n    } else {\r\n      this.target.rawQuery = !this.target.rawQuery;\r\n    }\r\n  }\r\n\r\n  resetPlusButton(button: { html: any; value: any }) {\r\n    const plusButton = this.uiSegmentSrv.newPlusButton();\r\n    button.html = plusButton.html;\r\n    button.value = plusButton.value;\r\n  }\r\n\r\n  getTableSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildTableQuery())\r\n      .then(this.transformToSegments({}))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  tableChanged() {\r\n    this.target.table = this.tableSegment.value;\r\n    this.target.where = [];\r\n    this.target.group = [];\r\n    this.updateProjection();\r\n\r\n    const segment = this.uiSegmentSrv.newSegment('none');\r\n    this.metricColumnSegment.html = segment.html;\r\n    this.metricColumnSegment.value = segment.value;\r\n    this.target.metricColumn = 'none';\r\n\r\n    const task1 = this.datasource.metricFindQuery(this.metaBuilder.buildColumnQuery('time')).then((result: any) => {\r\n      // check if time column is still valid\r\n      if (result.length > 0 && !_.find(result, (r: any) => r.text === this.target.timeColumn)) {\r\n        const segment = this.uiSegmentSrv.newSegment(result[0].text);\r\n        this.timeColumnSegment.html = segment.html;\r\n        this.timeColumnSegment.value = segment.value;\r\n      }\r\n      return this.timeColumnChanged(false);\r\n    });\r\n    const task2 = this.datasource.metricFindQuery(this.metaBuilder.buildColumnQuery('value')).then((result: any) => {\r\n      if (result.length > 0) {\r\n        this.target.select = [[{ type: 'column', params: [result[0].text] }]];\r\n        this.updateProjection();\r\n      }\r\n    });\r\n\r\n    Promise.all([task1, task2]).then(() => {\r\n      this.updateRawSqlAndRefresh();\r\n    });\r\n  }\r\n\r\n  getTimeColumnSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('time'))\r\n      .then(this.transformToSegments({}))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  timeColumnChanged(refresh?: boolean) {\r\n    this.target.timeColumn = this.timeColumnSegment.value;\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildDatatypeQuery(this.target.timeColumn))\r\n      .then((result: any) => {\r\n        if (result.length === 1) {\r\n          if (this.target.timeColumnType !== result[0].text) {\r\n            this.target.timeColumnType = result[0].text;\r\n          }\r\n          let partModel;\r\n          if (this.queryModel.hasUnixEpochTimecolumn()) {\r\n            partModel = sqlPart.create({ type: 'macro', name: '$__unixEpochFilter', params: [] });\r\n          } else {\r\n            partModel = sqlPart.create({ type: 'macro', name: '$__timeFilter', params: [] });\r\n          }\r\n\r\n          if (this.whereParts.length >= 1 && this.whereParts[0].def.type === 'macro') {\r\n            // replace current macro\r\n            this.whereParts[0] = partModel;\r\n          } else {\r\n            this.whereParts.splice(0, 0, partModel);\r\n          }\r\n        }\r\n\r\n        this.updatePersistedParts();\r\n        if (refresh !== false) {\r\n          this.updateRawSqlAndRefresh();\r\n        }\r\n      });\r\n  }\r\n\r\n  getMetricColumnSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('metric'))\r\n      .then(this.transformToSegments({ addNone: true }))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  metricColumnChanged() {\r\n    this.target.metricColumn = this.metricColumnSegment.value;\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  onDataReceived(dataList: any) {\r\n    this.lastQueryMeta = null;\r\n    this.lastQueryError = null;\r\n\r\n    const anySeriesFromQuery: any = _.find(dataList, { refId: this.target.refId });\r\n    if (anySeriesFromQuery) {\r\n      this.lastQueryMeta = anySeriesFromQuery.meta;\r\n    }\r\n  }\r\n\r\n  onDataError(err: any) {\r\n    if (err.data && err.data.results) {\r\n      const queryRes = err.data.results[this.target.refId];\r\n      if (queryRes) {\r\n        this.lastQueryMeta = queryRes.meta;\r\n        this.lastQueryError = queryRes.error;\r\n      }\r\n    }\r\n  }\r\n\r\n  transformToSegments(config: any) {\r\n    return (results: any) => {\r\n      const segments = _.map(results, segment => {\r\n        return this.uiSegmentSrv.newSegment({\r\n          value: segment.text,\r\n          expandable: segment.expandable,\r\n        });\r\n      });\r\n\r\n      if (config.addTemplateVars) {\r\n        for (const variable of this.templateSrv.variables) {\r\n          let value;\r\n          value = '$' + variable.name;\r\n          if (config.templateQuoter && variable.multi === false) {\r\n            value = config.templateQuoter(value);\r\n          }\r\n\r\n          segments.unshift(\r\n            this.uiSegmentSrv.newSegment({\r\n              type: 'template',\r\n              value: value,\r\n              expandable: true,\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      if (config.addNone) {\r\n        segments.unshift(this.uiSegmentSrv.newSegment({ type: 'template', value: 'none', expandable: true }));\r\n      }\r\n\r\n      return segments;\r\n    };\r\n  }\r\n\r\n  findAggregateIndex(selectParts: any) {\r\n    return _.findIndex(selectParts, (p: any) => p.def.type === 'aggregate' || p.def.type === 'percentile');\r\n  }\r\n\r\n  findWindowIndex(selectParts: any) {\r\n    return _.findIndex(selectParts, (p: any) => p.def.type === 'window' || p.def.type === 'moving_window');\r\n  }\r\n\r\n  addSelectPart(selectParts: any[], item: { value: any }, subItem: { type: any; value: any }) {\r\n    let partType = item.value;\r\n    if (subItem && subItem.type) {\r\n      partType = subItem.type;\r\n    }\r\n    let partModel = sqlPart.create({ type: partType });\r\n    if (subItem) {\r\n      partModel.params[0] = subItem.value;\r\n    }\r\n    let addAlias = false;\r\n\r\n    switch (partType) {\r\n      case 'column':\r\n        const parts = _.map(selectParts, (part: any) => {\r\n          return sqlPart.create({ type: part.def.type, params: _.clone(part.params) });\r\n        });\r\n        this.selectParts.push(parts);\r\n        break;\r\n      case 'percentile':\r\n      case 'aggregate':\r\n        // add group by if no group by yet\r\n        if (this.target.group.length === 0) {\r\n          this.addGroup('time', '$__interval');\r\n        }\r\n        const aggIndex = this.findAggregateIndex(selectParts);\r\n        if (aggIndex !== -1) {\r\n          // replace current aggregation\r\n          selectParts[aggIndex] = partModel;\r\n        } else {\r\n          selectParts.splice(1, 0, partModel);\r\n        }\r\n        if (!_.find(selectParts, (p: any) => p.def.type === 'alias')) {\r\n          addAlias = true;\r\n        }\r\n        break;\r\n      case 'moving_window':\r\n      case 'window':\r\n        const windowIndex = this.findWindowIndex(selectParts);\r\n        if (windowIndex !== -1) {\r\n          // replace current window function\r\n          selectParts[windowIndex] = partModel;\r\n        } else {\r\n          const aggIndex = this.findAggregateIndex(selectParts);\r\n          if (aggIndex !== -1) {\r\n            selectParts.splice(aggIndex + 1, 0, partModel);\r\n          } else {\r\n            selectParts.splice(1, 0, partModel);\r\n          }\r\n        }\r\n        if (!_.find(selectParts, (p: any) => p.def.type === 'alias')) {\r\n          addAlias = true;\r\n        }\r\n        break;\r\n      case 'alias':\r\n        addAlias = true;\r\n        break;\r\n    }\r\n\r\n    if (addAlias) {\r\n      // set initial alias name to column name\r\n      partModel = sqlPart.create({ type: 'alias', params: [selectParts[0].params[0].replace(/\"/g, '')] });\r\n      if (selectParts[selectParts.length - 1].def.type === 'alias') {\r\n        selectParts[selectParts.length - 1] = partModel;\r\n      } else {\r\n        selectParts.push(partModel);\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  removeSelectPart(selectParts: any, part: { def: { type: string } }) {\r\n    if (part.def.type === 'column') {\r\n      // remove all parts of column unless its last column\r\n      if (this.selectParts.length > 1) {\r\n        const modelsIndex = _.indexOf(this.selectParts, selectParts);\r\n        this.selectParts.splice(modelsIndex, 1);\r\n      }\r\n    } else {\r\n      const partIndex = _.indexOf(selectParts, part);\r\n      selectParts.splice(partIndex, 1);\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  handleSelectPartEvent(selectParts: any, part: { def: any }, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        switch (part.def.type) {\r\n          // case 'aggregate':\r\n          //   return this.datasource\r\n          //     .metricFindQuery(this.metaBuilder.buildAggregateQuery())\r\n          //     .then(this.transformToSegments({}))\r\n          //     .catch(this.handleQueryError.bind(this));\r\n          case 'column':\r\n            return this.datasource\r\n              .metricFindQuery(this.metaBuilder.buildColumnQuery('value'))\r\n              .then(this.transformToSegments({}))\r\n              .catch(this.handleQueryError.bind(this));\r\n        }\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.removeSelectPart(selectParts, part);\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleGroupPartEvent(part: any, index: any, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        return this.datasource\r\n          .metricFindQuery(this.metaBuilder.buildColumnQuery())\r\n          .then(this.transformToSegments({}))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.removeGroup(part, index);\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  addGroup(partType: string, value: string) {\r\n    let params = [value];\r\n    if (partType === 'time') {\r\n      params = ['$__interval', 'none'];\r\n    }\r\n    const partModel = sqlPart.create({ type: partType, params: params });\r\n\r\n    if (partType === 'time') {\r\n      // put timeGroup at start\r\n      this.groupParts.splice(0, 0, partModel);\r\n    } else {\r\n      this.groupParts.push(partModel);\r\n    }\r\n\r\n    // add aggregates when adding group by\r\n    for (const selectParts of this.selectParts) {\r\n      if (!selectParts.some(part => part.def.type === 'aggregate')) {\r\n        const aggregate = sqlPart.create({ type: 'aggregate', params: ['avg'] });\r\n        selectParts.splice(1, 0, aggregate);\r\n        if (!selectParts.some(part => part.def.type === 'alias')) {\r\n          const alias = sqlPart.create({ type: 'alias', params: [selectParts[0].part.params[0]] });\r\n          selectParts.push(alias);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  removeGroup(part: { def: { type: string } }, index: number) {\r\n    if (part.def.type === 'time') {\r\n      // remove aggregations\r\n      this.selectParts = _.map(this.selectParts, (s: any) => {\r\n        return _.filter(s, (part: any) => {\r\n          if (part.def.type === 'aggregate' || part.def.type === 'percentile') {\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n    }\r\n\r\n    this.groupParts.splice(index, 1);\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  handleWherePartEvent(whereParts: any, part: any, evt: any, index: any) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        switch (evt.param.name) {\r\n          case 'left':\r\n            return this.datasource\r\n              .metricFindQuery(this.metaBuilder.buildColumnQuery())\r\n              .then(this.transformToSegments({}))\r\n              .catch(this.handleQueryError.bind(this));\r\n          case 'right':\r\n            if (['int', 'bigint', 'double', 'datetime'].indexOf(part.datatype) > -1) {\r\n              // don't do value lookups for numerical fields\r\n              return Promise.resolve([]);\r\n            } else {\r\n              return this.datasource\r\n                .metricFindQuery(this.metaBuilder.buildValueQuery(part.params[0]))\r\n                .then(\r\n                  this.transformToSegments({\r\n                    addTemplateVars: true,\r\n                    templateQuoter: (v: string) => {\r\n                      return this.queryModel.quoteLiteral(v);\r\n                    },\r\n                  })\r\n                )\r\n                .catch(this.handleQueryError.bind(this));\r\n            }\r\n          case 'op':\r\n            return Promise.resolve(this.uiSegmentSrv.newOperators(this.metaBuilder.getOperators(part.datatype)));\r\n          default:\r\n            return Promise.resolve([]);\r\n        }\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.datasource.metricFindQuery(this.metaBuilder.buildDatatypeQuery(part.params[0])).then((d: any) => {\r\n          if (d.length === 1) {\r\n            part.datatype = d[0].text;\r\n          }\r\n        });\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        // remove element\r\n        whereParts.splice(index, 1);\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  getWhereOptions() {\r\n    const options = [];\r\n    if (this.queryModel.hasUnixEpochTimecolumn()) {\r\n      options.push(this.uiSegmentSrv.newSegment({ type: 'macro', value: '$__unixEpochFilter' }));\r\n    } else {\r\n      options.push(this.uiSegmentSrv.newSegment({ type: 'macro', value: '$__timeFilter' }));\r\n    }\r\n    options.push(this.uiSegmentSrv.newSegment({ type: 'expression', value: 'Expression' }));\r\n    return Promise.resolve(options);\r\n  }\r\n\r\n  addWhereAction(part: any, index: number) {\r\n    switch (this.whereAdd.type) {\r\n      case 'macro': {\r\n        const partModel = sqlPart.create({ type: 'macro', name: this.whereAdd.value, params: [] });\r\n        if (this.whereParts.length >= 1 && this.whereParts[0].def.type === 'macro') {\r\n          // replace current macro\r\n          this.whereParts[0] = partModel;\r\n        } else {\r\n          this.whereParts.splice(0, 0, partModel);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        this.whereParts.push(sqlPart.create({ type: 'expression', params: ['value', '=', 'value'] }));\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n    this.resetPlusButton(this.whereAdd);\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  getGroupOptions() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('group'))\r\n      .then((tags: any) => {\r\n        const options = [];\r\n        if (!this.queryModel.hasTimeGroup()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ type: 'time', value: 'time($__interval,none)' }));\r\n        }\r\n        for (const tag of tags) {\r\n          options.push(this.uiSegmentSrv.newSegment({ type: 'column', value: tag.text }));\r\n        }\r\n        return options;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  addGroupAction() {\r\n    switch (this.groupAdd.value) {\r\n      default: {\r\n        this.addGroup(this.groupAdd.type, this.groupAdd.value);\r\n      }\r\n    }\r\n\r\n    this.resetPlusButton(this.groupAdd);\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  handleQueryError(err: any): any[] {\r\n    this.error = err.message || 'Failed to issue metric query';\r\n    return [];\r\n  }\r\n}\r\n","import _ from 'lodash';\r\n\r\nexport default class ResponseParser {\r\n  processQueryResult(res: any) {\r\n    const data: any[] = [];\r\n\r\n    if (!res.data.results) {\r\n      return { data: data };\r\n    }\r\n\r\n    for (const key in res.data.results) {\r\n      const queryRes = res.data.results[key];\r\n\r\n      if (queryRes.series) {\r\n        for (const series of queryRes.series) {\r\n          data.push({\r\n            target: series.name,\r\n            datapoints: series.points,\r\n            refId: queryRes.refId,\r\n            meta: queryRes.meta,\r\n          });\r\n        }\r\n      }\r\n\r\n      if (queryRes.tables) {\r\n        for (const table of queryRes.tables) {\r\n          table.type = 'table';\r\n          table.refId = queryRes.refId;\r\n          table.meta = queryRes.meta;\r\n          data.push(table);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { data: data };\r\n  }\r\n\r\n  parseMetricFindQueryResult(refId: string, results: any) {\r\n    if (!results || results.data.length === 0 || results.data.results[refId].meta.rowCount === 0) {\r\n      return [];\r\n    }\r\n\r\n    const columns = results.data.results[refId].tables[0].columns;\r\n    const rows = results.data.results[refId].tables[0].rows;\r\n    const textColIndex = this.findColIndex(columns, '__text');\r\n    const valueColIndex = this.findColIndex(columns, '__value');\r\n\r\n    if (columns.length === 2 && textColIndex !== -1 && valueColIndex !== -1) {\r\n      return this.transformToKeyValueList(rows, textColIndex, valueColIndex);\r\n    }\r\n\r\n    return this.transformToSimpleList(rows);\r\n  }\r\n\r\n  transformToKeyValueList(rows: any, textColIndex: number, valueColIndex: number) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      if (!this.containsKey(res, rows[i][textColIndex])) {\r\n        res.push({\r\n          text: rows[i][textColIndex],\r\n          value: rows[i][valueColIndex],\r\n        });\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  transformToSimpleList(rows: any) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      for (let j = 0; j < rows[i].length; j++) {\r\n        const value = rows[i][j];\r\n        if (res.indexOf(value) === -1) {\r\n          res.push(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return _.map(res, value => {\r\n      return { text: value };\r\n    });\r\n  }\r\n\r\n  findColIndex(columns: any[], colName: string) {\r\n    for (let i = 0; i < columns.length; i++) {\r\n      if (columns[i].text === colName) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  containsKey(res: any[], key: any) {\r\n    for (let i = 0; i < res.length; i++) {\r\n      if (res[i].text === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  transformAnnotationResponse(options: any, data: any) {\r\n    const table = data.data.results[options.annotation.name].tables[0];\r\n\r\n    let timeColumnIndex = -1;\r\n    let timeEndColumnIndex = -1;\r\n    let textColumnIndex = -1;\r\n    let tagsColumnIndex = -1;\r\n\r\n    for (let i = 0; i < table.columns.length; i++) {\r\n      if (table.columns[i].text === 'time_sec' || table.columns[i].text === 'time') {\r\n        timeColumnIndex = i;\r\n      } else if (table.columns[i].text === 'timeend') {\r\n        timeEndColumnIndex = i;\r\n      } else if (table.columns[i].text === 'title') {\r\n        return Promise.reject({\r\n          message: 'The title column for annotations is deprecated, now only a column named text is returned',\r\n        });\r\n      } else if (table.columns[i].text === 'text') {\r\n        textColumnIndex = i;\r\n      } else if (table.columns[i].text === 'tags') {\r\n        tagsColumnIndex = i;\r\n      }\r\n    }\r\n\r\n    if (timeColumnIndex === -1) {\r\n      return Promise.reject({\r\n        message: 'Missing mandatory time column (with time_sec column alias) in annotation query.',\r\n      });\r\n    }\r\n\r\n    const list = [];\r\n    for (let i = 0; i < table.rows.length; i++) {\r\n      const row = table.rows[i];\r\n      const timeEnd =\r\n        timeEndColumnIndex !== -1 && row[timeEndColumnIndex] ? Math.floor(row[timeEndColumnIndex]) : undefined;\r\n      list.push({\r\n        annotation: options.annotation,\r\n        time: Math.floor(row[timeColumnIndex]),\r\n        timeEnd,\r\n        text: row[textColumnIndex] ? row[textColumnIndex].toString() : '',\r\n        tags: row[tagsColumnIndex] ? row[tagsColumnIndex].trim().split(/\\s*,\\s*/) : [],\r\n      });\r\n    }\r\n\r\n    return list;\r\n  }\r\n}\r\n","import { SqlPartDef, SqlPart } from 'app/core/components/sql_part/sql_part';\n\nconst index: any[] = [];\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    return null;\n  }\n\n  return new SqlPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new SqlPartDef(options);\n}\n\nregister({\n  type: 'column',\n  style: 'label',\n  params: [{ type: 'column', dynamicLookup: true }],\n  defaultParams: ['value'],\n});\n\nregister({\n  type: 'expression',\n  style: 'expression',\n  label: 'Expr:',\n  params: [\n    { name: 'left', type: 'string', dynamicLookup: true },\n    { name: 'op', type: 'string', dynamicLookup: true },\n    { name: 'right', type: 'string', dynamicLookup: true },\n  ],\n  defaultParams: ['value', '=', 'value'],\n});\n\nregister({\n  type: 'macro',\n  style: 'label',\n  label: 'Macro:',\n  params: [],\n  defaultParams: [],\n});\n\nregister({\n  type: 'aggregate',\n  style: 'label',\n  params: [\n    {\n      name: 'name',\n      type: 'string',\n      options: ['avg', 'count', 'min', 'max', 'sum', 'stddev', 'variance'],\n    },\n  ],\n  defaultParams: ['avg'],\n});\n\nregister({\n  type: 'alias',\n  style: 'label',\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n});\n\nregister({\n  type: 'time',\n  style: 'function',\n  label: 'time',\n  params: [\n    {\n      name: 'interval',\n      type: 'interval',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'NULL', 'previous', '0'],\n    },\n  ],\n  defaultParams: ['$__interval', 'none'],\n});\n\nexport default {\n  create: createPart,\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAIA;AAAA;AACA;AACA;AACA;AAkBA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AAOA;AAEA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzBA;AACA;AACA;AACA;AACA;AACA;AAsBA;AAAA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC3NA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA0CA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AAMA;AACA;AACA;AACA;AARA;AASA;AAAA;AAEA;AAUA;AAKA;AACA;AACA;AACA;AAPA;AAQA;AAAA;AAEA;;;;;;;;;;;;;;;;;;ACzCA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAMA;AASA;AAAA;AAqBA;AACA;AAAA;AAGA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzmBA;AA0mBA;AAAA;AA3mBA;;;;;;;;;;;;;;;;;;ACzBA;AAEA;AAAA;AAqJA;AApJA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}