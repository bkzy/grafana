{"version":3,"file":"opentsdbPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/opentsdb/components/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/opentsdb/components/OpenTsdbDetails.tsx","webpack:///webpack:///./public/app/plugins/datasource/opentsdb/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/opentsdb/module.ts","webpack:///webpack:///./public/app/plugins/datasource/opentsdb/query_ctrl.ts"],"sourcesContent":["import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { OpenTsdbDetails } from './OpenTsdbDetails';\nimport { OpenTsdbOptions } from '../types';\n\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<OpenTsdbOptions>) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:4242\"\n        dataSourceConfig={options}\n        onChange={onOptionsChange}\n      />\n      <OpenTsdbDetails value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n","import React, { SyntheticEvent } from 'react';\r\nimport { FormLabel, Select, Input } from '@grafana/ui';\r\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\r\nimport { OpenTsdbOptions } from '../types';\r\n\r\nconst tsdbVersions = [\r\n  { label: '<=2.1', value: 1 },\r\n  { label: '==2.2', value: 2 },\r\n  { label: '==2.3', value: 3 },\r\n];\r\n\r\nconst tsdbResolutions = [\r\n  { label: 'second', value: 1 },\r\n  { label: 'millisecond', value: 2 },\r\n];\r\n\r\ninterface Props {\r\n  value: DataSourceSettings<OpenTsdbOptions>;\r\n  onChange: (value: DataSourceSettings<OpenTsdbOptions>) => void;\r\n}\r\n\r\nexport const OpenTsdbDetails = (props: Props) => {\r\n  const { onChange, value } = props;\r\n\r\n  return (\r\n    <>\r\n      <h5>OpenTSDB settings</h5>\r\n      <div className=\"gf-form\">\r\n        <FormLabel width={7}>Version</FormLabel>\r\n        <Select\r\n          options={tsdbVersions}\r\n          value={tsdbVersions.find(version => version.value === value.jsonData.tsdbVersion) ?? tsdbVersions[0]}\r\n          onChange={onSelectChangeHandler('tsdbVersion', value, onChange)}\r\n        />\r\n      </div>\r\n      <div className=\"gf-form\">\r\n        <FormLabel width={7}>Resolution</FormLabel>\r\n        <Select\r\n          options={tsdbResolutions}\r\n          value={\r\n            tsdbResolutions.find(resolution => resolution.value === value.jsonData.tsdbResolution) ?? tsdbResolutions[0]\r\n          }\r\n          onChange={onSelectChangeHandler('tsdbResolution', value, onChange)}\r\n        />\r\n      </div>\r\n      <div className=\"gf-form\">\r\n        <FormLabel width={7}>Lookup Limit</FormLabel>\r\n        <Input\r\n          type=\"number\"\r\n          value={value.jsonData.lookupLimit ?? 1000}\r\n          onChange={onInputChangeHandler('lookupLimit', value, onChange)}\r\n        />\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst onSelectChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\r\n  newValue: SelectableValue\r\n) => {\r\n  onChange({\r\n    ...value,\r\n    jsonData: {\r\n      ...value.jsonData,\r\n      [key]: newValue.value,\r\n    },\r\n  });\r\n};\r\n\r\nconst onInputChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  onChange({\r\n    ...value,\r\n    jsonData: {\r\n      ...value.jsonData,\r\n      [key]: event.currentTarget.value,\r\n    },\r\n  });\r\n};\r\n","import angular from 'angular';\r\nimport _ from 'lodash';\r\nimport { dateMath, DataQueryRequest, DataSourceApi } from '@grafana/data';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\r\n\r\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\r\n  type: any;\r\n  url: any;\r\n  name: any;\r\n  withCredentials: any;\r\n  basicAuth: any;\r\n  tsdbVersion: any;\r\n  tsdbResolution: any;\r\n  lookupLimit: any;\r\n  tagKeys: any;\r\n\r\n  aggregatorsPromise: any;\r\n  filterTypesPromise: any;\r\n\r\n  constructor(instanceSettings: any, private backendSrv: BackendSrv, private templateSrv: TemplateSrv) {\r\n    super(instanceSettings);\r\n\r\n    this.type = 'opentsdb';\r\n    this.url = instanceSettings.url;\r\n    this.name = instanceSettings.name;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    this.basicAuth = instanceSettings.basicAuth;\r\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\r\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\r\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\r\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\r\n    this.tagKeys = {};\r\n\r\n    this.aggregatorsPromise = null;\r\n    this.filterTypesPromise = null;\r\n  }\r\n\r\n  // Called once per panel (graph)\r\n  query(options: DataQueryRequest) {\r\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\r\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\r\n    const qs: any[] = [];\r\n\r\n    _.each(options.targets, target => {\r\n      if (!target.metric) {\r\n        return;\r\n      }\r\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\r\n    });\r\n\r\n    const queries = _.compact(qs);\r\n\r\n    // No valid targets, return the empty result to save a round trip.\r\n    if (_.isEmpty(queries)) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    const groupByTags: any = {};\r\n    _.each(queries, query => {\r\n      if (query.filters && query.filters.length > 0) {\r\n        _.each(query.filters, val => {\r\n          groupByTags[val.tagk] = true;\r\n        });\r\n      } else {\r\n        _.each(query.tags, (val, key) => {\r\n          groupByTags[key] = true;\r\n        });\r\n      }\r\n    });\r\n\r\n    options.targets = _.filter(options.targets, query => {\r\n      return query.hide !== true;\r\n    });\r\n\r\n    return this.performTimeSeriesQuery(queries, start, end).then((response: any) => {\r\n      const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\r\n      const result = _.map(response.data, (metricData: any, index: number) => {\r\n        index = metricToTargetMapping[index];\r\n        if (index === -1) {\r\n          index = 0;\r\n        }\r\n        this._saveTagKeys(metricData);\r\n\r\n        return this.transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);\r\n      });\r\n      return { data: result };\r\n    });\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\r\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\r\n    const qs = [];\r\n    const eventList: any[] = [];\r\n\r\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\r\n\r\n    const queries = _.compact(qs);\r\n\r\n    return this.performTimeSeriesQuery(queries, start, end).then((results: any) => {\r\n      if (results.data[0]) {\r\n        let annotationObject = results.data[0].annotations;\r\n        if (options.annotation.isGlobal) {\r\n          annotationObject = results.data[0].globalAnnotations;\r\n        }\r\n        if (annotationObject) {\r\n          _.each(annotationObject, annotation => {\r\n            const event = {\r\n              text: annotation.description,\r\n              time: Math.floor(annotation.startTime) * 1000,\r\n              annotation: options.annotation,\r\n            };\r\n\r\n            eventList.push(event);\r\n          });\r\n        }\r\n      }\r\n      return eventList;\r\n    });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    if (target.filters && target.filters.length > 0) {\r\n      for (let i = 0; i < target.filters.length; i++) {\r\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (target.tags && Object.keys(target.tags).length > 0) {\r\n      for (const tagKey in target.tags) {\r\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  performTimeSeriesQuery(queries: any[], start: any, end: any) {\r\n    let msResolution = false;\r\n    if (this.tsdbResolution === 2) {\r\n      msResolution = true;\r\n    }\r\n    const reqBody: any = {\r\n      start: start,\r\n      queries: queries,\r\n      msResolution: msResolution,\r\n      globalAnnotations: true,\r\n    };\r\n    if (this.tsdbVersion === 3) {\r\n      reqBody.showQuery = true;\r\n    }\r\n\r\n    // Relative queries (e.g. last hour) don't include an end time\r\n    if (end) {\r\n      reqBody.end = end;\r\n    }\r\n\r\n    const options = {\r\n      method: 'POST',\r\n      url: this.url + '/api/query',\r\n      data: reqBody,\r\n    };\r\n\r\n    this._addCredentialOptions(options);\r\n    return this.backendSrv.datasourceRequest(options);\r\n  }\r\n\r\n  suggestTagKeys(metric: string | number) {\r\n    return Promise.resolve(this.tagKeys[metric] || []);\r\n  }\r\n\r\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\r\n    const tagKeys = Object.keys(metricData.tags);\r\n    _.each(metricData.aggregateTags, tag => {\r\n      tagKeys.push(tag);\r\n    });\r\n\r\n    this.tagKeys[metricData.metric] = tagKeys;\r\n  }\r\n\r\n  _performSuggestQuery(query: string, type: string) {\r\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).then((result: any) => {\r\n      return result.data;\r\n    });\r\n  }\r\n\r\n  _performMetricKeyValueLookup(metric: string, keys: any) {\r\n    if (!metric || !keys) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    const keysArray = keys.split(',').map((key: any) => {\r\n      return key.trim();\r\n    });\r\n    const key = keysArray[0];\r\n    let keysQuery = key + '=*';\r\n\r\n    if (keysArray.length > 1) {\r\n      keysQuery += ',' + keysArray.splice(1).join(',');\r\n    }\r\n\r\n    const m = metric + '{' + keysQuery + '}';\r\n\r\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).then((result: any) => {\r\n      result = result.data.results;\r\n      const tagvs: any[] = [];\r\n      _.each(result, r => {\r\n        if (tagvs.indexOf(r.tags[key]) === -1) {\r\n          tagvs.push(r.tags[key]);\r\n        }\r\n      });\r\n      return tagvs;\r\n    });\r\n  }\r\n\r\n  _performMetricKeyLookup(metric: any) {\r\n    if (!metric) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).then((result: any) => {\r\n      result = result.data.results;\r\n      const tagks: any[] = [];\r\n      _.each(result, r => {\r\n        _.each(r.tags, (tagv, tagk) => {\r\n          if (tagks.indexOf(tagk) === -1) {\r\n            tagks.push(tagk);\r\n          }\r\n        });\r\n      });\r\n      return tagks;\r\n    });\r\n  }\r\n\r\n  _get(relativeUrl: string, params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }) {\r\n    const options = {\r\n      method: 'GET',\r\n      url: this.url + relativeUrl,\r\n      params: params,\r\n    };\r\n\r\n    this._addCredentialOptions(options);\r\n\r\n    return this.backendSrv.datasourceRequest(options);\r\n  }\r\n\r\n  _addCredentialOptions(options: any) {\r\n    if (this.basicAuth || this.withCredentials) {\r\n      options.withCredentials = true;\r\n    }\r\n    if (this.basicAuth) {\r\n      options.headers = { Authorization: this.basicAuth };\r\n    }\r\n  }\r\n\r\n  metricFindQuery(query: string) {\r\n    if (!query) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    let interpolated;\r\n    try {\r\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\r\n    } catch (err) {\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    const responseTransform = (result: any) => {\r\n      return _.map(result, value => {\r\n        return { text: value };\r\n      });\r\n    };\r\n\r\n    const metricsRegex = /metrics\\((.*)\\)/;\r\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\r\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\r\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\r\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\r\n\r\n    const metricsQuery = interpolated.match(metricsRegex);\r\n    if (metricsQuery) {\r\n      return this._performSuggestQuery(metricsQuery[1], 'metrics').then(responseTransform);\r\n    }\r\n\r\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\r\n    if (tagNamesQuery) {\r\n      return this._performMetricKeyLookup(tagNamesQuery[1]).then(responseTransform);\r\n    }\r\n\r\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\r\n    if (tagValuesQuery) {\r\n      return this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).then(responseTransform);\r\n    }\r\n\r\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\r\n    if (tagNamesSuggestQuery) {\r\n      return this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').then(responseTransform);\r\n    }\r\n\r\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\r\n    if (tagValuesSuggestQuery) {\r\n      return this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').then(responseTransform);\r\n    }\r\n\r\n    return Promise.resolve([]);\r\n  }\r\n\r\n  testDatasource() {\r\n    return this._performSuggestQuery('cpu', 'metrics').then(() => {\r\n      return { status: 'success', message: 'Data source is working' };\r\n    });\r\n  }\r\n\r\n  getAggregators() {\r\n    if (this.aggregatorsPromise) {\r\n      return this.aggregatorsPromise;\r\n    }\r\n\r\n    this.aggregatorsPromise = this._get('/api/aggregators').then((result: any) => {\r\n      if (result.data && _.isArray(result.data)) {\r\n        return result.data.sort();\r\n      }\r\n      return [];\r\n    });\r\n    return this.aggregatorsPromise;\r\n  }\r\n\r\n  getFilterTypes() {\r\n    if (this.filterTypesPromise) {\r\n      return this.filterTypesPromise;\r\n    }\r\n\r\n    this.filterTypesPromise = this._get('/api/config/filters').then((result: any) => {\r\n      if (result.data) {\r\n        return Object.keys(result.data).sort();\r\n      }\r\n      return [];\r\n    });\r\n    return this.filterTypesPromise;\r\n  }\r\n\r\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\r\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\r\n    const dps: any[] = [];\r\n\r\n    // TSDB returns datapoints has a hash of ts => value.\r\n    // Can't use _.pairs(invert()) because it stringifies keys/values\r\n    _.each(md.dps, (v: any, k: number) => {\r\n      if (tsdbResolution === 2) {\r\n        dps.push([v, k * 1]);\r\n      } else {\r\n        dps.push([v, k * 1000]);\r\n      }\r\n    });\r\n\r\n    return { target: metricLabel, datapoints: dps };\r\n  }\r\n\r\n  createMetricLabel(\r\n    md: { dps?: any; tags?: any; metric?: any },\r\n    target: { alias: string },\r\n    groupByTags: any,\r\n    options: { scopedVars: any }\r\n  ) {\r\n    if (target.alias) {\r\n      const scopedVars = _.clone(options.scopedVars || {});\r\n      _.each(md.tags, (value, key) => {\r\n        scopedVars['tag_' + key] = { value: value };\r\n      });\r\n      return this.templateSrv.replace(target.alias, scopedVars);\r\n    }\r\n\r\n    let label = md.metric;\r\n    const tagData: any[] = [];\r\n\r\n    if (!_.isEmpty(md.tags)) {\r\n      _.each(_.toPairs(md.tags), tag => {\r\n        if (_.has(groupByTags, tag[0])) {\r\n          tagData.push(tag[0] + '=' + tag[1]);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!_.isEmpty(tagData)) {\r\n      label += '{' + tagData.join(', ') + '}';\r\n    }\r\n\r\n    return label;\r\n  }\r\n\r\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\r\n    if (!target.metric || target.hide) {\r\n      return null;\r\n    }\r\n\r\n    const query: any = {\r\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\r\n      aggregator: 'avg',\r\n    };\r\n\r\n    if (target.aggregator) {\r\n      query.aggregator = this.templateSrv.replace(target.aggregator);\r\n    }\r\n\r\n    if (target.shouldComputeRate) {\r\n      query.rate = true;\r\n      query.rateOptions = {\r\n        counter: !!target.isCounter,\r\n      };\r\n\r\n      if (target.counterMax && target.counterMax.length) {\r\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\r\n      }\r\n\r\n      if (target.counterResetValue && target.counterResetValue.length) {\r\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\r\n      }\r\n\r\n      if (tsdbVersion >= 2) {\r\n        query.rateOptions.dropResets =\r\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\r\n      }\r\n    }\r\n\r\n    if (!target.disableDownsampling) {\r\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\r\n\r\n      if (interval.match(/\\.[0-9]+s/)) {\r\n        interval = parseFloat(interval) * 1000 + 'ms';\r\n      }\r\n\r\n      query.downsample = interval + '-' + target.downsampleAggregator;\r\n\r\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\r\n        query.downsample += '-' + target.downsampleFillPolicy;\r\n      }\r\n    }\r\n\r\n    if (target.filters && target.filters.length > 0) {\r\n      query.filters = angular.copy(target.filters);\r\n      if (query.filters) {\r\n        for (const filterKey in query.filters) {\r\n          query.filters[filterKey].filter = this.templateSrv.replace(\r\n            query.filters[filterKey].filter,\r\n            options.scopedVars,\r\n            'pipe'\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      query.tags = angular.copy(target.tags);\r\n      if (query.tags) {\r\n        for (const tagKey in query.tags) {\r\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\r\n        }\r\n      }\r\n    }\r\n\r\n    if (target.explicitTags) {\r\n      query.explicitTags = true;\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\r\n    let interpolatedTagValue, arrTagV;\r\n    return _.map(metrics, metricData => {\r\n      if (tsdbVersion === 3) {\r\n        return metricData.query.index;\r\n      } else {\r\n        return _.findIndex(options.targets as any[], target => {\r\n          if (target.filters && target.filters.length > 0) {\r\n            return target.metric === metricData.metric;\r\n          } else {\r\n            return (\r\n              target.metric === metricData.metric &&\r\n              _.every(target.tags, (tagV, tagK) => {\r\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\r\n                arrTagV = interpolatedTagValue.split('|');\r\n                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\r\n              })\r\n            );\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\r\n    if (date === 'now') {\r\n      return null;\r\n    }\r\n\r\n    date = dateMath.parse(date, roundUp, timezone);\r\n    return date.valueOf();\r\n  }\r\n}\r\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './components/ConfigEditor';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(OpenTsDatasource)\n  .setQueryCtrl(OpenTsQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n","import _ from 'lodash';\r\nimport kbn from 'app/core/utils/kbn';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { auto } from 'angular';\r\n\r\nexport class OpenTsQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n  aggregators: any;\r\n  fillPolicies: any;\r\n  filterTypes: any;\r\n  tsdbVersion: any;\r\n  aggregator: any;\r\n  downsampleInterval: any;\r\n  downsampleAggregator: any;\r\n  downsampleFillPolicy: any;\r\n  errors: any;\r\n  suggestMetrics: any;\r\n  suggestTagKeys: any;\r\n  suggestTagValues: any;\r\n  addTagMode: boolean;\r\n  addFilterMode: boolean;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any, $injector: auto.IInjectorService) {\r\n    super($scope, $injector);\r\n\r\n    this.errors = this.validateTarget();\r\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\r\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\r\n    this.filterTypes = [\r\n      'wildcard',\r\n      'iliteral_or',\r\n      'not_iliteral_or',\r\n      'not_literal_or',\r\n      'iwildcard',\r\n      'literal_or',\r\n      'regexp',\r\n    ];\r\n\r\n    this.tsdbVersion = this.datasource.tsdbVersion;\r\n\r\n    if (!this.target.aggregator) {\r\n      this.target.aggregator = 'sum';\r\n    }\r\n\r\n    if (!this.target.downsampleAggregator) {\r\n      this.target.downsampleAggregator = 'avg';\r\n    }\r\n\r\n    if (!this.target.downsampleFillPolicy) {\r\n      this.target.downsampleFillPolicy = 'none';\r\n    }\r\n\r\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\r\n      if (aggs.length !== 0) {\r\n        this.aggregators = aggs;\r\n      }\r\n    });\r\n\r\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\r\n      if (filterTypes.length !== 0) {\r\n        this.filterTypes = filterTypes;\r\n      }\r\n    });\r\n\r\n    // needs to be defined here as it is called from typeahead\r\n    this.suggestMetrics = (query: string, callback: any) => {\r\n      this.datasource\r\n        .metricFindQuery('metrics(' + query + ')')\r\n        .then(this.getTextValues)\r\n        .then(callback);\r\n    };\r\n\r\n    this.suggestTagKeys = (query: any, callback: any) => {\r\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\r\n    };\r\n\r\n    this.suggestTagValues = (query: string, callback: any) => {\r\n      this.datasource\r\n        .metricFindQuery('suggest_tagv(' + query + ')')\r\n        .then(this.getTextValues)\r\n        .then(callback);\r\n    };\r\n  }\r\n\r\n  targetBlur() {\r\n    this.errors = this.validateTarget();\r\n    this.refresh();\r\n  }\r\n\r\n  getTextValues(metricFindResult: any) {\r\n    return _.map(metricFindResult, value => {\r\n      return value.text;\r\n    });\r\n  }\r\n\r\n  addTag() {\r\n    if (this.target.filters && this.target.filters.length > 0) {\r\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\r\n    }\r\n\r\n    if (!this.addTagMode) {\r\n      this.addTagMode = true;\r\n      return;\r\n    }\r\n\r\n    if (!this.target.tags) {\r\n      this.target.tags = {};\r\n    }\r\n\r\n    this.errors = this.validateTarget();\r\n\r\n    if (!this.errors.tags) {\r\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\r\n      this.target.currentTagKey = '';\r\n      this.target.currentTagValue = '';\r\n      this.targetBlur();\r\n    }\r\n\r\n    this.addTagMode = false;\r\n  }\r\n\r\n  removeTag(key: string | number) {\r\n    delete this.target.tags[key];\r\n    this.targetBlur();\r\n  }\r\n\r\n  editTag(key: string | number, value: any) {\r\n    this.removeTag(key);\r\n    this.target.currentTagKey = key;\r\n    this.target.currentTagValue = value;\r\n    this.addTag();\r\n  }\r\n\r\n  closeAddTagMode() {\r\n    this.addTagMode = false;\r\n    return;\r\n  }\r\n\r\n  addFilter() {\r\n    if (this.target.tags && _.size(this.target.tags) > 0) {\r\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\r\n    }\r\n\r\n    if (!this.addFilterMode) {\r\n      this.addFilterMode = true;\r\n      return;\r\n    }\r\n\r\n    if (!this.target.filters) {\r\n      this.target.filters = [];\r\n    }\r\n\r\n    if (!this.target.currentFilterType) {\r\n      this.target.currentFilterType = 'iliteral_or';\r\n    }\r\n\r\n    if (!this.target.currentFilterGroupBy) {\r\n      this.target.currentFilterGroupBy = false;\r\n    }\r\n\r\n    this.errors = this.validateTarget();\r\n\r\n    if (!this.errors.filters) {\r\n      const currentFilter = {\r\n        type: this.target.currentFilterType,\r\n        tagk: this.target.currentFilterKey,\r\n        filter: this.target.currentFilterValue,\r\n        groupBy: this.target.currentFilterGroupBy,\r\n      };\r\n      this.target.filters.push(currentFilter);\r\n      this.target.currentFilterType = 'literal_or';\r\n      this.target.currentFilterKey = '';\r\n      this.target.currentFilterValue = '';\r\n      this.target.currentFilterGroupBy = false;\r\n      this.targetBlur();\r\n    }\r\n\r\n    this.addFilterMode = false;\r\n  }\r\n\r\n  removeFilter(index: number) {\r\n    this.target.filters.splice(index, 1);\r\n    this.targetBlur();\r\n  }\r\n\r\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\r\n    this.removeFilter(index);\r\n    this.target.currentFilterKey = fil.tagk;\r\n    this.target.currentFilterValue = fil.filter;\r\n    this.target.currentFilterType = fil.type;\r\n    this.target.currentFilterGroupBy = fil.groupBy;\r\n    this.addFilter();\r\n  }\r\n\r\n  closeAddFilterMode() {\r\n    this.addFilterMode = false;\r\n    return;\r\n  }\r\n\r\n  validateTarget() {\r\n    const errs: any = {};\r\n\r\n    if (this.target.shouldDownsample) {\r\n      try {\r\n        if (this.target.downsampleInterval) {\r\n          kbn.describe_interval(this.target.downsampleInterval);\r\n        } else {\r\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\r\n        }\r\n      } catch (err) {\r\n        errs.downsampleInterval = err.message;\r\n      }\r\n    }\r\n\r\n    if (this.target.tags && _.has(this.target.tags, this.target.currentTagKey)) {\r\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\r\n    }\r\n\r\n    return errs;\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AAKA;AAGA;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAQA;AACA;AACA;AAQA;AAEA;;AAGA;AAOA;AAEA;;AAGA;AAOA;;;;;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AAKA;AAAA;AAcA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACvfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AAGA;AAAA;AAiBA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAtNA;AAuNA;AAAA;AAxNA;;;;;A","sourceRoot":""}