{"version":3,"file":"postgresPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/core/components/sql_part/sql_part.ts","webpack:///webpack:///./public/app/features/datasources/utils/passwordHandlers.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/config_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/meta_query.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/module.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/postgres_query.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/response_parser.ts","webpack:///webpack:///./public/app/plugins/datasource/postgres/sql_part.ts"],"sourcesContent":["import _ from 'lodash';\r\n\r\nexport class SqlPartDef {\r\n  type: string;\r\n  style: string;\r\n  label: string;\r\n  params: any[];\r\n  defaultParams: any[];\r\n  wrapOpen: string;\r\n  wrapClose: string;\r\n  separator: string;\r\n\r\n  constructor(options: any) {\r\n    this.type = options.type;\r\n    if (options.label) {\r\n      this.label = options.label;\r\n    } else {\r\n      this.label = this.type[0].toUpperCase() + this.type.substring(1) + ':';\r\n    }\r\n    this.style = options.style;\r\n    if (this.style === 'function') {\r\n      this.wrapOpen = '(';\r\n      this.wrapClose = ')';\r\n      this.separator = ', ';\r\n    } else {\r\n      this.wrapOpen = ' ';\r\n      this.wrapClose = ' ';\r\n      this.separator = ' ';\r\n    }\r\n    this.params = options.params;\r\n    this.defaultParams = options.defaultParams;\r\n  }\r\n}\r\n\r\nexport class SqlPart {\r\n  part: any;\r\n  def: SqlPartDef;\r\n  params: any[];\r\n  label: string;\r\n  name: string;\r\n  datatype: string;\r\n\r\n  constructor(part: any, def: any) {\r\n    this.part = part;\r\n    this.def = def;\r\n    if (!this.def) {\r\n      throw { message: 'Could not find sql part ' + part.type };\r\n    }\r\n\r\n    this.datatype = part.datatype;\r\n\r\n    if (part.name) {\r\n      this.name = part.name;\r\n      this.label = def.label + ' ' + part.name;\r\n    } else {\r\n      this.name = '';\r\n      this.label = def.label;\r\n    }\r\n\r\n    part.params = part.params || _.clone(this.def.defaultParams);\r\n    this.params = part.params;\r\n  }\r\n\r\n  updateParam(strValue: string, index: number) {\r\n    // handle optional parameters\r\n    if (strValue === '' && this.def.params[index].optional) {\r\n      this.params.splice(index, 1);\r\n    } else {\r\n      this.params[index] = strValue;\r\n    }\r\n\r\n    this.part.params = this.params;\r\n  }\r\n}\r\n","/**\r\n * Set of handlers for secure password field in Angular components. They handle backward compatibility with\r\n * passwords stored in plain text fields.\r\n */\r\n\r\nimport { SyntheticEvent } from 'react';\r\n\r\nexport enum PasswordFieldEnum {\r\n  Password = 'password',\r\n  BasicAuthPassword = 'basicAuthPassword',\r\n}\r\n\r\n/**\r\n * Basic shape for settings controllers in at the moment mostly angular datasource plugins.\r\n */\r\nexport type Ctrl = {\r\n  current: {\r\n    secureJsonFields: {\r\n      [key: string]: boolean;\r\n    };\r\n    secureJsonData?: {\r\n      [key: string]: string;\r\n    };\r\n    password?: string;\r\n    basicAuthPassword?: string;\r\n  };\r\n};\r\n\r\nexport const createResetHandler = (ctrl: Ctrl, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  event.preventDefault();\r\n  // Reset also normal plain text password to remove it and only save it in secureJsonData.\r\n  ctrl.current[field] = null;\r\n  ctrl.current.secureJsonFields[field] = false;\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = '';\r\n};\r\n\r\nexport const createChangeHandler = (ctrl: any, field: PasswordFieldEnum) => (\r\n  event: SyntheticEvent<HTMLInputElement>\r\n) => {\r\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\r\n  ctrl.current.secureJsonData[field] = event.currentTarget.value;\r\n};\r\n","import _ from 'lodash';\r\nimport {\r\n  createChangeHandler,\r\n  createResetHandler,\r\n  PasswordFieldEnum,\r\n} from '../../../features/datasources/utils/passwordHandlers';\r\nimport DatasourceSrv from 'app/features/plugins/datasource_srv';\r\n\r\nexport class PostgresConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n\r\n  current: any;\r\n  datasourceSrv: any;\r\n  showTimescaleDBHelp: boolean;\r\n  onPasswordReset: ReturnType<typeof createResetHandler>;\r\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any, datasourceSrv: DatasourceSrv) {\r\n    this.datasourceSrv = datasourceSrv;\r\n    this.current.jsonData.sslmode = this.current.jsonData.sslmode || 'verify-full';\r\n    this.current.jsonData.postgresVersion = this.current.jsonData.postgresVersion || 903;\r\n    this.showTimescaleDBHelp = false;\r\n    this.autoDetectFeatures();\r\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\r\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\r\n  }\r\n\r\n  autoDetectFeatures() {\r\n    if (!this.current.id) {\r\n      return;\r\n    }\r\n\r\n    this.datasourceSrv.loadDatasource(this.current.name).then((ds: any) => {\r\n      return ds.getVersion().then((version: any) => {\r\n        version = Number(version[0].text);\r\n\r\n        // timescaledb is only available for 9.6+\r\n        if (version >= 906) {\r\n          ds.getTimescaleDBVersion().then((version: any) => {\r\n            if (version.length === 1) {\r\n              this.current.jsonData.timescaledb = true;\r\n            }\r\n          });\r\n        }\r\n\r\n        const major = Math.trunc(version / 100);\r\n        const minor = version % 100;\r\n        let name = String(major);\r\n        if (version < 1000) {\r\n          name = String(major) + '.' + String(minor);\r\n        }\r\n        if (!_.find(this.postgresVersions, (p: any) => p.value === version)) {\r\n          this.postgresVersions.push({ name: name, value: version });\r\n        }\r\n        this.current.jsonData.postgresVersion = version;\r\n      });\r\n    });\r\n  }\r\n\r\n  toggleTimescaleDBHelp() {\r\n    this.showTimescaleDBHelp = !this.showTimescaleDBHelp;\r\n  }\r\n\r\n  // the value portion is derived from postgres server_version_num/100\r\n  postgresVersions = [\r\n    { name: '9.3', value: 903 },\r\n    { name: '9.4', value: 904 },\r\n    { name: '9.5', value: 905 },\r\n    { name: '9.6', value: 906 },\r\n    { name: '10', value: 1000 },\r\n  ];\r\n}\r\n","import _ from 'lodash';\r\nimport ResponseParser from './response_parser';\r\nimport PostgresQuery from 'app/plugins/datasource/postgres/postgres_query';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\n//Types\r\nimport { PostgresQueryForInterpolation } from './types';\r\nimport { getSearchFilterScopedVar } from '../../../features/templating/variable';\r\n\r\nexport class PostgresDatasource {\r\n  id: any;\r\n  name: any;\r\n  jsonData: any;\r\n  responseParser: ResponseParser;\r\n  queryModel: PostgresQuery;\r\n  interval: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: { name: any; id?: any; jsonData?: any },\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv,\r\n    private timeSrv: TimeSrv\r\n  ) {\r\n    this.name = instanceSettings.name;\r\n    this.id = instanceSettings.id;\r\n    this.jsonData = instanceSettings.jsonData;\r\n    this.responseParser = new ResponseParser();\r\n    this.queryModel = new PostgresQuery({});\r\n    this.interval = (instanceSettings.jsonData || {}).timeInterval || '1m';\r\n  }\r\n\r\n  interpolateVariable = (value: string, variable: { multi: any; includeAll: any }) => {\r\n    if (typeof value === 'string') {\r\n      if (variable.multi || variable.includeAll) {\r\n        return this.queryModel.quoteLiteral(value);\r\n      } else {\r\n        return value;\r\n      }\r\n    }\r\n\r\n    if (typeof value === 'number') {\r\n      return value;\r\n    }\r\n\r\n    const quotedValues = _.map(value, v => {\r\n      return this.queryModel.quoteLiteral(v);\r\n    });\r\n    return quotedValues.join(',');\r\n  };\r\n\r\n  interpolateVariablesInQueries(\r\n    queries: PostgresQueryForInterpolation[],\r\n    scopedVars: ScopedVars\r\n  ): PostgresQueryForInterpolation[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length > 0) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          rawSql: this.templateSrv.replace(query.rawSql, scopedVars, this.interpolateVariable),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  query(options: any) {\r\n    const queries = _.filter(options.targets, target => {\r\n      return target.hide !== true;\r\n    }).map(target => {\r\n      const queryModel = new PostgresQuery(target, this.templateSrv, options.scopedVars);\r\n\r\n      return {\r\n        refId: target.refId,\r\n        intervalMs: options.intervalMs,\r\n        maxDataPoints: options.maxDataPoints,\r\n        datasourceId: this.id,\r\n        rawSql: queryModel.render(this.interpolateVariable),\r\n        format: target.format,\r\n      };\r\n    });\r\n\r\n    if (queries.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: queries,\r\n        },\r\n      })\r\n      .then(this.responseParser.processQueryResult);\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    if (!options.annotation.rawQuery) {\r\n      return Promise.reject({\r\n        message: 'Query missing in annotation definition',\r\n      });\r\n    }\r\n\r\n    const query = {\r\n      refId: options.annotation.name,\r\n      datasourceId: this.id,\r\n      rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),\r\n      format: 'table',\r\n    };\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries: [query],\r\n        },\r\n      })\r\n      .then((data: any) => this.responseParser.transformAnnotationResponse(options, data));\r\n  }\r\n\r\n  metricFindQuery(query: string, optionalOptions: { variable?: any; searchFilter?: string }) {\r\n    let refId = 'tempvar';\r\n    if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {\r\n      refId = optionalOptions.variable.name;\r\n    }\r\n\r\n    const rawSql = this.templateSrv.replace(\r\n      query,\r\n      getSearchFilterScopedVar({ query, wildcardChar: '%', options: optionalOptions }),\r\n      this.interpolateVariable\r\n    );\r\n\r\n    const interpolatedQuery = {\r\n      refId: refId,\r\n      datasourceId: this.id,\r\n      rawSql,\r\n      format: 'table',\r\n    };\r\n\r\n    const range = this.timeSrv.timeRange();\r\n    const data = {\r\n      queries: [interpolatedQuery],\r\n      from: range.from.valueOf().toString(),\r\n      to: range.to.valueOf().toString(),\r\n    };\r\n\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: data,\r\n      })\r\n      .then((data: any) => this.responseParser.parseMetricFindQueryResult(refId, data));\r\n  }\r\n\r\n  getVersion() {\r\n    return this.metricFindQuery(\"SELECT current_setting('server_version_num')::int/100\", {});\r\n  }\r\n\r\n  getTimescaleDBVersion() {\r\n    return this.metricFindQuery(\"SELECT extversion FROM pg_extension WHERE extname = 'timescaledb'\", {});\r\n  }\r\n\r\n  testDatasource() {\r\n    return this.metricFindQuery('SELECT 1', {})\r\n      .then((res: any) => {\r\n        return { status: 'success', message: 'Database Connection OK' };\r\n      })\r\n      .catch((err: any) => {\r\n        console.log(err);\r\n        if (err.data && err.data.message) {\r\n          return { status: 'error', message: err.data.message };\r\n        } else {\r\n          return { status: 'error', message: err.status };\r\n        }\r\n      });\r\n  }\r\n\r\n  targetContainsTemplate(target: any) {\r\n    let rawSql = '';\r\n\r\n    if (target.rawQuery) {\r\n      rawSql = target.rawSql;\r\n    } else {\r\n      const query = new PostgresQuery(target);\r\n      rawSql = query.buildQuery();\r\n    }\r\n\r\n    rawSql = rawSql.replace('$__', '');\r\n\r\n    return this.templateSrv.variableExists(rawSql);\r\n  }\r\n}\r\n","import QueryModel from './postgres_query';\r\n\r\nexport class PostgresMetaQuery {\r\n  constructor(private target: { table: string; timeColumn: string }, private queryModel: QueryModel) {}\r\n\r\n  getOperators(datatype: string) {\r\n    switch (datatype) {\r\n      case 'float4':\r\n      case 'float8': {\r\n        return ['=', '!=', '<', '<=', '>', '>='];\r\n      }\r\n      case 'text':\r\n      case 'varchar':\r\n      case 'char': {\r\n        return ['=', '!=', '<', '<=', '>', '>=', 'IN', 'NOT IN', 'LIKE', 'NOT LIKE', '~', '~*', '!~', '!~*'];\r\n      }\r\n      default: {\r\n        return ['=', '!=', '<', '<=', '>', '>=', 'IN', 'NOT IN'];\r\n      }\r\n    }\r\n  }\r\n\r\n  // quote identifier as literal to use in metadata queries\r\n  quoteIdentAsLiteral(value: string) {\r\n    return this.queryModel.quoteLiteral(this.queryModel.unquoteIdentifier(value));\r\n  }\r\n\r\n  findMetricTable() {\r\n    // query that returns first table found that has a timestamp(tz) column and a float column\r\n    let query = `\r\nSELECT\r\n\tquote_ident(table_name) as table_name,\r\n\t( SELECT\r\n\t    quote_ident(column_name) as column_name\r\n\t  FROM information_schema.columns c\r\n    WHERE\r\n      c.table_schema = t.table_schema AND\r\n      c.table_name = t.table_name AND\r\n      udt_name IN ('timestamptz','timestamp')\r\n    ORDER BY ordinal_position LIMIT 1\r\n  ) AS time_column,\r\n  ( SELECT\r\n      quote_ident(column_name) AS column_name\r\n    FROM information_schema.columns c\r\n    WHERE\r\n      c.table_schema = t.table_schema AND\r\n      c.table_name = t.table_name AND\r\n      udt_name='float8'\r\n    ORDER BY ordinal_position LIMIT 1\r\n  ) AS value_column\r\nFROM information_schema.tables t\r\nWHERE `;\r\n    query += this.buildSchemaConstraint();\r\n    query += ` AND\r\n  EXISTS\r\n  ( SELECT 1\r\n    FROM information_schema.columns c\r\n    WHERE\r\n      c.table_schema = t.table_schema AND\r\n      c.table_name = t.table_name AND\r\n      udt_name IN ('timestamptz','timestamp')\r\n  ) AND\r\n  EXISTS\r\n  ( SELECT 1\r\n    FROM information_schema.columns c\r\n    WHERE\r\n      c.table_schema = t.table_schema AND\r\n      c.table_name = t.table_name AND\r\n      udt_name='float8'\r\n  )\r\nLIMIT 1\r\n;`;\r\n    return query;\r\n  }\r\n\r\n  buildSchemaConstraint() {\r\n    const query = `\r\ntable_schema IN (\r\n  SELECT\r\n    CASE WHEN trim(s[i]) = '\"$user\"' THEN user ELSE trim(s[i]) END\r\n  FROM\r\n    generate_series(\r\n      array_lower(string_to_array(current_setting('search_path'),','),1),\r\n      array_upper(string_to_array(current_setting('search_path'),','),1)\r\n    ) as i,\r\n    string_to_array(current_setting('search_path'),',') s\r\n)`;\r\n    return query;\r\n  }\r\n\r\n  buildTableConstraint(table: string) {\r\n    let query = '';\r\n\r\n    // check for schema qualified table\r\n    if (table.includes('.')) {\r\n      const parts = table.split('.');\r\n      query = 'table_schema = ' + this.quoteIdentAsLiteral(parts[0]);\r\n      query += ' AND table_name = ' + this.quoteIdentAsLiteral(parts[1]);\r\n      return query;\r\n    } else {\r\n      query = this.buildSchemaConstraint();\r\n      query += ' AND table_name = ' + this.quoteIdentAsLiteral(table);\r\n\r\n      return query;\r\n    }\r\n  }\r\n\r\n  buildTableQuery() {\r\n    let query = 'SELECT quote_ident(table_name) FROM information_schema.tables WHERE ';\r\n    query += this.buildSchemaConstraint();\r\n    query += ' ORDER BY table_name';\r\n    return query;\r\n  }\r\n\r\n  buildColumnQuery(type?: string) {\r\n    let query = 'SELECT quote_ident(column_name) FROM information_schema.columns WHERE ';\r\n    query += this.buildTableConstraint(this.target.table);\r\n\r\n    switch (type) {\r\n      case 'time': {\r\n        query +=\r\n          \" AND data_type IN ('timestamp without time zone','timestamp with time zone','bigint','integer','double precision','real')\";\r\n        break;\r\n      }\r\n      case 'metric': {\r\n        query += \" AND data_type IN ('text','character','character varying')\";\r\n        break;\r\n      }\r\n      case 'value': {\r\n        query += \" AND data_type IN ('bigint','integer','double precision','real')\";\r\n        query += ' AND column_name <> ' + this.quoteIdentAsLiteral(this.target.timeColumn);\r\n        break;\r\n      }\r\n      case 'group': {\r\n        query += \" AND data_type IN ('text','character','character varying')\";\r\n        break;\r\n      }\r\n    }\r\n\r\n    query += ' ORDER BY column_name';\r\n\r\n    return query;\r\n  }\r\n\r\n  buildValueQuery(column: string) {\r\n    let query = 'SELECT DISTINCT quote_literal(' + column + ')';\r\n    query += ' FROM ' + this.target.table;\r\n    query += ' WHERE $__timeFilter(' + this.target.timeColumn + ')';\r\n    query += ' AND ' + column + ' IS NOT NULL';\r\n    query += ' ORDER BY 1 LIMIT 100';\r\n    return query;\r\n  }\r\n\r\n  buildDatatypeQuery(column: string) {\r\n    let query = 'SELECT udt_name FROM information_schema.columns WHERE ';\r\n    query += this.buildTableConstraint(this.target.table);\r\n    query += ' AND column_name = ' + this.quoteIdentAsLiteral(column);\r\n    return query;\r\n  }\r\n\r\n  buildAggregateQuery() {\r\n    let query = 'SELECT DISTINCT proname FROM pg_aggregate ';\r\n    query += 'INNER JOIN pg_proc ON pg_aggregate.aggfnoid = pg_proc.oid ';\r\n    query += 'INNER JOIN pg_type ON pg_type.oid=pg_proc.prorettype ';\r\n    query += \"WHERE pronargs=1 AND typname IN ('float8') AND aggkind='n' ORDER BY 1\";\r\n    return query;\r\n  }\r\n}\r\n","import { PostgresDatasource } from './datasource';\r\nimport { PostgresQueryCtrl } from './query_ctrl';\r\nimport { PostgresConfigCtrl } from './config_ctrl';\r\n\r\nconst defaultQuery = `SELECT\r\n  extract(epoch from time_column) AS time,\r\n  text_column as text,\r\n  tags_column as tags\r\nFROM\r\n  metric_table\r\nWHERE\r\n  $__timeFilter(time_column)\r\n`;\r\n\r\nclass PostgresAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n\r\n  annotation: any;\r\n\r\n  /** @ngInject */\r\n  constructor() {\r\n    this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;\r\n  }\r\n}\r\n\r\nexport {\r\n  PostgresDatasource,\r\n  PostgresDatasource as Datasource,\r\n  PostgresQueryCtrl as QueryCtrl,\r\n  PostgresConfigCtrl as ConfigCtrl,\r\n  PostgresAnnotationsQueryCtrl as AnnotationsQueryCtrl,\r\n};\r\n","import _ from 'lodash';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { ScopedVars } from '@grafana/data';\r\n\r\nexport default class PostgresQuery {\r\n  target: any;\r\n  templateSrv: any;\r\n  scopedVars: any;\r\n\r\n  /** @ngInject */\r\n  constructor(target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\r\n    this.target = target;\r\n    this.templateSrv = templateSrv;\r\n    this.scopedVars = scopedVars;\r\n\r\n    target.format = target.format || 'time_series';\r\n    target.timeColumn = target.timeColumn || 'time';\r\n    target.metricColumn = target.metricColumn || 'none';\r\n\r\n    target.group = target.group || [];\r\n    target.where = target.where || [{ type: 'macro', name: '$__timeFilter', params: [] }];\r\n    target.select = target.select || [[{ type: 'column', params: ['value'] }]];\r\n\r\n    // handle pre query gui panels gracefully\r\n    if (!('rawQuery' in this.target)) {\r\n      if ('rawSql' in target) {\r\n        // pre query gui panel\r\n        target.rawQuery = true;\r\n      } else {\r\n        // new panel\r\n        target.rawQuery = false;\r\n      }\r\n    }\r\n\r\n    // give interpolateQueryStr access to this\r\n    this.interpolateQueryStr = this.interpolateQueryStr.bind(this);\r\n  }\r\n\r\n  // remove identifier quoting from identifier to use in metadata queries\r\n  unquoteIdentifier(value: string) {\r\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\r\n      return value.substring(1, value.length - 1).replace(/\"\"/g, '\"');\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  quoteIdentifier(value: any) {\r\n    return '\"' + String(value).replace(/\"/g, '\"\"') + '\"';\r\n  }\r\n\r\n  quoteLiteral(value: any) {\r\n    return \"'\" + String(value).replace(/'/g, \"''\") + \"'\";\r\n  }\r\n\r\n  escapeLiteral(value: any) {\r\n    return String(value).replace(/'/g, \"''\");\r\n  }\r\n\r\n  hasTimeGroup() {\r\n    return _.find(this.target.group, (g: any) => g.type === 'time');\r\n  }\r\n\r\n  hasMetricColumn() {\r\n    return this.target.metricColumn !== 'none';\r\n  }\r\n\r\n  interpolateQueryStr(value: any, variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\r\n    // if no multi or include all do not regexEscape\r\n    if (!variable.multi && !variable.includeAll) {\r\n      return this.escapeLiteral(value);\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return this.quoteLiteral(value);\r\n    }\r\n\r\n    const escapedValues = _.map(value, this.quoteLiteral);\r\n    return escapedValues.join(',');\r\n  }\r\n\r\n  render(interpolate?: any) {\r\n    const target = this.target;\r\n\r\n    // new query with no table set yet\r\n    if (!this.target.rawQuery && !('table' in this.target)) {\r\n      return '';\r\n    }\r\n\r\n    if (!target.rawQuery) {\r\n      target.rawSql = this.buildQuery();\r\n    }\r\n\r\n    if (interpolate) {\r\n      return this.templateSrv.replace(target.rawSql, this.scopedVars, this.interpolateQueryStr);\r\n    } else {\r\n      return target.rawSql;\r\n    }\r\n  }\r\n\r\n  hasUnixEpochTimecolumn() {\r\n    return ['int4', 'int8', 'float4', 'float8', 'numeric'].indexOf(this.target.timeColumnType) > -1;\r\n  }\r\n\r\n  buildTimeColumn(alias = true) {\r\n    const timeGroup = this.hasTimeGroup();\r\n    let query;\r\n    let macro = '$__timeGroup';\r\n\r\n    if (timeGroup) {\r\n      let args;\r\n      if (timeGroup.params.length > 1 && timeGroup.params[1] !== 'none') {\r\n        args = timeGroup.params.join(',');\r\n      } else {\r\n        args = timeGroup.params[0];\r\n      }\r\n      if (this.hasUnixEpochTimecolumn()) {\r\n        macro = '$__unixEpochGroup';\r\n      }\r\n      if (alias) {\r\n        macro += 'Alias';\r\n      }\r\n      query = macro + '(' + this.target.timeColumn + ',' + args + ')';\r\n    } else {\r\n      query = this.target.timeColumn;\r\n      if (alias) {\r\n        query += ' AS \"time\"';\r\n      }\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildMetricColumn() {\r\n    if (this.hasMetricColumn()) {\r\n      return this.target.metricColumn + ' AS metric';\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  buildValueColumns() {\r\n    let query = '';\r\n    for (const column of this.target.select) {\r\n      query += ',\\n  ' + this.buildValueColumn(column);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildValueColumn(column: any) {\r\n    let query = '';\r\n\r\n    const columnName: any = _.find(column, (g: any) => g.type === 'column');\r\n    query = columnName.params[0];\r\n\r\n    const aggregate: any = _.find(column, (g: any) => g.type === 'aggregate' || g.type === 'percentile');\r\n    const windows: any = _.find(column, (g: any) => g.type === 'window' || g.type === 'moving_window');\r\n\r\n    if (aggregate) {\r\n      const func = aggregate.params[0];\r\n      switch (aggregate.type) {\r\n        case 'aggregate':\r\n          if (func === 'first' || func === 'last') {\r\n            query = func + '(' + query + ',' + this.target.timeColumn + ')';\r\n          } else {\r\n            query = func + '(' + query + ')';\r\n          }\r\n          break;\r\n        case 'percentile':\r\n          query = func + '(' + aggregate.params[1] + ') WITHIN GROUP (ORDER BY ' + query + ')';\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (windows) {\r\n      const overParts = [];\r\n      if (this.hasMetricColumn()) {\r\n        overParts.push('PARTITION BY ' + this.target.metricColumn);\r\n      }\r\n      overParts.push('ORDER BY ' + this.buildTimeColumn(false));\r\n\r\n      const over = overParts.join(' ');\r\n      let curr: string;\r\n      let prev: string;\r\n      switch (windows.type) {\r\n        case 'window':\r\n          switch (windows.params[0]) {\r\n            case 'delta':\r\n              curr = query;\r\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\r\n              query = curr + ' - ' + prev;\r\n              break;\r\n            case 'increase':\r\n              curr = query;\r\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\r\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\r\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\r\n              break;\r\n            case 'rate':\r\n              let timeColumn = this.target.timeColumn;\r\n              if (aggregate) {\r\n                timeColumn = 'min(' + timeColumn + ')';\r\n              }\r\n\r\n              curr = query;\r\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\r\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\r\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\r\n              query += '/extract(epoch from ' + timeColumn + ' - lag(' + timeColumn + ') OVER (' + over + '))';\r\n              break;\r\n            default:\r\n              query = windows.params[0] + '(' + query + ') OVER (' + over + ')';\r\n              break;\r\n          }\r\n          break;\r\n        case 'moving_window':\r\n          query = windows.params[0] + '(' + query + ') OVER (' + over + ' ROWS ' + windows.params[1] + ' PRECEDING)';\r\n          break;\r\n      }\r\n    }\r\n\r\n    const alias: any = _.find(column, (g: any) => g.type === 'alias');\r\n    if (alias) {\r\n      query += ' AS ' + this.quoteIdentifier(alias.params[0]);\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildWhereClause() {\r\n    let query = '';\r\n    const conditions = _.map(this.target.where, (tag, index) => {\r\n      switch (tag.type) {\r\n        case 'macro':\r\n          return tag.name + '(' + this.target.timeColumn + ')';\r\n          break;\r\n        case 'expression':\r\n          return tag.params.join(' ');\r\n          break;\r\n      }\r\n    });\r\n\r\n    if (conditions.length > 0) {\r\n      query = '\\nWHERE\\n  ' + conditions.join(' AND\\n  ');\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  buildGroupClause() {\r\n    let query = '';\r\n    let groupSection = '';\r\n\r\n    for (let i = 0; i < this.target.group.length; i++) {\r\n      const part = this.target.group[i];\r\n      if (i > 0) {\r\n        groupSection += ', ';\r\n      }\r\n      if (part.type === 'time') {\r\n        groupSection += '1';\r\n      } else {\r\n        groupSection += part.params[0];\r\n      }\r\n    }\r\n\r\n    if (groupSection.length) {\r\n      query = '\\nGROUP BY ' + groupSection;\r\n      if (this.hasMetricColumn()) {\r\n        query += ',2';\r\n      }\r\n    }\r\n    return query;\r\n  }\r\n\r\n  buildQuery() {\r\n    let query = 'SELECT';\r\n\r\n    query += '\\n  ' + this.buildTimeColumn();\r\n    if (this.hasMetricColumn()) {\r\n      query += ',\\n  ' + this.buildMetricColumn();\r\n    }\r\n    query += this.buildValueColumns();\r\n\r\n    query += '\\nFROM ' + this.target.table;\r\n\r\n    query += this.buildWhereClause();\r\n    query += this.buildGroupClause();\r\n\r\n    query += '\\nORDER BY 1';\r\n    if (this.hasMetricColumn()) {\r\n      query += ',2';\r\n    }\r\n\r\n    return query;\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport appEvents from 'app/core/app_events';\r\nimport { PostgresMetaQuery } from './meta_query';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { SqlPart } from 'app/core/components/sql_part/sql_part';\r\nimport PostgresQuery from './postgres_query';\r\nimport sqlPart from './sql_part';\r\nimport { auto } from 'angular';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { CoreEvents } from 'app/types';\r\nimport { PanelEvents } from '@grafana/data';\r\n\r\nexport interface QueryMeta {\r\n  sql: string;\r\n}\r\n\r\nconst defaultQuery = `SELECT\r\n  $__time(time_column),\r\n  value1\r\nFROM\r\n  metric_table\r\nWHERE\r\n  $__timeFilter(time_column)\r\n`;\r\n\r\nexport class PostgresQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  showLastQuerySQL: boolean;\r\n  formats: any[];\r\n  queryModel: PostgresQuery;\r\n  metaBuilder: PostgresMetaQuery;\r\n  lastQueryMeta: QueryMeta;\r\n  lastQueryError: string;\r\n  showHelp: boolean;\r\n  tableSegment: any;\r\n  whereAdd: any;\r\n  timeColumnSegment: any;\r\n  metricColumnSegment: any;\r\n  selectMenu: any[];\r\n  selectParts: SqlPart[][];\r\n  groupParts: SqlPart[];\r\n  whereParts: SqlPart[];\r\n  groupAdd: any;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    $scope: any,\r\n    $injector: auto.IInjectorService,\r\n    private templateSrv: TemplateSrv,\r\n    private uiSegmentSrv: any\r\n  ) {\r\n    super($scope, $injector);\r\n    this.target = this.target;\r\n    this.queryModel = new PostgresQuery(this.target, templateSrv, this.panel.scopedVars);\r\n    this.metaBuilder = new PostgresMetaQuery(this.target, this.queryModel);\r\n    this.updateProjection();\r\n\r\n    this.formats = [\r\n      { text: 'Time series', value: 'time_series' },\r\n      { text: 'Table', value: 'table' },\r\n    ];\r\n\r\n    if (!this.target.rawSql) {\r\n      // special handling when in table panel\r\n      if (this.panelCtrl.panel.type === 'table') {\r\n        this.target.format = 'table';\r\n        this.target.rawSql = 'SELECT 1';\r\n        this.target.rawQuery = true;\r\n      } else {\r\n        this.target.rawSql = defaultQuery;\r\n        this.datasource.metricFindQuery(this.metaBuilder.findMetricTable()).then((result: any) => {\r\n          if (result.length > 0) {\r\n            this.target.table = result[0].text;\r\n            let segment = this.uiSegmentSrv.newSegment(this.target.table);\r\n            this.tableSegment.html = segment.html;\r\n            this.tableSegment.value = segment.value;\r\n\r\n            this.target.timeColumn = result[1].text;\r\n            segment = this.uiSegmentSrv.newSegment(this.target.timeColumn);\r\n            this.timeColumnSegment.html = segment.html;\r\n            this.timeColumnSegment.value = segment.value;\r\n\r\n            this.target.timeColumnType = 'timestamp';\r\n            this.target.select = [[{ type: 'column', params: [result[2].text] }]];\r\n            this.updateProjection();\r\n            this.updateRawSqlAndRefresh();\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!this.target.table) {\r\n      this.tableSegment = uiSegmentSrv.newSegment({ value: 'select table', fake: true });\r\n    } else {\r\n      this.tableSegment = uiSegmentSrv.newSegment(this.target.table);\r\n    }\r\n\r\n    this.timeColumnSegment = uiSegmentSrv.newSegment(this.target.timeColumn);\r\n    this.metricColumnSegment = uiSegmentSrv.newSegment(this.target.metricColumn);\r\n\r\n    this.buildSelectMenu();\r\n    this.whereAdd = this.uiSegmentSrv.newPlusButton();\r\n    this.groupAdd = this.uiSegmentSrv.newPlusButton();\r\n\r\n    this.panelCtrl.events.on(PanelEvents.dataReceived, this.onDataReceived.bind(this), $scope);\r\n    this.panelCtrl.events.on(PanelEvents.dataError, this.onDataError.bind(this), $scope);\r\n  }\r\n\r\n  updateRawSqlAndRefresh() {\r\n    if (!this.target.rawQuery) {\r\n      this.target.rawSql = this.queryModel.buildQuery();\r\n    }\r\n\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  updateProjection() {\r\n    this.selectParts = _.map(this.target.select, (parts: any) => {\r\n      return _.map(parts, sqlPart.create).filter(n => n);\r\n    });\r\n    this.whereParts = _.map(this.target.where, sqlPart.create).filter(n => n);\r\n    this.groupParts = _.map(this.target.group, sqlPart.create).filter(n => n);\r\n  }\r\n\r\n  updatePersistedParts() {\r\n    this.target.select = _.map(this.selectParts, selectParts => {\r\n      return _.map(selectParts, (part: any) => {\r\n        return { type: part.def.type, datatype: part.datatype, params: part.params };\r\n      });\r\n    });\r\n    this.target.where = _.map(this.whereParts, (part: any) => {\r\n      return { type: part.def.type, datatype: part.datatype, name: part.name, params: part.params };\r\n    });\r\n    this.target.group = _.map(this.groupParts, (part: any) => {\r\n      return { type: part.def.type, datatype: part.datatype, params: part.params };\r\n    });\r\n  }\r\n\r\n  buildSelectMenu() {\r\n    this.selectMenu = [];\r\n    const aggregates = {\r\n      text: 'Aggregate Functions',\r\n      value: 'aggregate',\r\n      submenu: [\r\n        { text: 'Average', value: 'avg' },\r\n        { text: 'Count', value: 'count' },\r\n        { text: 'Maximum', value: 'max' },\r\n        { text: 'Minimum', value: 'min' },\r\n        { text: 'Sum', value: 'sum' },\r\n        { text: 'Standard deviation', value: 'stddev' },\r\n        { text: 'Variance', value: 'variance' },\r\n      ],\r\n    };\r\n\r\n    // first and last aggregate are timescaledb specific\r\n    if (this.datasource.jsonData.timescaledb === true) {\r\n      aggregates.submenu.push({ text: 'First', value: 'first' });\r\n      aggregates.submenu.push({ text: 'Last', value: 'last' });\r\n    }\r\n\r\n    this.selectMenu.push(aggregates);\r\n\r\n    // ordered set aggregates require postgres 9.4+\r\n    if (this.datasource.jsonData.postgresVersion >= 904) {\r\n      const aggregates2 = {\r\n        text: 'Ordered-Set Aggregate Functions',\r\n        value: 'percentile',\r\n        submenu: [\r\n          { text: 'Percentile (continuous)', value: 'percentile_cont' },\r\n          { text: 'Percentile (discrete)', value: 'percentile_disc' },\r\n        ],\r\n      };\r\n      this.selectMenu.push(aggregates2);\r\n    }\r\n\r\n    const windows = {\r\n      text: 'Window Functions',\r\n      value: 'window',\r\n      submenu: [\r\n        { text: 'Delta', value: 'delta' },\r\n        { text: 'Increase', value: 'increase' },\r\n        { text: 'Rate', value: 'rate' },\r\n        { text: 'Sum', value: 'sum' },\r\n        { text: 'Moving Average', value: 'avg', type: 'moving_window' },\r\n      ],\r\n    };\r\n    this.selectMenu.push(windows);\r\n\r\n    this.selectMenu.push({ text: 'Alias', value: 'alias' });\r\n    this.selectMenu.push({ text: 'Column', value: 'column' });\r\n  }\r\n\r\n  toggleEditorMode() {\r\n    if (this.target.rawQuery) {\r\n      appEvents.emit(CoreEvents.showConfirmModal, {\r\n        title: 'Warning',\r\n        text2: 'Switching to query builder may overwrite your raw SQL.',\r\n        icon: 'fa-exclamation',\r\n        yesText: 'Switch',\r\n        onConfirm: () => {\r\n          this.target.rawQuery = !this.target.rawQuery;\r\n        },\r\n      });\r\n    } else {\r\n      this.target.rawQuery = !this.target.rawQuery;\r\n    }\r\n  }\r\n\r\n  resetPlusButton(button: { html: any; value: any }) {\r\n    const plusButton = this.uiSegmentSrv.newPlusButton();\r\n    button.html = plusButton.html;\r\n    button.value = plusButton.value;\r\n  }\r\n\r\n  getTableSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildTableQuery())\r\n      .then(this.transformToSegments({}))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  tableChanged() {\r\n    this.target.table = this.tableSegment.value;\r\n    this.target.where = [];\r\n    this.target.group = [];\r\n    this.updateProjection();\r\n\r\n    const segment = this.uiSegmentSrv.newSegment('none');\r\n    this.metricColumnSegment.html = segment.html;\r\n    this.metricColumnSegment.value = segment.value;\r\n    this.target.metricColumn = 'none';\r\n\r\n    const task1 = this.datasource.metricFindQuery(this.metaBuilder.buildColumnQuery('time')).then((result: any) => {\r\n      // check if time column is still valid\r\n      if (result.length > 0 && !_.find(result, (r: any) => r.text === this.target.timeColumn)) {\r\n        const segment = this.uiSegmentSrv.newSegment(result[0].text);\r\n        this.timeColumnSegment.html = segment.html;\r\n        this.timeColumnSegment.value = segment.value;\r\n      }\r\n      return this.timeColumnChanged(false);\r\n    });\r\n    const task2 = this.datasource.metricFindQuery(this.metaBuilder.buildColumnQuery('value')).then((result: any) => {\r\n      if (result.length > 0) {\r\n        this.target.select = [[{ type: 'column', params: [result[0].text] }]];\r\n        this.updateProjection();\r\n      }\r\n    });\r\n\r\n    Promise.all([task1, task2]).then(() => {\r\n      this.updateRawSqlAndRefresh();\r\n    });\r\n  }\r\n\r\n  getTimeColumnSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('time'))\r\n      .then(this.transformToSegments({}))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  timeColumnChanged(refresh?: boolean) {\r\n    this.target.timeColumn = this.timeColumnSegment.value;\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildDatatypeQuery(this.target.timeColumn))\r\n      .then((result: any) => {\r\n        if (result.length === 1) {\r\n          if (this.target.timeColumnType !== result[0].text) {\r\n            this.target.timeColumnType = result[0].text;\r\n          }\r\n          let partModel;\r\n          if (this.queryModel.hasUnixEpochTimecolumn()) {\r\n            partModel = sqlPart.create({ type: 'macro', name: '$__unixEpochFilter', params: [] });\r\n          } else {\r\n            partModel = sqlPart.create({ type: 'macro', name: '$__timeFilter', params: [] });\r\n          }\r\n\r\n          if (this.whereParts.length >= 1 && this.whereParts[0].def.type === 'macro') {\r\n            // replace current macro\r\n            this.whereParts[0] = partModel;\r\n          } else {\r\n            this.whereParts.splice(0, 0, partModel);\r\n          }\r\n        }\r\n\r\n        this.updatePersistedParts();\r\n        if (refresh !== false) {\r\n          this.updateRawSqlAndRefresh();\r\n        }\r\n      });\r\n  }\r\n\r\n  getMetricColumnSegments() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('metric'))\r\n      .then(this.transformToSegments({ addNone: true }))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  metricColumnChanged() {\r\n    this.target.metricColumn = this.metricColumnSegment.value;\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  onDataReceived(dataList: any) {\r\n    this.lastQueryMeta = null;\r\n    this.lastQueryError = null;\r\n    console.log('postgres query data received', dataList);\r\n\r\n    const anySeriesFromQuery: any = _.find(dataList, { refId: this.target.refId });\r\n    if (anySeriesFromQuery) {\r\n      this.lastQueryMeta = anySeriesFromQuery.meta;\r\n    }\r\n  }\r\n\r\n  onDataError(err: any) {\r\n    if (err.data && err.data.results) {\r\n      const queryRes = err.data.results[this.target.refId];\r\n      if (queryRes) {\r\n        this.lastQueryMeta = queryRes.meta;\r\n        this.lastQueryError = queryRes.error;\r\n      }\r\n    }\r\n  }\r\n\r\n  transformToSegments(config: { addNone?: any; addTemplateVars?: any; templateQuoter?: any }) {\r\n    return (results: any) => {\r\n      const segments = _.map(results, segment => {\r\n        return this.uiSegmentSrv.newSegment({\r\n          value: segment.text,\r\n          expandable: segment.expandable,\r\n        });\r\n      });\r\n\r\n      if (config.addTemplateVars) {\r\n        for (const variable of this.templateSrv.variables) {\r\n          let value;\r\n          value = '$' + variable.name;\r\n          if (config.templateQuoter && variable.multi === false) {\r\n            value = config.templateQuoter(value);\r\n          }\r\n\r\n          segments.unshift(\r\n            this.uiSegmentSrv.newSegment({\r\n              type: 'template',\r\n              value: value,\r\n              expandable: true,\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      if (config.addNone) {\r\n        segments.unshift(this.uiSegmentSrv.newSegment({ type: 'template', value: 'none', expandable: true }));\r\n      }\r\n\r\n      return segments;\r\n    };\r\n  }\r\n\r\n  findAggregateIndex(selectParts: any) {\r\n    return _.findIndex(selectParts, (p: any) => p.def.type === 'aggregate' || p.def.type === 'percentile');\r\n  }\r\n\r\n  findWindowIndex(selectParts: any) {\r\n    return _.findIndex(selectParts, (p: any) => p.def.type === 'window' || p.def.type === 'moving_window');\r\n  }\r\n\r\n  addSelectPart(selectParts: any[], item: { value: any }, subItem: { type: any; value: any }) {\r\n    let partType = item.value;\r\n    if (subItem && subItem.type) {\r\n      partType = subItem.type;\r\n    }\r\n    let partModel = sqlPart.create({ type: partType });\r\n    if (subItem) {\r\n      partModel.params[0] = subItem.value;\r\n    }\r\n    let addAlias = false;\r\n\r\n    switch (partType) {\r\n      case 'column':\r\n        const parts = _.map(selectParts, (part: any) => {\r\n          return sqlPart.create({ type: part.def.type, params: _.clone(part.params) });\r\n        });\r\n        this.selectParts.push(parts);\r\n        break;\r\n      case 'percentile':\r\n      case 'aggregate':\r\n        // add group by if no group by yet\r\n        if (this.target.group.length === 0) {\r\n          this.addGroup('time', '$__interval');\r\n        }\r\n        const aggIndex = this.findAggregateIndex(selectParts);\r\n        if (aggIndex !== -1) {\r\n          // replace current aggregation\r\n          selectParts[aggIndex] = partModel;\r\n        } else {\r\n          selectParts.splice(1, 0, partModel);\r\n        }\r\n        if (!_.find(selectParts, (p: any) => p.def.type === 'alias')) {\r\n          addAlias = true;\r\n        }\r\n        break;\r\n      case 'moving_window':\r\n      case 'window':\r\n        const windowIndex = this.findWindowIndex(selectParts);\r\n        if (windowIndex !== -1) {\r\n          // replace current window function\r\n          selectParts[windowIndex] = partModel;\r\n        } else {\r\n          const aggIndex = this.findAggregateIndex(selectParts);\r\n          if (aggIndex !== -1) {\r\n            selectParts.splice(aggIndex + 1, 0, partModel);\r\n          } else {\r\n            selectParts.splice(1, 0, partModel);\r\n          }\r\n        }\r\n        if (!_.find(selectParts, (p: any) => p.def.type === 'alias')) {\r\n          addAlias = true;\r\n        }\r\n        break;\r\n      case 'alias':\r\n        addAlias = true;\r\n        break;\r\n    }\r\n\r\n    if (addAlias) {\r\n      // set initial alias name to column name\r\n      partModel = sqlPart.create({ type: 'alias', params: [selectParts[0].params[0].replace(/\"/g, '')] });\r\n      if (selectParts[selectParts.length - 1].def.type === 'alias') {\r\n        selectParts[selectParts.length - 1] = partModel;\r\n      } else {\r\n        selectParts.push(partModel);\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  removeSelectPart(selectParts: any, part: { def: { type: string } }) {\r\n    if (part.def.type === 'column') {\r\n      // remove all parts of column unless its last column\r\n      if (this.selectParts.length > 1) {\r\n        const modelsIndex = _.indexOf(this.selectParts, selectParts);\r\n        this.selectParts.splice(modelsIndex, 1);\r\n      }\r\n    } else {\r\n      const partIndex = _.indexOf(selectParts, part);\r\n      selectParts.splice(partIndex, 1);\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  handleSelectPartEvent(selectParts: any, part: { def: any }, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        switch (part.def.type) {\r\n          case 'aggregate':\r\n            return this.datasource\r\n              .metricFindQuery(this.metaBuilder.buildAggregateQuery())\r\n              .then(this.transformToSegments({}))\r\n              .catch(this.handleQueryError.bind(this));\r\n          case 'column':\r\n            return this.datasource\r\n              .metricFindQuery(this.metaBuilder.buildColumnQuery('value'))\r\n              .then(this.transformToSegments({}))\r\n              .catch(this.handleQueryError.bind(this));\r\n        }\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.removeSelectPart(selectParts, part);\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleGroupPartEvent(part: any, index: any, evt: { name: any }) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        return this.datasource\r\n          .metricFindQuery(this.metaBuilder.buildColumnQuery())\r\n          .then(this.transformToSegments({}))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.removeGroup(part, index);\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  addGroup(partType: string, value: string) {\r\n    let params = [value];\r\n    if (partType === 'time') {\r\n      params = ['$__interval', 'none'];\r\n    }\r\n    const partModel = sqlPart.create({ type: partType, params: params });\r\n\r\n    if (partType === 'time') {\r\n      // put timeGroup at start\r\n      this.groupParts.splice(0, 0, partModel);\r\n    } else {\r\n      this.groupParts.push(partModel);\r\n    }\r\n\r\n    // add aggregates when adding group by\r\n    for (const selectParts of this.selectParts) {\r\n      if (!selectParts.some(part => part.def.type === 'aggregate')) {\r\n        const aggregate = sqlPart.create({ type: 'aggregate', params: ['avg'] });\r\n        selectParts.splice(1, 0, aggregate);\r\n        if (!selectParts.some(part => part.def.type === 'alias')) {\r\n          const alias = sqlPart.create({ type: 'alias', params: [selectParts[0].part.params[0]] });\r\n          selectParts.push(alias);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  removeGroup(part: { def: { type: string } }, index: number) {\r\n    if (part.def.type === 'time') {\r\n      // remove aggregations\r\n      this.selectParts = _.map(this.selectParts, (s: any) => {\r\n        return _.filter(s, (part: any) => {\r\n          if (part.def.type === 'aggregate' || part.def.type === 'percentile') {\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n    }\r\n\r\n    this.groupParts.splice(index, 1);\r\n    this.updatePersistedParts();\r\n  }\r\n\r\n  handleWherePartEvent(whereParts: any, part: any, evt: any, index: any) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        switch (evt.param.name) {\r\n          case 'left':\r\n            return this.datasource\r\n              .metricFindQuery(this.metaBuilder.buildColumnQuery())\r\n              .then(this.transformToSegments({}))\r\n              .catch(this.handleQueryError.bind(this));\r\n          case 'right':\r\n            if (['int4', 'int8', 'float4', 'float8', 'timestamp', 'timestamptz'].indexOf(part.datatype) > -1) {\r\n              // don't do value lookups for numerical fields\r\n              return Promise.resolve([]);\r\n            } else {\r\n              return this.datasource\r\n                .metricFindQuery(this.metaBuilder.buildValueQuery(part.params[0]))\r\n                .then(\r\n                  this.transformToSegments({\r\n                    addTemplateVars: true,\r\n                    templateQuoter: (v: string) => {\r\n                      return this.queryModel.quoteLiteral(v);\r\n                    },\r\n                  })\r\n                )\r\n                .catch(this.handleQueryError.bind(this));\r\n            }\r\n          case 'op':\r\n            return Promise.resolve(this.uiSegmentSrv.newOperators(this.metaBuilder.getOperators(part.datatype)));\r\n          default:\r\n            return Promise.resolve([]);\r\n        }\r\n      }\r\n      case 'part-param-changed': {\r\n        this.updatePersistedParts();\r\n        this.datasource.metricFindQuery(this.metaBuilder.buildDatatypeQuery(part.params[0])).then((d: any) => {\r\n          if (d.length === 1) {\r\n            part.datatype = d[0].text;\r\n          }\r\n        });\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        // remove element\r\n        whereParts.splice(index, 1);\r\n        this.updatePersistedParts();\r\n        this.updateRawSqlAndRefresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  getWhereOptions() {\r\n    const options = [];\r\n    if (this.queryModel.hasUnixEpochTimecolumn()) {\r\n      options.push(this.uiSegmentSrv.newSegment({ type: 'macro', value: '$__unixEpochFilter' }));\r\n    } else {\r\n      options.push(this.uiSegmentSrv.newSegment({ type: 'macro', value: '$__timeFilter' }));\r\n    }\r\n    options.push(this.uiSegmentSrv.newSegment({ type: 'expression', value: 'Expression' }));\r\n    return Promise.resolve(options);\r\n  }\r\n\r\n  addWhereAction(part: any, index: any) {\r\n    switch (this.whereAdd.type) {\r\n      case 'macro': {\r\n        const partModel = sqlPart.create({ type: 'macro', name: this.whereAdd.value, params: [] });\r\n        if (this.whereParts.length >= 1 && this.whereParts[0].def.type === 'macro') {\r\n          // replace current macro\r\n          this.whereParts[0] = partModel;\r\n        } else {\r\n          this.whereParts.splice(0, 0, partModel);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        this.whereParts.push(sqlPart.create({ type: 'expression', params: ['value', '=', 'value'] }));\r\n      }\r\n    }\r\n\r\n    this.updatePersistedParts();\r\n    this.resetPlusButton(this.whereAdd);\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  getGroupOptions() {\r\n    return this.datasource\r\n      .metricFindQuery(this.metaBuilder.buildColumnQuery('group'))\r\n      .then((tags: any) => {\r\n        const options = [];\r\n        if (!this.queryModel.hasTimeGroup()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ type: 'time', value: 'time($__interval,none)' }));\r\n        }\r\n        for (const tag of tags) {\r\n          options.push(this.uiSegmentSrv.newSegment({ type: 'column', value: tag.text }));\r\n        }\r\n        return options;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  addGroupAction() {\r\n    switch (this.groupAdd.value) {\r\n      default: {\r\n        this.addGroup(this.groupAdd.type, this.groupAdd.value);\r\n      }\r\n    }\r\n\r\n    this.resetPlusButton(this.groupAdd);\r\n    this.updateRawSqlAndRefresh();\r\n  }\r\n\r\n  handleQueryError(err: any): any[] {\r\n    this.error = err.message || 'Failed to issue metric query';\r\n    return [];\r\n  }\r\n}\r\n","import _ from 'lodash';\r\n\r\nexport default class ResponseParser {\r\n  processQueryResult(res: any) {\r\n    const data: any[] = [];\r\n\r\n    if (!res.data.results) {\r\n      return { data: data };\r\n    }\r\n\r\n    for (const key in res.data.results) {\r\n      const queryRes = res.data.results[key];\r\n\r\n      if (queryRes.series) {\r\n        for (const series of queryRes.series) {\r\n          data.push({\r\n            target: series.name,\r\n            datapoints: series.points,\r\n            refId: queryRes.refId,\r\n            meta: queryRes.meta,\r\n          });\r\n        }\r\n      }\r\n\r\n      if (queryRes.tables) {\r\n        for (const table of queryRes.tables) {\r\n          table.type = 'table';\r\n          table.refId = queryRes.refId;\r\n          table.meta = queryRes.meta;\r\n          data.push(table);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { data: data };\r\n  }\r\n\r\n  parseMetricFindQueryResult(refId: string, results: any) {\r\n    if (!results || results.data.length === 0 || results.data.results[refId].meta.rowCount === 0) {\r\n      return [];\r\n    }\r\n\r\n    const columns = results.data.results[refId].tables[0].columns;\r\n    const rows = results.data.results[refId].tables[0].rows;\r\n    const textColIndex = this.findColIndex(columns, '__text');\r\n    const valueColIndex = this.findColIndex(columns, '__value');\r\n\r\n    if (columns.length === 2 && textColIndex !== -1 && valueColIndex !== -1) {\r\n      return this.transformToKeyValueList(rows, textColIndex, valueColIndex);\r\n    }\r\n\r\n    return this.transformToSimpleList(rows);\r\n  }\r\n\r\n  transformToKeyValueList(rows: any, textColIndex: number, valueColIndex: number) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      if (!this.containsKey(res, rows[i][textColIndex])) {\r\n        res.push({\r\n          text: rows[i][textColIndex],\r\n          value: rows[i][valueColIndex],\r\n        });\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  transformToSimpleList(rows: any[][]) {\r\n    const res = [];\r\n\r\n    for (let i = 0; i < rows.length; i++) {\r\n      for (let j = 0; j < rows[i].length; j++) {\r\n        const value = rows[i][j];\r\n        if (res.indexOf(value) === -1) {\r\n          res.push(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return _.map(res, value => {\r\n      return { text: value };\r\n    });\r\n  }\r\n\r\n  findColIndex(columns: any[], colName: string) {\r\n    for (let i = 0; i < columns.length; i++) {\r\n      if (columns[i].text === colName) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  containsKey(res: any, key: any) {\r\n    for (let i = 0; i < res.length; i++) {\r\n      if (res[i].text === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  transformAnnotationResponse(options: any, data: any) {\r\n    const table = data.data.results[options.annotation.name].tables[0];\r\n\r\n    let timeColumnIndex = -1;\r\n    let timeEndColumnIndex = -1;\r\n    const titleColumnIndex = -1;\r\n    let textColumnIndex = -1;\r\n    let tagsColumnIndex = -1;\r\n\r\n    for (let i = 0; i < table.columns.length; i++) {\r\n      if (table.columns[i].text === 'time') {\r\n        timeColumnIndex = i;\r\n      } else if (table.columns[i].text === 'timeend') {\r\n        timeEndColumnIndex = i;\r\n      } else if (table.columns[i].text === 'text') {\r\n        textColumnIndex = i;\r\n      } else if (table.columns[i].text === 'tags') {\r\n        tagsColumnIndex = i;\r\n      }\r\n    }\r\n\r\n    if (timeColumnIndex === -1) {\r\n      return Promise.reject({\r\n        message: 'Missing mandatory time column in annotation query.',\r\n      });\r\n    }\r\n\r\n    const list = [];\r\n    for (let i = 0; i < table.rows.length; i++) {\r\n      const row = table.rows[i];\r\n      const timeEnd =\r\n        timeEndColumnIndex !== -1 && row[timeEndColumnIndex] ? Math.floor(row[timeEndColumnIndex]) : undefined;\r\n      list.push({\r\n        annotation: options.annotation,\r\n        time: Math.floor(row[timeColumnIndex]),\r\n        timeEnd,\r\n        title: row[titleColumnIndex],\r\n        text: row[textColumnIndex],\r\n        tags: row[tagsColumnIndex] ? row[tagsColumnIndex].trim().split(/\\s*,\\s*/) : [],\r\n      });\r\n    }\r\n\r\n    return list;\r\n  }\r\n}\r\n","import { SqlPartDef, SqlPart } from 'app/core/components/sql_part/sql_part';\n\nconst index: any[] = [];\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    return null;\n  }\n\n  return new SqlPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new SqlPartDef(options);\n}\n\nregister({\n  type: 'column',\n  style: 'label',\n  params: [{ type: 'column', dynamicLookup: true }],\n  defaultParams: ['value'],\n});\n\nregister({\n  type: 'expression',\n  style: 'expression',\n  label: 'Expr:',\n  params: [\n    { name: 'left', type: 'string', dynamicLookup: true },\n    { name: 'op', type: 'string', dynamicLookup: true },\n    { name: 'right', type: 'string', dynamicLookup: true },\n  ],\n  defaultParams: ['value', '=', 'value'],\n});\n\nregister({\n  type: 'macro',\n  style: 'label',\n  label: 'Macro:',\n  params: [],\n  defaultParams: [],\n});\n\nregister({\n  type: 'aggregate',\n  style: 'label',\n  params: [\n    {\n      name: 'name',\n      type: 'string',\n      options: ['avg', 'count', 'min', 'max', 'sum', 'stddev', 'variance'],\n    },\n  ],\n  defaultParams: ['avg'],\n});\n\nregister({\n  type: 'percentile',\n  label: 'Aggregate:',\n  style: 'label',\n  params: [\n    {\n      name: 'name',\n      type: 'string',\n      options: ['percentile_cont', 'percentile_disc'],\n    },\n    {\n      name: 'fraction',\n      type: 'number',\n      options: ['0.5', '0.75', '0.9', '0.95', '0.99'],\n    },\n  ],\n  defaultParams: ['percentile_cont', '0.95'],\n});\n\nregister({\n  type: 'alias',\n  style: 'label',\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n});\n\nregister({\n  type: 'time',\n  style: 'function',\n  label: 'time',\n  params: [\n    {\n      name: 'interval',\n      type: 'interval',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'NULL', 'previous', '0'],\n    },\n  ],\n  defaultParams: ['$__interval', 'none'],\n});\n\nregister({\n  type: 'window',\n  style: 'label',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['delta', 'increase', 'rate', 'sum'],\n    },\n  ],\n  defaultParams: ['increase'],\n});\n\nregister({\n  type: 'moving_window',\n  style: 'label',\n  label: 'Moving Window:',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['avg'],\n    },\n    {\n      name: 'window_size',\n      type: 'number',\n      options: ['3', '5', '7', '10', '20'],\n    },\n  ],\n  defaultParams: ['avg', '5'],\n});\n\nexport default {\n  create: createPart,\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAIA;AAAA;AACA;AACA;AACA;AAkBA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AASA;AACA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArDA;AA+DA;AAAA;AAhEA;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AAOA;AAEA;AAQA;AACA;AAAA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzBA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AAAA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACzMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAuBA;AACA;AAmBA;AACA;AAEA;AACA;AAWA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACvKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAUA;AAKA;AACA;AACA;AACA;AAPA;AAQA;AAAA;AAEA;;;;;;;;;;;;;;;;;;ACzBA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxSA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAMA;AASA;AAAA;AAoBA;AACA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzoBA;AA0oBA;AAAA;AA3oBA;;;;;;;;;;;;;;;;;;ACzBA;AAEA;AAAA;AAmJA;AAlJA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}