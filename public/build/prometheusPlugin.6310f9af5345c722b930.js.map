{"version":3,"file":"prometheusPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./node_modules/lru-cache/index.js","webpack:///webpack:///./node_modules/yallist/iterator.js","webpack:///webpack:///./node_modules/yallist/yallist.js","webpack:///webpack:///./public/app/core/utils/CancelablePromise.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts"],"sourcesContent":["'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","// https://github.com/facebook/react/issues/5465\r\n\r\nexport interface CancelablePromise<T> {\r\n  promise: Promise<T>;\r\n  cancel: () => void;\r\n}\r\n\r\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\r\n  let hasCanceled_ = false;\r\n\r\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\r\n    promise.then(val => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\r\n    promise.catch(error => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\r\n  });\r\n\r\n  return {\r\n    promise: wrappedPromise,\r\n    cancel() {\r\n      hasCanceled_ = true;\r\n    },\r\n  };\r\n};\r\n","import React from 'react';\r\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\r\n\r\nconst CHEAT_SHEET_ITEMS = [\r\n  {\r\n    title: 'Request Rate',\r\n    expression: 'rate(http_request_total[5m])',\r\n    label:\r\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\r\n  },\r\n  {\r\n    title: '95th Percentile of Request Latencies',\r\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\r\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\r\n  },\r\n  {\r\n    title: 'Alerts Firing',\r\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\r\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\r\n  },\r\n  {\r\n    title: 'Step',\r\n    label:\r\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\r\n  },\r\n];\r\n\r\nexport default (props: ExploreStartPageProps) => (\r\n  <div>\r\n    <h2>PromQL Cheat Sheet</h2>\r\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\r\n      <div className=\"cheat-sheet-item\" key={index}>\r\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\r\n        {item.expression ? (\r\n          <div\r\n            className=\"cheat-sheet-item__example\"\r\n            onClick={e => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\r\n          >\r\n            <code>{item.expression}</code>\r\n          </div>\r\n        ) : null}\r\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\r\n      </div>\r\n    ))}\r\n  </div>\r\n);\r\n","import React, { PureComponent } from 'react';\r\n\r\n// Types\r\nimport { ExploreQueryFieldProps } from '@grafana/data';\r\nimport { FormLabel } from '@grafana/ui';\r\n\r\nimport { PrometheusDatasource } from '../datasource';\r\nimport { PromQuery, PromOptions } from '../types';\r\n\r\nimport PromQueryField from './PromQueryField';\r\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\r\n\r\ninterface State {\r\n  interval: string;\r\n}\r\n\r\nexport class PromExploreQueryEditor extends PureComponent<Props, State> {\r\n  // Query target to be modified and used for queries\r\n  query: PromQuery;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    const { query } = props;\r\n    this.query = query;\r\n    // Query target properties that are fully controlled inputs\r\n    this.state = {\r\n      // Fully controlled text inputs\r\n      interval: query.interval,\r\n    };\r\n  }\r\n\r\n  onFieldChange = (query: PromQuery, override?: any) => {\r\n    this.query.expr = query.expr;\r\n  };\r\n\r\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\r\n    const interval = e.currentTarget.value;\r\n    this.query.interval = interval;\r\n    this.setState({ interval });\r\n  };\r\n\r\n  onRunQuery = () => {\r\n    const { query } = this;\r\n    this.props.onChange(query);\r\n    this.props.onRunQuery();\r\n  };\r\n\r\n  onReturnKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n    if (e.key === 'Enter') {\r\n      this.onRunQuery();\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { datasource, query, data, history } = this.props;\r\n    const { interval } = this.state;\r\n\r\n    return (\r\n      <div className=\"gf-form-inline\">\r\n        <PromQueryField\r\n          datasource={datasource}\r\n          query={query}\r\n          onRunQuery={this.onRunQuery}\r\n          onChange={this.onFieldChange}\r\n          history={history}\r\n          data={data}\r\n        >\r\n          <div className=\"gf-form-inline explore-input--ml\">\r\n            <div className=\"gf-form\">\r\n              <FormLabel width={4}>Step</FormLabel>\r\n              <input\r\n                type=\"text\"\r\n                className=\"gf-form-input width-6\"\r\n                placeholder={'auto'}\r\n                onChange={this.onIntervalChange}\r\n                onKeyDown={this.onReturnKeyDown}\r\n                value={interval}\r\n              />\r\n            </div>\r\n          </div>\r\n        </PromQueryField>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport React, { Component } from 'react';\r\n\r\nimport { PrometheusDatasource } from '../datasource';\r\nimport { PromQuery } from '../types';\r\nimport { DataQueryRequest, PanelData } from '@grafana/data';\r\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\r\n\r\ninterface Props {\r\n  datasource: PrometheusDatasource;\r\n  query: PromQuery;\r\n  panelData: PanelData;\r\n}\r\n\r\ninterface State {\r\n  href: string;\r\n}\r\n\r\nexport default class PromLink extends Component<Props, State> {\r\n  state: State = { href: null };\r\n  async componentDidUpdate(prevProps: Props) {\r\n    if (prevProps.panelData !== this.props.panelData && this.props.panelData.request) {\r\n      const href = await this.getExternalLink();\r\n      this.setState({ href });\r\n    }\r\n  }\r\n\r\n  async getExternalLink(): Promise<string> {\r\n    const { query, panelData } = this.props;\r\n    const target = panelData.request.targets.length > 0 ? panelData.request.targets[0] : ({ datasource: null } as any);\r\n    const datasourceName = target.datasource;\r\n    const datasource: PrometheusDatasource = datasourceName\r\n      ? (((await getDatasourceSrv().get(datasourceName)) as any) as PrometheusDatasource)\r\n      : (this.props.datasource as PrometheusDatasource);\r\n\r\n    const range = panelData.request.range;\r\n    const start = datasource.getPrometheusTime(range.from, false);\r\n    const end = datasource.getPrometheusTime(range.to, true);\r\n    const rangeDiff = Math.ceil(end - start);\r\n    const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\r\n\r\n    const options = {\r\n      interval: panelData.request.interval,\r\n    } as DataQueryRequest<PromQuery>;\r\n    const queryOptions = datasource.createQuery(query, options, start, end);\r\n    const expr = {\r\n      'g0.expr': queryOptions.expr,\r\n      'g0.range_input': rangeDiff + 's',\r\n      'g0.end_input': endTime,\r\n      'g0.step_input': queryOptions.step,\r\n      'g0.tab': 0,\r\n    };\r\n\r\n    const args = _.map(expr, (v: string, k: string) => {\r\n      return k + '=' + encodeURIComponent(v);\r\n    }).join('&');\r\n    return `${datasource.directUrl}/graph?${args}`;\r\n  }\r\n\r\n  render() {\r\n    const { href } = this.state;\r\n    return (\r\n      <a href={href} target=\"_blank\" rel=\"noopener\">\r\n        <i className=\"fa fa-share-square-o\" /> Prometheus\r\n      </a>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport React, { PureComponent } from 'react';\r\n\r\n// Types\r\nimport { FormLabel, Select, Switch } from '@grafana/ui';\r\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\r\n\r\nimport { PrometheusDatasource } from '../datasource';\r\nimport { PromQuery, PromOptions } from '../types';\r\n\r\nimport PromQueryField from './PromQueryField';\r\nimport PromLink from './PromLink';\r\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\r\n\r\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\r\n  { label: 'Time series', value: 'time_series' },\r\n  { label: 'Table', value: 'table' },\r\n  { label: 'Heatmap', value: 'heatmap' },\r\n];\r\n\r\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\r\n  value,\r\n  label: '1/' + value,\r\n}));\r\n\r\ninterface State {\r\n  legendFormat: string;\r\n  formatOption: SelectableValue<string>;\r\n  interval: string;\r\n  intervalFactorOption: SelectableValue<number>;\r\n  instant: boolean;\r\n}\r\n\r\nexport class PromQueryEditor extends PureComponent<Props, State> {\r\n  // Query target to be modified and used for queries\r\n  query: PromQuery;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    const { query } = props;\r\n    this.query = query;\r\n    // Query target properties that are fully controlled inputs\r\n    this.state = {\r\n      // Fully controlled text inputs\r\n      interval: query.interval,\r\n      legendFormat: query.legendFormat,\r\n      // Select options\r\n      formatOption: FORMAT_OPTIONS.find(option => option.value === query.format) || FORMAT_OPTIONS[0],\r\n      intervalFactorOption:\r\n        INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\r\n      // Switch options\r\n      instant: Boolean(query.instant),\r\n    };\r\n  }\r\n\r\n  onFieldChange = (query: PromQuery, override?: any) => {\r\n    this.query.expr = query.expr;\r\n  };\r\n\r\n  onFormatChange = (option: SelectableValue<string>) => {\r\n    this.query.format = option.value;\r\n    this.setState({ formatOption: option }, this.onRunQuery);\r\n  };\r\n\r\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const instant = e.target.checked;\r\n    this.query.instant = instant;\r\n    this.setState({ instant }, this.onRunQuery);\r\n  };\r\n\r\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\r\n    const interval = e.currentTarget.value;\r\n    this.query.interval = interval;\r\n    this.setState({ interval });\r\n  };\r\n\r\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\r\n    this.query.intervalFactor = option.value;\r\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\r\n  };\r\n\r\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\r\n    const legendFormat = e.currentTarget.value;\r\n    this.query.legendFormat = legendFormat;\r\n    this.setState({ legendFormat });\r\n  };\r\n\r\n  onRunQuery = () => {\r\n    const { query } = this;\r\n    this.props.onChange(query);\r\n    this.props.onRunQuery();\r\n  };\r\n\r\n  render() {\r\n    const { datasource, query, data } = this.props;\r\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <PromQueryField\r\n          datasource={datasource}\r\n          query={query}\r\n          onRunQuery={this.onRunQuery}\r\n          onChange={this.onFieldChange}\r\n          history={[]}\r\n          data={data}\r\n        />\r\n\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form\">\r\n            <FormLabel\r\n              width={7}\r\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\r\n        {{hostname}} will be replaced with label value for the label hostname.\"\r\n            >\r\n              Legend\r\n            </FormLabel>\r\n            <input\r\n              type=\"text\"\r\n              className=\"gf-form-input\"\r\n              placeholder=\"legend format\"\r\n              value={legendFormat}\r\n              onChange={this.onLegendChange}\r\n              onBlur={this.onRunQuery}\r\n            />\r\n          </div>\r\n\r\n          <div className=\"gf-form\">\r\n            <FormLabel\r\n              width={7}\r\n              tooltip={\r\n                <>\r\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\r\n                  <code>$__interval</code> variable. The limit is absolute and not modified by the \"Resolution\" setting.\r\n                </>\r\n              }\r\n            >\r\n              Min step\r\n            </FormLabel>\r\n            <input\r\n              type=\"text\"\r\n              className=\"gf-form-input width-8\"\r\n              placeholder={interval}\r\n              onChange={this.onIntervalChange}\r\n              onBlur={this.onRunQuery}\r\n              value={interval}\r\n            />\r\n          </div>\r\n\r\n          <div className=\"gf-form\">\r\n            <div className=\"gf-form-label\">Resolution</div>\r\n            <Select\r\n              isSearchable={false}\r\n              options={INTERVAL_FACTOR_OPTIONS}\r\n              onChange={this.onIntervalFactorChange}\r\n              value={intervalFactorOption}\r\n            />\r\n          </div>\r\n\r\n          <div className=\"gf-form\">\r\n            <div className=\"gf-form-label\">Format</div>\r\n            <Select isSearchable={false} options={FORMAT_OPTIONS} onChange={this.onFormatChange} value={formatOption} />\r\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\r\n\r\n            <FormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\r\n              <PromLink\r\n                datasource={datasource}\r\n                query={this.query} // Use modified query\r\n                panelData={data}\r\n              />\r\n            </FormLabel>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport React from 'react';\r\n\r\nimport { Plugin } from 'slate';\r\nimport {\r\n  ButtonCascader,\r\n  CascaderOption,\r\n  SlatePrism,\r\n  TypeaheadInput,\r\n  TypeaheadOutput,\r\n  QueryField,\r\n  BracesPlugin,\r\n} from '@grafana/ui';\r\n\r\nimport Prism from 'prismjs';\r\n\r\n// dom also includes Element polyfills\r\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\r\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\r\nimport { ExploreQueryFieldProps, QueryHint, isDataFrame, toLegacyResponseData, HistoryItem } from '@grafana/data';\r\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\r\nimport { PrometheusDatasource } from '../datasource';\r\nimport PromQlLanguageProvider from '../language_provider';\r\n\r\nconst HISTOGRAM_GROUP = '__histograms__';\r\nconst PRISM_SYNTAX = 'promql';\r\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\r\n\r\nfunction getChooserText(hasSyntax: boolean, metrics: string[]) {\r\n  if (!hasSyntax) {\r\n    return 'Loading metrics...';\r\n  }\r\n  if (metrics && metrics.length === 0) {\r\n    return '(No metrics found)';\r\n  }\r\n  return 'Metrics';\r\n}\r\n\r\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\r\n  const option: CascaderOption = { label: metric, value: metric };\r\n  if (metadata && metadata[metric]) {\r\n    const { type = '', help } = metadata[metric][0];\r\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\r\n  }\r\n  return option;\r\n}\r\n\r\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\r\n  // Filter out recording rules and insert as first option\r\n  const ruleRegex = /:\\w+:/;\r\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\r\n  const rulesOption = {\r\n    label: 'Recording rules',\r\n    value: RECORDING_RULES_GROUP,\r\n    children: ruleNames\r\n      .slice()\r\n      .sort()\r\n      .map(name => ({ label: name, value: name })),\r\n  };\r\n\r\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\r\n\r\n  const delimiter = '_';\r\n  const metricsOptions = _.chain(metrics)\r\n    .filter((metric: string) => !ruleRegex.test(metric))\r\n    .groupBy((metric: string) => metric.split(delimiter)[0])\r\n    .map(\r\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\r\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\r\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => addMetricsMetadata(m, metadata));\r\n        return {\r\n          children,\r\n          label: prefix,\r\n          value: prefix,\r\n        };\r\n      }\r\n    )\r\n    .sortBy('label')\r\n    .value();\r\n\r\n  return [...options, ...metricsOptions];\r\n}\r\n\r\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\r\n  // Modify suggestion based on context\r\n  switch (typeaheadContext) {\r\n    case 'context-labels': {\r\n      const nextChar = DOMUtil.getNextCharacter();\r\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\r\n        suggestion += '=';\r\n      }\r\n      break;\r\n    }\r\n\r\n    case 'context-label-values': {\r\n      // Always add quotes and remove existing ones instead\r\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\r\n        suggestion = `\"${suggestion}`;\r\n      }\r\n      if (DOMUtil.getNextCharacter() !== '\"') {\r\n        suggestion = `${suggestion}\"`;\r\n      }\r\n      break;\r\n    }\r\n\r\n    default:\r\n  }\r\n  return suggestion;\r\n}\r\n\r\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\r\n  history: Array<HistoryItem<PromQuery>>;\r\n}\r\n\r\ninterface PromQueryFieldState {\r\n  metricsOptions: any[];\r\n  syntaxLoaded: boolean;\r\n  hint: QueryHint | null;\r\n}\r\n\r\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\r\n  plugins: Plugin[];\r\n  languageProvider: PromQlLanguageProvider;\r\n  languageProviderInitializationPromise: CancelablePromise<any>;\r\n\r\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\r\n    super(props, context);\r\n\r\n    if (props.datasource.languageProvider) {\r\n      this.languageProvider = props.datasource.languageProvider;\r\n    }\r\n\r\n    this.plugins = [\r\n      BracesPlugin(),\r\n      SlatePrism({\r\n        onlyIn: (node: any) => node.type === 'code_block',\r\n        getSyntax: (node: any) => 'promql',\r\n      }),\r\n    ];\r\n\r\n    this.state = {\r\n      metricsOptions: [],\r\n      syntaxLoaded: false,\r\n      hint: null,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    if (this.languageProvider) {\r\n      Prism.languages[PRISM_SYNTAX] = this.languageProvider.syntax;\r\n      this.refreshMetrics(makePromiseCancelable(this.languageProvider.start()));\r\n    }\r\n    this.refreshHint();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.languageProviderInitializationPromise) {\r\n      this.languageProviderInitializationPromise.cancel();\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\r\n    const { data } = this.props;\r\n\r\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\r\n      this.refreshHint();\r\n    }\r\n  }\r\n\r\n  refreshHint = () => {\r\n    const { datasource, query, data } = this.props;\r\n\r\n    if (!data || data.series.length === 0) {\r\n      this.setState({ hint: null });\r\n      return;\r\n    }\r\n\r\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\r\n    const hints = datasource.getQueryHints(query, result);\r\n    const hint = hints && hints.length > 0 ? hints[0] : null;\r\n    this.setState({ hint });\r\n  };\r\n\r\n  refreshMetrics = (cancelablePromise: CancelablePromise<any>) => {\r\n    this.languageProviderInitializationPromise = cancelablePromise;\r\n    this.languageProviderInitializationPromise.promise\r\n      .then(remaining => {\r\n        remaining.map((task: Promise<any>) => task.then(this.onUpdateLanguage).catch(() => {}));\r\n      })\r\n      .then(() => this.onUpdateLanguage())\r\n      .catch(({ isCanceled }) => {\r\n        if (isCanceled) {\r\n          console.warn('PromQueryField has unmounted, language provider intialization was canceled');\r\n        }\r\n      });\r\n  };\r\n\r\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\r\n    let query;\r\n    if (selectedOptions.length === 1) {\r\n      if (selectedOptions[0].children.length === 0) {\r\n        query = selectedOptions[0].value;\r\n      } else {\r\n        // Ignore click on group\r\n        return;\r\n      }\r\n    } else {\r\n      const prefix = selectedOptions[0].value;\r\n      const metric = selectedOptions[1].value;\r\n      if (prefix === HISTOGRAM_GROUP) {\r\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\r\n      } else {\r\n        query = metric;\r\n      }\r\n    }\r\n    this.onChangeQuery(query, true);\r\n  };\r\n\r\n  onChangeQuery = (value: string, override?: boolean) => {\r\n    // Send text change to parent\r\n    const { query, onChange, onRunQuery } = this.props;\r\n    if (onChange) {\r\n      const nextQuery: PromQuery = { ...query, expr: value };\r\n      onChange(nextQuery);\r\n\r\n      if (override && onRunQuery) {\r\n        onRunQuery();\r\n      }\r\n    }\r\n  };\r\n\r\n  onClickHintFix = () => {\r\n    const { datasource, query, onChange, onRunQuery } = this.props;\r\n    const { hint } = this.state;\r\n\r\n    onChange(datasource.modifyQuery(query, hint.fix.action));\r\n    onRunQuery();\r\n  };\r\n\r\n  onUpdateLanguage = () => {\r\n    const {\r\n      histogramMetrics,\r\n      metrics,\r\n      metricsMetadata,\r\n      lookupsDisabled,\r\n      lookupMetricsThreshold,\r\n    } = this.languageProvider;\r\n    if (!metrics) {\r\n      return;\r\n    }\r\n\r\n    // Build metrics tree\r\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\r\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\r\n    const metricsOptions =\r\n      histogramMetrics.length > 0\r\n        ? [\r\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\r\n            ...metricsByPrefix,\r\n          ]\r\n        : metricsByPrefix;\r\n\r\n    // Hint for big disabled lookups\r\n    let hint: QueryHint;\r\n    if (lookupsDisabled) {\r\n      hint = {\r\n        label: `Dynamic label lookup is disabled for datasources with more than ${lookupMetricsThreshold} metrics.`,\r\n        type: 'INFO',\r\n      };\r\n    }\r\n\r\n    this.setState({ hint, metricsOptions, syntaxLoaded: true });\r\n  };\r\n\r\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\r\n    if (!this.languageProvider) {\r\n      return { suggestions: [] };\r\n    }\r\n\r\n    const { history } = this.props;\r\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\r\n\r\n    const result = await this.languageProvider.provideCompletionItems(\r\n      { text, value, prefix, wrapperClasses, labelKey },\r\n      { history }\r\n    );\r\n\r\n    // console.log('handleTypeahead', wrapperClasses, text, prefix, labelKey, result.context);\r\n\r\n    return result;\r\n  };\r\n\r\n  render() {\r\n    const { data, query, children } = this.props;\r\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\r\n    const cleanText = this.languageProvider ? this.languageProvider.cleanText : undefined;\r\n    const chooserText = getChooserText(syntaxLoaded, metricsOptions);\r\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\r\n    const showError = data && data.error && data.error.refId === query.refId;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"gf-form-inline gf-form-inline--nowrap flex-grow-1\">\r\n          <div className=\"gf-form flex-shrink-0\">\r\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\r\n              {chooserText}\r\n            </ButtonCascader>\r\n          </div>\r\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\r\n            <QueryField\r\n              additionalPlugins={this.plugins}\r\n              cleanText={cleanText}\r\n              query={query.expr}\r\n              onTypeahead={this.onTypeahead}\r\n              onWillApplySuggestion={willApplySuggestion}\r\n              onBlur={this.props.onBlur}\r\n              onChange={this.onChangeQuery}\r\n              onRunQuery={this.props.onRunQuery}\r\n              placeholder=\"Enter a PromQL query\"\r\n              portalOrigin=\"prometheus\"\r\n              syntaxLoaded={syntaxLoaded}\r\n            />\r\n          </div>\r\n          {children}\r\n        </div>\r\n        {showError ? (\r\n          <div className=\"query-row-break\">\r\n            <div className=\"prom-query-field-info text-error\">{data.error.message}</div>\r\n          </div>\r\n        ) : null}\r\n        {hint ? (\r\n          <div className=\"query-row-break\">\r\n            <div className=\"prom-query-field-info text-warning\">\r\n              {hint.label}{' '}\r\n              {hint.fix ? (\r\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\r\n                  {hint.fix.label}\r\n                </a>\r\n              ) : null}\r\n            </div>\r\n          </div>\r\n        ) : null}\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PromQueryField;\r\n","import React from 'react';\r\nimport { DataSourceHttpSettings } from '@grafana/ui';\r\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\r\nimport { PromSettings } from './PromSettings';\r\nimport { PromOptions } from '../types';\r\n\r\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\r\nexport const ConfigEditor = (props: Props) => {\r\n  const { options, onOptionsChange } = props;\r\n  return (\r\n    <>\r\n      <DataSourceHttpSettings\r\n        defaultUrl=\"http://localhost:9090\"\r\n        dataSourceConfig={options}\r\n        onChange={onOptionsChange}\r\n      />\r\n\r\n      <PromSettings value={options} onChange={onOptionsChange} />\r\n    </>\r\n  );\r\n};\r\n","import React, { SyntheticEvent } from 'react';\r\nimport { EventsWithValidation, FormField, FormLabel, Input, regexValidation, Select } from '@grafana/ui';\r\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\r\nimport { PromOptions } from '../types';\r\n\r\nconst httpOptions = [\r\n  { value: 'GET', label: 'GET' },\r\n  { value: 'POST', label: 'POST' },\r\n];\r\n\r\ntype Props = {\r\n  value: DataSourceSettings<PromOptions>;\r\n  onChange: (value: DataSourceSettings<PromOptions>) => void;\r\n};\r\n\r\nexport const PromSettings = (props: Props) => {\r\n  const { value, onChange } = props;\r\n\r\n  return (\r\n    <>\r\n      <div className=\"gf-form-group\">\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form\">\r\n            <FormField\r\n              label=\"Scrape interval\"\r\n              labelWidth={13}\r\n              placeholder=\"15s\"\r\n              inputEl={\r\n                <Input\r\n                  className=\"width-6\"\r\n                  value={value.jsonData.timeInterval}\r\n                  spellCheck={false}\r\n                  onChange={onChangeHandler('timeInterval', value, onChange)}\r\n                  validationEvents={promSettingsValidationEvents}\r\n                />\r\n              }\r\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\r\n            />\r\n          </div>\r\n        </div>\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form\">\r\n            <FormField\r\n              label=\"Query timeout\"\r\n              labelWidth={13}\r\n              inputEl={\r\n                <Input\r\n                  className=\"width-6\"\r\n                  value={value.jsonData.queryTimeout}\r\n                  onChange={onChangeHandler('queryTimeout', value, onChange)}\r\n                  spellCheck={false}\r\n                  placeholder=\"60s\"\r\n                  validationEvents={promSettingsValidationEvents}\r\n                />\r\n              }\r\n              tooltip=\"Set the Prometheus query timeout.\"\r\n            />\r\n          </div>\r\n        </div>\r\n        <div className=\"gf-form\">\r\n          <FormLabel\r\n            width={13}\r\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\r\n          >\r\n            HTTP Method\r\n          </FormLabel>\r\n          <Select\r\n            options={httpOptions}\r\n            value={httpOptions.find(o => o.value === value.jsonData.httpMethod)}\r\n            onChange={onChangeHandler('httpMethod', value, onChange)}\r\n            width={7}\r\n          />\r\n        </div>\r\n      </div>\r\n      <h3 className=\"page-heading\">Misc</h3>\r\n      <div className=\"gf-form-group\">\r\n        <div className=\"gf-form-inline\">\r\n          <div className=\"gf-form max-width-30\">\r\n            <FormField\r\n              label=\"Custom query parameters\"\r\n              labelWidth={14}\r\n              tooltip=\"Add Custom parameters to Prometheus or Thanos queries.\"\r\n              inputEl={\r\n                <Input\r\n                  className=\"width-25\"\r\n                  value={value.jsonData.customQueryParameters}\r\n                  onChange={onChangeHandler('customQueryParameters', value, onChange)}\r\n                  spellCheck={false}\r\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\r\n                />\r\n              }\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport const promSettingsValidationEvents = {\r\n  [EventsWithValidation.onBlur]: [\r\n    regexValidation(\r\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\r\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\r\n    ),\r\n  ],\r\n};\r\n\r\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\r\n  if (!eventItem) {\r\n    return '';\r\n  }\r\n\r\n  if (eventItem.hasOwnProperty('currentTarget')) {\r\n    return eventItem.currentTarget.value;\r\n  }\r\n\r\n  return (eventItem as SelectableValue<string>).value;\r\n};\r\n\r\nconst onChangeHandler = (key: keyof PromOptions, value: Props['value'], onChange: Props['onChange']) => (\r\n  eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>\r\n) => {\r\n  onChange({\r\n    ...value,\r\n    jsonData: {\r\n      ...value.jsonData,\r\n      [key]: getValueFromEventItem(eventItem),\r\n    },\r\n  });\r\n};\r\n","// Libraries\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport defaults from 'lodash/defaults';\r\nimport $ from 'jquery';\r\n// Services & Utils\r\nimport kbn from 'app/core/utils/kbn';\r\nimport {\r\n  AnnotationEvent,\r\n  dateMath,\r\n  DateTime,\r\n  LoadingState,\r\n  TimeRange,\r\n  TimeSeries,\r\n  CoreApp,\r\n  DataQueryError,\r\n  DataQueryRequest,\r\n  DataQueryResponse,\r\n  DataQueryResponseData,\r\n  DataSourceApi,\r\n  DataSourceInstanceSettings,\r\n  ScopedVars,\r\n} from '@grafana/data';\r\nimport { from, merge, Observable, of, forkJoin } from 'rxjs';\r\nimport { filter, map, tap } from 'rxjs/operators';\r\n\r\nimport PrometheusMetricFindQuery from './metric_find_query';\r\nimport { ResultTransformer } from './result_transformer';\r\nimport PrometheusLanguageProvider from './language_provider';\r\nimport { getBackendSrv } from 'app/core/services/backend_srv';\r\nimport addLabelToQuery from './add_label_to_query';\r\nimport { getQueryHints } from './query_hints';\r\nimport { expandRecordingRules } from './language_utils';\r\n// Types\r\nimport { PromOptions, PromQuery, PromQueryRequest } from './types';\r\nimport { safeStringifyValue } from 'app/core/utils/explore';\r\nimport templateSrv from 'app/features/templating/template_srv';\r\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\nimport TableModel from 'app/core/table_model';\r\n\r\ninterface RequestOptions {\r\n  method?: string;\r\n  url?: string;\r\n  headers?: Record<string, string>;\r\n  transformRequest?: (data: any) => string;\r\n  data?: any;\r\n  withCredentials?: boolean;\r\n  silent?: boolean;\r\n  requestId?: string;\r\n}\r\n\r\nexport interface PromDataQueryResponse {\r\n  data: {\r\n    status: string;\r\n    data: {\r\n      resultType: string;\r\n      results?: DataQueryResponseData[];\r\n      result?: DataQueryResponseData[];\r\n    };\r\n  };\r\n  cancelled?: boolean;\r\n}\r\n\r\nexport interface PromLabelQueryResponse {\r\n  data: {\r\n    status: string;\r\n    data: string[];\r\n  };\r\n  cancelled?: boolean;\r\n}\r\n\r\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\r\n  type: string;\r\n  editorSrc: string;\r\n  ruleMappings: { [index: string]: string };\r\n  url: string;\r\n  directUrl: string;\r\n  basicAuth: any;\r\n  withCredentials: any;\r\n  metricsNameCache: any;\r\n  interval: string;\r\n  queryTimeout: string;\r\n  httpMethod: string;\r\n  languageProvider: PrometheusLanguageProvider;\r\n  resultTransformer: ResultTransformer;\r\n  customQueryParameters: any;\r\n\r\n  constructor(instanceSettings: DataSourceInstanceSettings<PromOptions>) {\r\n    super(instanceSettings);\r\n\r\n    this.type = 'prometheus';\r\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\r\n    this.url = instanceSettings.url;\r\n    this.basicAuth = instanceSettings.basicAuth;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\r\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\r\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\r\n    this.directUrl = instanceSettings.jsonData.directUrl;\r\n    this.resultTransformer = new ResultTransformer(templateSrv);\r\n    this.ruleMappings = {};\r\n    this.languageProvider = new PrometheusLanguageProvider(this);\r\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\r\n  }\r\n\r\n  init = () => {\r\n    this.loadRules();\r\n  };\r\n\r\n  getQueryDisplayText(query: PromQuery) {\r\n    return query.expr;\r\n  }\r\n\r\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\r\n    httpOptions.headers = {};\r\n    const proxyMode = !this.url.match(/^http/);\r\n    if (proxyMode) {\r\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\r\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\r\n    }\r\n  }\r\n\r\n  _request(url: string, data: Record<string, string> = {}, options?: RequestOptions) {\r\n    options = defaults(options || {}, {\r\n      url: this.url + url,\r\n      method: this.httpMethod,\r\n      headers: {},\r\n    });\r\n\r\n    if (options.method === 'GET') {\r\n      if (data && Object.keys(data).length) {\r\n        options.url =\r\n          options.url +\r\n          '?' +\r\n          Object.entries(data)\r\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\r\n            .join('&');\r\n      }\r\n    } else {\r\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n      options.transformRequest = (data: any) => $.param(data);\r\n      options.data = data;\r\n    }\r\n\r\n    if (this.basicAuth || this.withCredentials) {\r\n      options.withCredentials = true;\r\n    }\r\n\r\n    if (this.basicAuth) {\r\n      options.headers.Authorization = this.basicAuth;\r\n    }\r\n\r\n    return getBackendSrv().datasourceRequest(options as Required<RequestOptions>);\r\n  }\r\n\r\n  // Use this for tab completion features, wont publish response to other components\r\n  metadataRequest(url: string) {\r\n    return this._request(url, null, { method: 'GET', silent: true });\r\n  }\r\n\r\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\r\n    // if no multi or include all do not regexEscape\r\n    if (!variable.multi && !variable.includeAll) {\r\n      return prometheusRegularEscape(value);\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return prometheusSpecialRegexEscape(value);\r\n    }\r\n\r\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\r\n    return escapedValues.join('|');\r\n  }\r\n\r\n  targetContainsTemplate(target: PromQuery) {\r\n    return templateSrv.variableExists(target.expr);\r\n  }\r\n\r\n  processResult = (response: any, query: PromQueryRequest, target: PromQuery, responseListLength: number) => {\r\n    // Keeping original start/end for transformers\r\n    const transformerOptions = {\r\n      format: target.format,\r\n      step: query.step,\r\n      legendFormat: target.legendFormat,\r\n      start: query.start,\r\n      end: query.end,\r\n      query: query.expr,\r\n      responseListLength,\r\n      refId: target.refId,\r\n      valueWithRefId: target.valueWithRefId,\r\n    };\r\n    const series = this.resultTransformer.transform(response, transformerOptions);\r\n\r\n    return series;\r\n  };\r\n\r\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\r\n    const queries: PromQueryRequest[] = [];\r\n    const activeTargets: PromQuery[] = [];\r\n\r\n    for (const target of options.targets) {\r\n      if (!target.expr || target.hide) {\r\n        continue;\r\n      }\r\n\r\n      target.requestId = options.panelId + target.refId;\r\n\r\n      if (options.app !== CoreApp.Explore) {\r\n        activeTargets.push(target);\r\n        queries.push(this.createQuery(target, options, start, end));\r\n        continue;\r\n      }\r\n\r\n      if (target.showingTable) {\r\n        // create instant target only if Table is showed in Explore\r\n        const instantTarget: any = cloneDeep(target);\r\n        instantTarget.format = 'table';\r\n        instantTarget.instant = true;\r\n        instantTarget.valueWithRefId = true;\r\n        delete instantTarget.maxDataPoints;\r\n        instantTarget.requestId += '_instant';\r\n\r\n        activeTargets.push(instantTarget);\r\n        queries.push(this.createQuery(instantTarget, options, start, end));\r\n      }\r\n\r\n      if (target.showingGraph) {\r\n        // create time series target only if Graph is showed in Explore\r\n        target.format = 'time_series';\r\n        target.instant = false;\r\n\r\n        activeTargets.push(target);\r\n        queries.push(this.createQuery(target, options, start, end));\r\n      }\r\n    }\r\n\r\n    return {\r\n      queries,\r\n      activeTargets,\r\n    };\r\n  };\r\n\r\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\r\n    const start = this.getPrometheusTime(options.range.from, false);\r\n    const end = this.getPrometheusTime(options.range.to, true);\r\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\r\n\r\n    // No valid targets, return the empty result to save a round trip.\r\n    if (!queries || !queries.length) {\r\n      return of({\r\n        data: [],\r\n        state: LoadingState.Done,\r\n      });\r\n    }\r\n\r\n    if (options.app === CoreApp.Explore) {\r\n      return this.exploreQuery(queries, activeTargets, end);\r\n    }\r\n\r\n    return this.panelsQuery(queries, activeTargets, end, options.requestId);\r\n  }\r\n\r\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\r\n    let runningQueriesCount = queries.length;\r\n    const subQueries = queries.map((query, index) => {\r\n      const target = activeTargets[index];\r\n      let observable: Observable<any> = null;\r\n\r\n      if (query.instant) {\r\n        observable = from(this.performInstantQuery(query, end));\r\n      } else {\r\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\r\n      }\r\n\r\n      return observable.pipe(\r\n        // Decrease the counter here. We assume that each request returns only single value and then completes\r\n        // (should hold until there is some streaming requests involved).\r\n        tap(() => runningQueriesCount--),\r\n        filter((response: any) => (response.cancelled ? false : true)),\r\n        map((response: any) => {\r\n          const data = this.processResult(response, query, target, queries.length);\r\n          return {\r\n            data,\r\n            key: query.requestId,\r\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\r\n          } as DataQueryResponse;\r\n        })\r\n      );\r\n    });\r\n\r\n    return merge(...subQueries);\r\n  }\r\n\r\n  private panelsQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number, requestId: string) {\r\n    const observables: Array<Observable<Array<TableModel | TimeSeries>>> = queries.map((query, index) => {\r\n      const target = activeTargets[index];\r\n      let observable: Observable<any> = null;\r\n\r\n      if (query.instant) {\r\n        observable = from(this.performInstantQuery(query, end));\r\n      } else {\r\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\r\n      }\r\n\r\n      return observable.pipe(\r\n        filter((response: any) => (response.cancelled ? false : true)),\r\n        map((response: any) => {\r\n          const data = this.processResult(response, query, target, queries.length);\r\n          return data;\r\n        })\r\n      );\r\n    });\r\n\r\n    return forkJoin(observables).pipe(\r\n      map((results: Array<Array<TableModel | TimeSeries>>) => {\r\n        const data = results.reduce((result, current) => {\r\n          return [...result, ...current];\r\n        }, []);\r\n        return {\r\n          data,\r\n          key: requestId,\r\n          state: LoadingState.Done,\r\n        };\r\n      })\r\n    );\r\n  }\r\n\r\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\r\n    const query: PromQueryRequest = {\r\n      hinting: target.hinting,\r\n      instant: target.instant,\r\n      step: 0,\r\n      expr: '',\r\n      requestId: target.requestId,\r\n      refId: target.refId,\r\n      start: 0,\r\n      end: 0,\r\n    };\r\n    const range = Math.ceil(end - start);\r\n\r\n    // options.interval is the dynamically calculated interval\r\n    let interval = kbn.interval_to_seconds(options.interval);\r\n    // Minimum interval (\"Min step\"), if specified for the query or datasource. or same as interval otherwise\r\n    const minInterval = kbn.interval_to_seconds(\r\n      templateSrv.replace(target.interval, options.scopedVars) || options.interval\r\n    );\r\n    const intervalFactor = target.intervalFactor || 1;\r\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\r\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\r\n    let scopedVars = { ...options.scopedVars, ...this.getRangeScopedVars(options.range) };\r\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\r\n    if (interval !== adjustedInterval) {\r\n      interval = adjustedInterval;\r\n      scopedVars = Object.assign({}, options.scopedVars, {\r\n        __interval: { text: interval + 's', value: interval + 's' },\r\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\r\n        ...this.getRangeScopedVars(options.range),\r\n      });\r\n    }\r\n    query.step = interval;\r\n\r\n    let expr = target.expr;\r\n\r\n    // Apply adhoc filters\r\n    const adhocFilters = templateSrv.getAdhocFilters(this.name);\r\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\r\n      const { key, operator } = filter;\r\n      let { value } = filter;\r\n      if (operator === '=~' || operator === '!~') {\r\n        value = prometheusRegularEscape(value);\r\n      }\r\n      return addLabelToQuery(acc, key, value, operator);\r\n    }, expr);\r\n\r\n    // Only replace vars in expression after having (possibly) updated interval vars\r\n    query.expr = templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\r\n\r\n    // Align query interval with step to allow query caching and to ensure\r\n    // that about-same-time query results look the same.\r\n    const adjusted = alignRange(\r\n      start,\r\n      end,\r\n      query.step,\r\n      getTimeSrv()\r\n        .timeRange()\r\n        .to.utcOffset() * 60\r\n    );\r\n    query.start = adjusted.start;\r\n    query.end = adjusted.end;\r\n    this._addTracingHeaders(query, options);\r\n\r\n    return query;\r\n  }\r\n\r\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\r\n    // Prometheus will drop queries that might return more than 11000 data points.\r\n    // Calculate a safe interval as an additional minimum to take into account.\r\n    const safeInterval = Math.ceil(range / 11000);\r\n    return Math.max(interval * intervalFactor, minInterval, safeInterval, 1);\r\n  }\r\n\r\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\r\n    if (start > end) {\r\n      throw { message: 'Invalid time range' };\r\n    }\r\n\r\n    const url = '/api/v1/query_range';\r\n    const data: any = {\r\n      query: query.expr,\r\n      start,\r\n      end,\r\n      step: query.step,\r\n    };\r\n\r\n    if (this.queryTimeout) {\r\n      data['timeout'] = this.queryTimeout;\r\n    }\r\n\r\n    for (const [key, value] of this.customQueryParameters) {\r\n      if (data[key] == null) {\r\n        data[key] = value;\r\n      }\r\n    }\r\n\r\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\r\n      if (err.cancelled) {\r\n        return err;\r\n      }\r\n\r\n      throw this.handleErrors(err, query);\r\n    });\r\n  }\r\n\r\n  performInstantQuery(query: PromQueryRequest, time: number) {\r\n    const url = '/api/v1/query';\r\n    const data: any = {\r\n      query: query.expr,\r\n      time,\r\n    };\r\n\r\n    if (this.queryTimeout) {\r\n      data['timeout'] = this.queryTimeout;\r\n    }\r\n\r\n    for (const [key, value] of this.customQueryParameters) {\r\n      if (data[key] == null) {\r\n        data[key] = value;\r\n      }\r\n    }\r\n\r\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\r\n      if (err.cancelled) {\r\n        return err;\r\n      }\r\n\r\n      throw this.handleErrors(err, query);\r\n    });\r\n  }\r\n\r\n  handleErrors = (err: any, target: PromQuery) => {\r\n    const error: DataQueryError = {\r\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\r\n      refId: target.refId,\r\n    };\r\n\r\n    if (err.data) {\r\n      if (typeof err.data === 'string') {\r\n        error.message = err.data;\r\n      } else if (err.data.error) {\r\n        error.message = safeStringifyValue(err.data.error);\r\n      }\r\n    } else if (err.message) {\r\n      error.message = err.message;\r\n    } else if (typeof err === 'string') {\r\n      error.message = err;\r\n    }\r\n\r\n    error.status = err.status;\r\n    error.statusText = err.statusText;\r\n\r\n    return error;\r\n  };\r\n\r\n  async performSuggestQuery(query: string, cache = false) {\r\n    if (cache && this.metricsNameCache?.expire > Date.now()) {\r\n      return this.metricsNameCache.data.filter((metricName: any) => metricName.indexOf(query) !== 1);\r\n    }\r\n\r\n    const response: PromLabelQueryResponse = await this.metadataRequest('/api/v1/label/__name__/values');\r\n    this.metricsNameCache = {\r\n      data: response.data.data,\r\n      expire: Date.now() + 60 * 1000,\r\n    };\r\n\r\n    return response.data.data.filter(metricName => metricName.indexOf(query) !== 1);\r\n  }\r\n\r\n  metricFindQuery(query: string) {\r\n    if (!query) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    const scopedVars = {\r\n      __interval: { text: this.interval, value: this.interval },\r\n      __interval_ms: { text: kbn.interval_to_ms(this.interval), value: kbn.interval_to_ms(this.interval) },\r\n      ...this.getRangeScopedVars(getTimeSrv().timeRange()),\r\n    };\r\n    const interpolated = templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\r\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\r\n    return metricFindQuery.process();\r\n  }\r\n\r\n  getRangeScopedVars(range: TimeRange = getTimeSrv().timeRange()) {\r\n    const msRange = range.to.diff(range.from);\r\n    const sRange = Math.round(msRange / 1000);\r\n    const regularRange = kbn.secondsToHms(msRange / 1000);\r\n    return {\r\n      __range_ms: { text: msRange, value: msRange },\r\n      __range_s: { text: sRange, value: sRange },\r\n      __range: { text: regularRange, value: regularRange },\r\n    };\r\n  }\r\n\r\n  async annotationQuery(options: any) {\r\n    const annotation = options.annotation;\r\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '', step = '60s' } = annotation;\r\n\r\n    if (!expr) {\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    const start = this.getPrometheusTime(options.range.from, false);\r\n    const end = this.getPrometheusTime(options.range.to, true);\r\n    const queryOptions = {\r\n      ...options,\r\n      interval: step,\r\n    };\r\n\r\n    // Unsetting min interval for accurate event resolution\r\n    const minStep = '1s';\r\n    const queryModel = {\r\n      expr,\r\n      interval: minStep,\r\n      refId: 'X',\r\n      requestId: `prom-query-${annotation.name}`,\r\n    };\r\n\r\n    const query = this.createQuery(queryModel, queryOptions, start, end);\r\n\r\n    const self = this;\r\n    const response: PromDataQueryResponse = await this.performTimeSeriesQuery(query, query.start, query.end);\r\n    const eventList: AnnotationEvent[] = [];\r\n    const splitKeys = tagKeys.split(',');\r\n\r\n    if (response.cancelled) {\r\n      return [];\r\n    }\r\n\r\n    response?.data?.data?.result?.forEach(series => {\r\n      const tags = Object.entries(series.metric)\r\n        .filter(([k]) => splitKeys.includes(k))\r\n        .map(([_k, v]: [string, string]) => v);\r\n\r\n      const dupCheck: Record<number, boolean> = {};\r\n      for (const value of series.values) {\r\n        const valueIsTrue = value[1] === '1'; // e.g. ALERTS\r\n        if (valueIsTrue || annotation.useValueForTime) {\r\n          const event: AnnotationEvent = {\r\n            annotation,\r\n            title: self.resultTransformer.renderTemplate(titleFormat, series.metric),\r\n            tags,\r\n            text: self.resultTransformer.renderTemplate(textFormat, series.metric),\r\n          };\r\n\r\n          if (annotation.useValueForTime) {\r\n            const timestampValue = Math.floor(parseFloat(value[1]));\r\n            if (dupCheck[timestampValue]) {\r\n              continue;\r\n            }\r\n            dupCheck[timestampValue] = true;\r\n            event.time = timestampValue;\r\n          } else {\r\n            event.time = Math.floor(parseFloat(value[0])) * 1000;\r\n          }\r\n\r\n          eventList.push(event);\r\n        }\r\n      }\r\n    });\r\n\r\n    return eventList;\r\n  }\r\n\r\n  async getTagKeys() {\r\n    const result = await this.metadataRequest('/api/v1/labels');\r\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\r\n  }\r\n\r\n  async getTagValues(options: any = {}) {\r\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\r\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\r\n  }\r\n\r\n  async testDatasource() {\r\n    const now = new Date().getTime();\r\n    const query = { expr: '1+1' } as PromQueryRequest;\r\n    const response = await this.performInstantQuery(query, now / 1000);\r\n    return response.data.status === 'success'\r\n      ? { status: 'success', message: 'Data source is working' }\r\n      : { status: 'error', message: response.error };\r\n  }\r\n\r\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\r\n    let expandedQueries = queries;\r\n    if (queries && queries.length) {\r\n      expandedQueries = queries.map(query => {\r\n        const expandedQuery = {\r\n          ...query,\r\n          datasource: this.name,\r\n          expr: templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\r\n        };\r\n        return expandedQuery;\r\n      });\r\n    }\r\n    return expandedQueries;\r\n  }\r\n\r\n  getQueryHints(query: PromQuery, result: any[]) {\r\n    return getQueryHints(query.expr ?? '', result, this);\r\n  }\r\n\r\n  async loadRules() {\r\n    try {\r\n      const res = await this.metadataRequest('/api/v1/rules');\r\n      const body = res.data || res.json();\r\n\r\n      const groups = body?.data?.groups;\r\n      if (groups) {\r\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\r\n      }\r\n    } catch (e) {\r\n      console.log('Rules API is experimental. Ignore next error.');\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  modifyQuery(query: PromQuery, action: any): PromQuery {\r\n    let expression = query.expr ?? '';\r\n    switch (action.type) {\r\n      case 'ADD_FILTER': {\r\n        expression = addLabelToQuery(expression, action.key, action.value);\r\n        break;\r\n      }\r\n      case 'ADD_HISTOGRAM_QUANTILE': {\r\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\r\n        break;\r\n      }\r\n      case 'ADD_RATE': {\r\n        expression = `rate(${expression}[5m])`;\r\n        break;\r\n      }\r\n      case 'ADD_SUM': {\r\n        expression = `sum(${expression.trim()}) by ($1)`;\r\n        break;\r\n      }\r\n      case 'EXPAND_RULES': {\r\n        if (action.mapping) {\r\n          expression = expandRecordingRules(expression, action.mapping);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n    return { ...query, expr: expression };\r\n  }\r\n\r\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\r\n    if (typeof date === 'string') {\r\n      date = dateMath.parse(date, roundUp);\r\n    }\r\n\r\n    return Math.ceil(date.valueOf() / 1000);\r\n  }\r\n\r\n  getTimeRange(): { start: number; end: number } {\r\n    const range = getTimeSrv().timeRange();\r\n    return {\r\n      start: this.getPrometheusTime(range.from, false),\r\n      end: this.getPrometheusTime(range.to, true),\r\n    };\r\n  }\r\n\r\n  getOriginalMetricName(labelData: { [key: string]: string }) {\r\n    return this.resultTransformer.getOriginalMetricName(labelData);\r\n  }\r\n}\r\n\r\n/**\r\n * Align query range to step.\r\n * Rounds start and end down to a multiple of step.\r\n * @param start Timestamp marking the beginning of the range.\r\n * @param end Timestamp marking the end of the range.\r\n * @param step Interval to align start and end with.\r\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\r\n */\r\nexport function alignRange(\r\n  start: number,\r\n  end: number,\r\n  step: number,\r\n  utcOffsetSec: number\r\n): { end: number; start: number } {\r\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\r\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\r\n  return {\r\n    end: alignedEnd,\r\n    start: alignedStart,\r\n  };\r\n}\r\n\r\nexport function extractRuleMappingFromGroups(groups: any[]) {\r\n  return groups.reduce(\r\n    (mapping, group) =>\r\n      group.rules\r\n        .filter((rule: any) => rule.type === 'recording')\r\n        .reduce(\r\n          (acc: { [key: string]: string }, rule: any) => ({\r\n            ...acc,\r\n            [rule.name]: rule.query,\r\n          }),\r\n          mapping\r\n        ),\r\n    {}\r\n  );\r\n}\r\n\r\nexport function prometheusRegularEscape(value: any) {\r\n  return typeof value === 'string' ? value.replace(/'/g, \"\\\\\\\\'\") : value;\r\n}\r\n\r\nexport function prometheusSpecialRegexEscape(value: any) {\r\n  return typeof value === 'string'\r\n    ? prometheusRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'))\r\n    : value;\r\n}\r\n","import _ from 'lodash';\r\nimport LRU from 'lru-cache';\r\nimport { Value } from 'slate';\r\n\r\nimport { dateTime, LanguageProvider, HistoryItem } from '@grafana/data';\r\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\r\n\r\nimport { parseSelector, processLabels, processHistogramLabels } from './language_utils';\r\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\r\n\r\nimport { PrometheusDatasource } from './datasource';\r\nimport { PromQuery, PromMetricsMetadata } from './types';\r\n\r\nconst DEFAULT_KEYS = ['job', 'instance'];\r\nconst EMPTY_SELECTOR = '{}';\r\nconst HISTORY_ITEM_COUNT = 5;\r\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\r\nexport const DEFAULT_LOOKUP_METRICS_THRESHOLD = 10000; // number of metrics defining an installation that's too big\r\n\r\nconst wrapLabel = (label: string): CompletionItem => ({ label });\r\n\r\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\r\n  suggestion.kind = 'function';\r\n  return suggestion;\r\n};\r\n\r\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\r\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\r\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\r\n  const count = historyForItem.length;\r\n  const recent = historyForItem[0];\r\n  let hint = `Queried ${count} times in the last 24h.`;\r\n\r\n  if (recent) {\r\n    const lastQueried = dateTime(recent.ts).fromNow();\r\n    hint = `${hint} Last queried ${lastQueried}.`;\r\n  }\r\n\r\n  return {\r\n    ...item,\r\n    documentation: hint,\r\n  };\r\n}\r\n\r\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\r\n  const item: CompletionItem = { label: metric };\r\n  if (metadata && metadata[metric]) {\r\n    const { type, help } = metadata[metric][0];\r\n    item.documentation = `${type.toUpperCase()}: ${help}`;\r\n  }\r\n  return item;\r\n}\r\n\r\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\r\n\r\nexport default class PromQlLanguageProvider extends LanguageProvider {\r\n  histogramMetrics?: string[];\r\n  timeRange?: { start: number; end: number };\r\n  metrics?: string[];\r\n  metricsMetadata?: PromMetricsMetadata;\r\n  startTask: Promise<any>;\r\n  datasource: PrometheusDatasource;\r\n  lookupMetricsThreshold: number;\r\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\r\n\r\n  /**\r\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\r\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\r\n   *  10 as a max size is totally arbitrary right now.\r\n   */\r\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\r\n\r\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\r\n    super();\r\n\r\n    this.datasource = datasource;\r\n    this.histogramMetrics = [];\r\n    this.timeRange = { start: 0, end: 0 };\r\n    this.metrics = [];\r\n    // Disable lookups until we know the instance is small enough\r\n    this.lookupMetricsThreshold = DEFAULT_LOOKUP_METRICS_THRESHOLD;\r\n    this.lookupsDisabled = true;\r\n\r\n    Object.assign(this, initialValues);\r\n  }\r\n\r\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\r\n  cleanText(s: string) {\r\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\r\n    const last = parts.pop();\r\n    return last\r\n      .trimLeft()\r\n      .replace(/\"$/, '')\r\n      .replace(/^\"/, '');\r\n  }\r\n\r\n  get syntax() {\r\n    return PromqlSyntax;\r\n  }\r\n\r\n  request = async (url: string, defaultValue: any): Promise<any> => {\r\n    try {\r\n      const res = await this.datasource.metadataRequest(url);\r\n      const body = await (res.data || res.json());\r\n\r\n      return body.data;\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n\r\n    return defaultValue;\r\n  };\r\n\r\n  start = async (): Promise<any[]> => {\r\n    this.metrics = await this.request('/api/v1/label/__name__/values', []);\r\n    this.lookupsDisabled = this.metrics.length > this.lookupMetricsThreshold;\r\n    this.metricsMetadata = await this.request('/api/v1/metadata', {});\r\n    this.processHistogramMetrics(this.metrics);\r\n    return [];\r\n  };\r\n\r\n  processHistogramMetrics = (data: string[]) => {\r\n    const { values } = processHistogramLabels(data);\r\n\r\n    if (values && values['__name__']) {\r\n      this.histogramMetrics = values['__name__'].slice().sort();\r\n    }\r\n  };\r\n\r\n  provideCompletionItems = async (\r\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\r\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\r\n  ): Promise<TypeaheadOutput> => {\r\n    // Local text properties\r\n    const empty = value.document.text.length === 0;\r\n    const selectedLines = value.document.getTextsAtRange(value.selection);\r\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\r\n\r\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\r\n\r\n    // Syntax spans have 3 classes by default. More indicate a recognized token\r\n    const tokenRecognized = wrapperClasses.length > 3;\r\n    // Non-empty prefix, but not inside known token\r\n    const prefixUnrecognized = prefix && !tokenRecognized;\r\n\r\n    // Prevent suggestions in `function(|suffix)`\r\n    const noSuffix = !nextCharacter || nextCharacter === ')';\r\n\r\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\r\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\r\n\r\n    // About to type next operand if preceded by binary operator\r\n    const operatorsPattern = /[+\\-*/^%]/;\r\n    const isNextOperand = text.match(operatorsPattern);\r\n\r\n    // Determine candidates by CSS context\r\n    if (wrapperClasses.includes('context-range')) {\r\n      // Suggestions for metric[|]\r\n      return this.getRangeCompletionItems();\r\n    } else if (wrapperClasses.includes('context-labels')) {\r\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\r\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\r\n    } else if (wrapperClasses.includes('context-aggregation')) {\r\n      // Suggestions for sum(metric) by (|)\r\n      return this.getAggregationCompletionItems(value);\r\n    } else if (empty) {\r\n      // Suggestions for empty query field\r\n      return this.getEmptyCompletionItems(context);\r\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\r\n      // Show term suggestions in a couple of scenarios\r\n      return this.getBeginningCompletionItems(context);\r\n    } else if (prefixUnrecognized && safePrefix) {\r\n      // Show term suggestions in a couple of scenarios\r\n      return this.getTermCompletionItems();\r\n    }\r\n\r\n    return {\r\n      suggestions: [],\r\n    };\r\n  };\r\n\r\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\r\n    return {\r\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\r\n    };\r\n  };\r\n\r\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\r\n    const { history } = context;\r\n    const suggestions = [];\r\n\r\n    if (history && history.length) {\r\n      const historyItems = _.chain(history)\r\n        .map(h => h.query.expr)\r\n        .filter()\r\n        .uniq()\r\n        .take(HISTORY_ITEM_COUNT)\r\n        .map(wrapLabel)\r\n        .map(item => addHistoryMetadata(item, history))\r\n        .value();\r\n\r\n      suggestions.push({\r\n        prefixMatch: true,\r\n        skipSort: true,\r\n        label: 'History',\r\n        items: historyItems,\r\n      });\r\n    }\r\n\r\n    return { suggestions };\r\n  };\r\n\r\n  getTermCompletionItems = (): TypeaheadOutput => {\r\n    const { metrics, metricsMetadata } = this;\r\n    const suggestions = [];\r\n\r\n    suggestions.push({\r\n      prefixMatch: true,\r\n      label: 'Functions',\r\n      items: FUNCTIONS.map(setFunctionKind),\r\n    });\r\n\r\n    if (metrics && metrics.length) {\r\n      suggestions.push({\r\n        label: 'Metrics',\r\n        items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\r\n      });\r\n    }\r\n\r\n    return { suggestions };\r\n  };\r\n\r\n  getRangeCompletionItems(): TypeaheadOutput {\r\n    return {\r\n      context: 'context-range',\r\n      suggestions: [\r\n        {\r\n          label: 'Range vector',\r\n          items: [...RATE_RANGES],\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\r\n    const suggestions: CompletionItemGroup[] = [];\r\n\r\n    // Stitch all query lines together to support multi-line queries\r\n    let queryOffset;\r\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\r\n      const blockText = block.getText();\r\n      if (value.anchorBlock.key === block.key) {\r\n        // Newline characters are not accounted for but this is irrelevant\r\n        // for the purpose of extracting the selector string\r\n        queryOffset = value.selection.anchor.offset + text.length;\r\n      }\r\n\r\n      return text + blockText;\r\n    }, '');\r\n\r\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\r\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\r\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\r\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\r\n\r\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\r\n    if (openParensSelectorIndex === -1) {\r\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\r\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\r\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\r\n    }\r\n\r\n    const result = {\r\n      suggestions,\r\n      context: 'context-aggregation',\r\n    };\r\n\r\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\r\n    if (openParensSelectorIndex === -1) {\r\n      return result;\r\n    }\r\n\r\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\r\n    const selectorString = queryText\r\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\r\n      .replace(/\\[[^\\]]+\\]$/, '');\r\n\r\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\r\n\r\n    const labelValues = await this.getLabelValues(selector);\r\n    if (labelValues) {\r\n      suggestions.push({ label: 'Labels', items: Object.keys(labelValues).map(wrapLabel) });\r\n    }\r\n    return result;\r\n  };\r\n\r\n  getLabelCompletionItems = async ({\r\n    text,\r\n    wrapperClasses,\r\n    labelKey,\r\n    value,\r\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\r\n    const suggestions: CompletionItemGroup[] = [];\r\n    const line = value.anchorBlock.getText();\r\n    const cursorOffset = value.selection.anchor.offset;\r\n    const suffix = line.substr(cursorOffset);\r\n    const prefix = line.substr(0, cursorOffset);\r\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\r\n    const isValueEnd = suffix.match(/^\"?[,}]/);\r\n    // detect cursor in front of value, e.g., {key=|\"}\r\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\r\n\r\n    // Don't suggestq anything at the beginning or inside a value\r\n    const isValueEmpty = isValueStart && isValueEnd;\r\n    const hasValuePrefix = isValueEnd && !isValueStart;\r\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\r\n      return { suggestions };\r\n    }\r\n\r\n    // Get normalized selector\r\n    let selector;\r\n    let parsedSelector;\r\n    try {\r\n      parsedSelector = parseSelector(line, cursorOffset);\r\n      selector = parsedSelector.selector;\r\n    } catch {\r\n      selector = EMPTY_SELECTOR;\r\n    }\r\n\r\n    const containsMetric = selector.includes('__name__=');\r\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\r\n\r\n    let labelValues;\r\n    // Query labels for selector\r\n    if (selector) {\r\n      labelValues = await this.getLabelValues(selector, !containsMetric);\r\n    }\r\n\r\n    if (!labelValues) {\r\n      console.warn(`Server did not return any values for selector = ${selector}`);\r\n      return { suggestions };\r\n    }\r\n\r\n    let context: string;\r\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\r\n      // Label values\r\n      if (labelKey && labelValues[labelKey]) {\r\n        context = 'context-label-values';\r\n        suggestions.push({\r\n          label: `Label values for \"${labelKey}\"`,\r\n          items: labelValues[labelKey].map(wrapLabel),\r\n        });\r\n      }\r\n    } else {\r\n      // Label keys\r\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\r\n\r\n      if (labelKeys) {\r\n        const possibleKeys = _.difference(labelKeys, existingKeys);\r\n        if (possibleKeys.length) {\r\n          context = 'context-labels';\r\n          const newItems = possibleKeys.map(key => ({ label: key }));\r\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\r\n          suggestions.push(newSuggestion);\r\n        }\r\n      }\r\n    }\r\n\r\n    return { context, suggestions };\r\n  };\r\n\r\n  async getLabelValues(selector: string, withName?: boolean) {\r\n    if (this.lookupsDisabled) {\r\n      return undefined;\r\n    }\r\n    try {\r\n      if (selector === EMPTY_SELECTOR) {\r\n        return await this.fetchDefaultLabels();\r\n      } else {\r\n        return await this.fetchSeriesLabels(selector, withName);\r\n      }\r\n    } catch (error) {\r\n      // TODO: better error handling\r\n      console.error(error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\r\n    const data = await this.request(`/api/v1/label/${key}/values`, []);\r\n    return { [key]: data };\r\n  };\r\n\r\n  roundToMinutes(seconds: number): number {\r\n    return Math.floor(seconds / 60);\r\n  }\r\n\r\n  /**\r\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\r\n   * they can change over requested time.\r\n   * @param name\r\n   * @param withName\r\n   */\r\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\r\n    const tRange = this.datasource.getTimeRange();\r\n    const url = `/api/v1/series?match[]=${name}&start=${tRange['start']}&end=${tRange['end']}`;\r\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\r\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\r\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\r\n    // when user does not the newest values for a minute if already cached.\r\n    const cacheKey = `/api/v1/series?match[]=${name}&start=${this.roundToMinutes(\r\n      tRange['start']\r\n    )}&end=${this.roundToMinutes(tRange['end'])}&withName=${!!withName}`;\r\n    let value = this.labelsCache.get(cacheKey);\r\n    if (!value) {\r\n      const data = await this.request(url, []);\r\n      const { values } = processLabels(data, withName);\r\n      value = values;\r\n      this.labelsCache.set(cacheKey, value);\r\n    }\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\r\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\r\n   * fetchSeriesLabels.\r\n   */\r\n  fetchDefaultLabels = _.once(async () => {\r\n    const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\r\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\r\n  });\r\n}\r\n","import _ from 'lodash';\r\nimport { TimeRange } from '@grafana/data';\r\nimport { PrometheusDatasource, PromDataQueryResponse } from './datasource';\r\nimport { PromQueryRequest } from './types';\r\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\n\r\nexport default class PrometheusMetricFindQuery {\r\n  range: TimeRange;\r\n\r\n  constructor(private datasource: PrometheusDatasource, private query: string) {\r\n    this.datasource = datasource;\r\n    this.query = query;\r\n    this.range = getTimeSrv().timeRange();\r\n  }\r\n\r\n  process() {\r\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\r\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\r\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\r\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\r\n    const labelNamesQuery = this.query.match(labelNamesRegex);\r\n    if (labelNamesQuery) {\r\n      return this.labelNamesQuery();\r\n    }\r\n\r\n    const labelValuesQuery = this.query.match(labelValuesRegex);\r\n    if (labelValuesQuery) {\r\n      if (labelValuesQuery[1]) {\r\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\r\n      } else {\r\n        return this.labelValuesQuery(labelValuesQuery[2], null);\r\n      }\r\n    }\r\n\r\n    const metricNamesQuery = this.query.match(metricNamesRegex);\r\n    if (metricNamesQuery) {\r\n      return this.metricNameQuery(metricNamesQuery[1]);\r\n    }\r\n\r\n    const queryResultQuery = this.query.match(queryResultRegex);\r\n    if (queryResultQuery) {\r\n      return this.queryResultQuery(queryResultQuery[1]);\r\n    }\r\n\r\n    // if query contains full metric name, return metric name and label list\r\n    return this.metricNameAndLabelsQuery(this.query);\r\n  }\r\n\r\n  labelNamesQuery() {\r\n    const url = '/api/v1/labels';\r\n    return this.datasource.metadataRequest(url).then((result: any) => {\r\n      return _.map(result.data.data, value => {\r\n        return { text: value };\r\n      });\r\n    });\r\n  }\r\n\r\n  labelValuesQuery(label: string, metric?: string) {\r\n    let url: string;\r\n\r\n    if (!metric) {\r\n      // return label values globally\r\n      url = '/api/v1/label/' + label + '/values';\r\n\r\n      return this.datasource.metadataRequest(url).then((result: any) => {\r\n        return _.map(result.data.data, value => {\r\n          return { text: value };\r\n        });\r\n      });\r\n    } else {\r\n      const start = this.datasource.getPrometheusTime(this.range.from, false);\r\n      const end = this.datasource.getPrometheusTime(this.range.to, true);\r\n      url = '/api/v1/series?match[]=' + encodeURIComponent(metric) + '&start=' + start + '&end=' + end;\r\n\r\n      return this.datasource.metadataRequest(url).then((result: any) => {\r\n        const _labels = _.map(result.data.data, metric => {\r\n          return metric[label] || '';\r\n        }).filter(label => {\r\n          return label !== '';\r\n        });\r\n\r\n        return _.uniq(_labels).map(metric => {\r\n          return {\r\n            text: metric,\r\n            expandable: true,\r\n          };\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  metricNameQuery(metricFilterPattern: string) {\r\n    const url = '/api/v1/label/__name__/values';\r\n\r\n    return this.datasource.metadataRequest(url).then((result: any) => {\r\n      return _.chain(result.data.data)\r\n        .filter(metricName => {\r\n          const r = new RegExp(metricFilterPattern);\r\n          return r.test(metricName);\r\n        })\r\n        .map(matchedMetricName => {\r\n          return {\r\n            text: matchedMetricName,\r\n            expandable: true,\r\n          };\r\n        })\r\n        .value();\r\n    });\r\n  }\r\n\r\n  queryResultQuery(query: string) {\r\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\r\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\r\n    return this.datasource.performInstantQuery(instantQuery, end).then((result: PromDataQueryResponse) => {\r\n      return _.map(result.data.data.result, metricData => {\r\n        let text = metricData.metric.__name__ || '';\r\n        delete metricData.metric.__name__;\r\n        text +=\r\n          '{' +\r\n          _.map(metricData.metric, (v, k) => {\r\n            return k + '=\"' + v + '\"';\r\n          }).join(',') +\r\n          '}';\r\n        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\r\n\r\n        return {\r\n          text: text,\r\n          expandable: true,\r\n        };\r\n      });\r\n    });\r\n  }\r\n\r\n  metricNameAndLabelsQuery(query: string) {\r\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\r\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\r\n    const url = '/api/v1/series?match[]=' + encodeURIComponent(query) + '&start=' + start + '&end=' + end;\r\n\r\n    const self = this;\r\n    return this.datasource.metadataRequest(url).then((result: PromDataQueryResponse) => {\r\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\r\n        return {\r\n          text: self.datasource.getOriginalMetricName(metric),\r\n          expandable: true,\r\n        };\r\n      });\r\n    });\r\n  }\r\n}\r\n","import { DataSourcePlugin } from '@grafana/data';\r\nimport { PrometheusDatasource } from './datasource';\r\n\r\nimport { PromQueryEditor } from './components/PromQueryEditor';\r\nimport PromCheatSheet from './components/PromCheatSheet';\r\nimport { PromExploreQueryEditor } from './components/PromExploreQueryEditor';\r\n\r\nimport { ConfigEditor } from './configuration/ConfigEditor';\r\n\r\nclass PrometheusAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n}\r\n\r\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\r\n  .setQueryEditor(PromQueryEditor)\r\n  .setConfigEditor(ConfigEditor)\r\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\r\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\r\n  .setExploreStartPage(PromCheatSheet);\r\n","import _ from 'lodash';\r\nimport { QueryHint, QueryFix } from '@grafana/data';\r\nimport { PrometheusDatasource } from './datasource';\r\n\r\n/**\r\n * Number of time series results needed before starting to suggest sum aggregation hints\r\n */\r\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\r\n\r\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] | null {\r\n  const hints = [];\r\n\r\n  // ..._bucket metric needs a histogram_quantile()\r\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\r\n  if (histogramMetric) {\r\n    const label = 'Time series has buckets, you probably wanted a histogram.';\r\n    hints.push({\r\n      type: 'HISTOGRAM_QUANTILE',\r\n      label,\r\n      fix: {\r\n        label: 'Fix by adding histogram_quantile().',\r\n        action: {\r\n          type: 'ADD_HISTOGRAM_QUANTILE',\r\n          query,\r\n        },\r\n      } as QueryFix,\r\n    });\r\n  }\r\n\r\n  // Check for need of rate()\r\n  if (query.indexOf('rate(') === -1) {\r\n    // Use metric metadata for exact types\r\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\r\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\r\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata;\r\n    let certain = false;\r\n    if (_.size(metricsMetadata) > 0) {\r\n      counterNameMetric = Object.keys(metricsMetadata).find(metricName => {\r\n        // Only considering first type information, could be non-deterministic\r\n        const metadata = metricsMetadata[metricName][0];\r\n        if (metadata.type.toLowerCase() === 'counter') {\r\n          const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\r\n          if (query.match(metricRegex)) {\r\n            certain = true;\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      });\r\n    }\r\n    if (counterNameMetric) {\r\n      const simpleMetric = query.trim().match(/^\\w+$/);\r\n      const verb = certain ? 'is' : 'looks like';\r\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\r\n      let fix: QueryFix;\r\n      if (simpleMetric) {\r\n        fix = {\r\n          label: 'Fix by adding rate().',\r\n          action: {\r\n            type: 'ADD_RATE',\r\n            query,\r\n          },\r\n        } as QueryFix;\r\n      } else {\r\n        label = `${label} Try applying a rate() function.`;\r\n      }\r\n      hints.push({\r\n        type: 'APPLY_RATE',\r\n        label,\r\n        fix,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Check for recording rules expansion\r\n  if (datasource && datasource.ruleMappings) {\r\n    const mapping = datasource.ruleMappings;\r\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\r\n      if (query.search(ruleName) > -1) {\r\n        return {\r\n          ...acc,\r\n          [ruleName]: mapping[ruleName],\r\n        };\r\n      }\r\n      return acc;\r\n    }, {});\r\n    if (_.size(mappingForQuery) > 0) {\r\n      const label = 'Query contains recording rules.';\r\n      hints.push({\r\n        type: 'EXPAND_RULES',\r\n        label,\r\n        fix: ({\r\n          label: 'Expand rules',\r\n          action: {\r\n            type: 'EXPAND_RULES',\r\n            query,\r\n            mapping: mappingForQuery,\r\n          },\r\n        } as any) as QueryFix,\r\n      });\r\n    }\r\n  }\r\n\r\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\r\n    const simpleMetric = query.trim().match(/^\\w+$/);\r\n    if (simpleMetric) {\r\n      hints.push({\r\n        type: 'ADD_SUM',\r\n        label: 'Many time series results returned.',\r\n        fix: {\r\n          label: 'Consider aggregating with sum().',\r\n          action: {\r\n            type: 'ADD_SUM',\r\n            query: query,\r\n            preventSubmit: true,\r\n          },\r\n        } as QueryFix,\r\n      });\r\n    }\r\n  }\r\n\r\n  return hints.length > 0 ? hints : null;\r\n}\r\n","import _ from 'lodash';\r\nimport TableModel from 'app/core/table_model';\r\nimport { TimeSeries, FieldType } from '@grafana/data';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\nexport class ResultTransformer {\r\n  constructor(private templateSrv: TemplateSrv) {}\r\n\r\n  transform(response: any, options: any): Array<TableModel | TimeSeries> {\r\n    const prometheusResult = response.data.data.result;\r\n\r\n    if (options.format === 'table') {\r\n      return [\r\n        this.transformMetricDataToTable(\r\n          prometheusResult,\r\n          options.responseListLength,\r\n          options.refId,\r\n          options.valueWithRefId\r\n        ),\r\n      ];\r\n    } else if (prometheusResult && options.format === 'heatmap') {\r\n      let seriesList = [];\r\n      for (const metricData of prometheusResult) {\r\n        seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\r\n      }\r\n      seriesList.sort(sortSeriesByLabel);\r\n      seriesList = this.transformToHistogramOverTime(seriesList);\r\n      return seriesList;\r\n    } else if (prometheusResult) {\r\n      const seriesList = [];\r\n      for (const metricData of prometheusResult) {\r\n        if (response.data.data.resultType === 'matrix') {\r\n          seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\r\n        } else if (response.data.data.resultType === 'vector') {\r\n          seriesList.push(this.transformInstantMetricData(metricData, options));\r\n        }\r\n      }\r\n      return seriesList;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  transformMetricData(metricData: any, options: any, start: number, end: number) {\r\n    const dps = [];\r\n    let metricLabel = null;\r\n\r\n    metricLabel = this.createMetricLabel(metricData.metric, options);\r\n\r\n    const stepMs = parseInt(options.step, 10) * 1000;\r\n    let baseTimestamp = start * 1000;\r\n\r\n    if (metricData.values === undefined) {\r\n      throw new Error('Prometheus heatmap error: data should be a time series');\r\n    }\r\n\r\n    for (const value of metricData.values) {\r\n      let dpValue = parseFloat(value[1]);\r\n      if (_.isNaN(dpValue)) {\r\n        dpValue = null;\r\n      }\r\n\r\n      const timestamp = parseFloat(value[0]) * 1000;\r\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\r\n        dps.push([null, t]);\r\n      }\r\n      baseTimestamp = timestamp + stepMs;\r\n      dps.push([dpValue, timestamp]);\r\n    }\r\n\r\n    const endTimestamp = end * 1000;\r\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\r\n      dps.push([null, t]);\r\n    }\r\n\r\n    return {\r\n      datapoints: dps,\r\n      query: options.query,\r\n      refId: options.refId,\r\n      target: metricLabel,\r\n      tags: metricData.metric,\r\n    };\r\n  }\r\n\r\n  transformMetricDataToTable(md: any, resultCount: number, refId: string, valueWithRefId?: boolean): TableModel {\r\n    const table = new TableModel();\r\n    table.refId = refId;\r\n\r\n    let i: number, j: number;\r\n    const metricLabels: { [key: string]: number } = {};\r\n\r\n    if (!md || md.length === 0) {\r\n      return table;\r\n    }\r\n\r\n    // Collect all labels across all metrics\r\n    _.each(md, series => {\r\n      for (const label in series.metric) {\r\n        if (!metricLabels.hasOwnProperty(label)) {\r\n          metricLabels[label] = 1;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Sort metric labels, create columns for them and record their index\r\n    const sortedLabels = _.keys(metricLabels).sort();\r\n    table.columns.push({ text: 'Time', type: FieldType.time });\r\n    _.each(sortedLabels, (label, labelIndex) => {\r\n      metricLabels[label] = labelIndex + 1;\r\n      table.columns.push({ text: label, filterable: true });\r\n    });\r\n    const valueText = resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value';\r\n    table.columns.push({ text: valueText });\r\n\r\n    // Populate rows, set value to empty string when label not present.\r\n    _.each(md, series => {\r\n      if (series.value) {\r\n        series.values = [series.value];\r\n      }\r\n      if (series.values) {\r\n        for (i = 0; i < series.values.length; i++) {\r\n          const values = series.values[i];\r\n          const reordered: any = [values[0] * 1000];\r\n          if (series.metric) {\r\n            for (j = 0; j < sortedLabels.length; j++) {\r\n              const label = sortedLabels[j];\r\n              if (series.metric.hasOwnProperty(label)) {\r\n                reordered.push(series.metric[label]);\r\n              } else {\r\n                reordered.push('');\r\n              }\r\n            }\r\n          }\r\n          reordered.push(parseFloat(values[1]));\r\n          table.rows.push(reordered);\r\n        }\r\n      }\r\n    });\r\n\r\n    return table;\r\n  }\r\n\r\n  transformInstantMetricData(md: any, options: any) {\r\n    const dps = [];\r\n    let metricLabel = null;\r\n    metricLabel = this.createMetricLabel(md.metric, options);\r\n    dps.push([parseFloat(md.value[1]), md.value[0] * 1000]);\r\n    return { target: metricLabel, datapoints: dps, tags: md.metric, refId: options.refId };\r\n  }\r\n\r\n  createMetricLabel(labelData: { [key: string]: string }, options: any) {\r\n    let label = '';\r\n    if (_.isUndefined(options) || _.isEmpty(options.legendFormat)) {\r\n      label = this.getOriginalMetricName(labelData);\r\n    } else {\r\n      label = this.renderTemplate(this.templateSrv.replace(options.legendFormat), labelData);\r\n    }\r\n    if (!label || label === '{}') {\r\n      label = options.query;\r\n    }\r\n    return label;\r\n  }\r\n\r\n  renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\r\n    const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\r\n    return aliasPattern.replace(aliasRegex, (match, g1) => {\r\n      if (aliasData[g1]) {\r\n        return aliasData[g1];\r\n      }\r\n      return g1;\r\n    });\r\n  }\r\n\r\n  getOriginalMetricName(labelData: { [key: string]: string }) {\r\n    const metricName = labelData.__name__ || '';\r\n    delete labelData.__name__;\r\n    const labelPart = _.map(_.toPairs(labelData), label => {\r\n      return label[0] + '=\"' + label[1] + '\"';\r\n    }).join(',');\r\n    return metricName + '{' + labelPart + '}';\r\n  }\r\n\r\n  transformToHistogramOverTime(seriesList: TimeSeries[]) {\r\n    /*      t1 = timestamp1, t2 = timestamp2 etc.\r\n            t1  t2  t3          t1  t2  t3\r\n    le10    10  10  0     =>    10  10  0\r\n    le20    20  10  30    =>    10  0   30\r\n    le30    30  10  35    =>    10  0   5\r\n    */\r\n    for (let i = seriesList.length - 1; i > 0; i--) {\r\n      const topSeries = seriesList[i].datapoints;\r\n      const bottomSeries = seriesList[i - 1].datapoints;\r\n      if (!topSeries || !bottomSeries) {\r\n        throw new Error('Prometheus heatmap transform error: data should be a time series');\r\n      }\r\n\r\n      for (let j = 0; j < topSeries.length; j++) {\r\n        const bottomPoint = bottomSeries[j] || [0];\r\n        topSeries[j][0] -= bottomPoint[0];\r\n      }\r\n    }\r\n\r\n    return seriesList;\r\n  }\r\n}\r\n\r\nfunction sortSeriesByLabel(s1: TimeSeries, s2: TimeSeries): number {\r\n  let le1, le2;\r\n\r\n  try {\r\n    // fail if not integer. might happen with bad queries\r\n    le1 = parseHistogramLabel(s1.target);\r\n    le2 = parseHistogramLabel(s2.target);\r\n  } catch (err) {\r\n    console.log(err);\r\n    return 0;\r\n  }\r\n\r\n  if (le1 > le2) {\r\n    return 1;\r\n  }\r\n\r\n  if (le1 < le2) {\r\n    return -1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nfunction parseHistogramLabel(le: string): number {\r\n  if (le === '+Inf') {\r\n    return +Infinity;\r\n  }\r\n  return Number(le);\r\n}\r\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzaA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAKA;AAGA;;;;;;;;;;;;;;;;;;;;;ACzCA;AAIA;AAKA;AAOA;AAAA;AAIA;AAAA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7BA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAwBA;AACA;AACA;AAEA;AAEA;AAQA;AACA;AACA;AACA;AAaA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AAKA;AAYA;AAAA;AAAA;AAAA;AACA;;AAgDA;AA/CA;;;;;;AACA;AACA;;AAAA;AACA;;;;;;AAEA;AAEA;AAAA;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;;;AACA;;;AAFA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACnEA;AACA;AAEA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAUA;AAAA;AAIA;AAAA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AApDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAwCA;AACA;AACA;AAEA;AAEA;AASA;AACA;AACA;AAOA;AAUA;AACA;;AAIA;AACA;AACA;AAKA;AAUA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AAUA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLA;AACA;AAGA;AAUA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAYA;AAAA;AAKA;AAAA;AA4CA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAAA;AAKA;AAEA;;;AACA;AAlKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AA6HA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAcA;AAEA;AAEA;AAGA;AAEA;AACA;AAAA;AACA;AAUA;AACA;AAAA;AAEA;;;;;;;;;;;;;AC3VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAMA;AAGA;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AAIA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAiBA;AACA;AACA;AAiBA;AACA;AAMA;AAQA;AACA;AACA;AACA;AACA;AAmBA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAGA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAkCA;AAAA;AAgBA;AAAA;AAkBA;AACA;AACA;AAuEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AA2NA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAkEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA0BA;AAAA;;;;;;;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;AACA;AAEA;;;;AACA;AAEA;;;;;;AACA;;AAAA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;;AAAA;AACA;;;;AACA;AAEA;;;;;;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;;;;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;;;;;;;;AAEA;;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;AAEA;AACA;;;;;;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;AAEA;;;;;;;AAOA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AAAA;AAHA;AAWA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvuBA;AACA;AAGA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAiBA;AAAA;AAPA;;;;AAIA;AACA;AA8BA;;;;;;AAEA;;AAAA;AACA;;AAAA;AAEA;;;AAEA;;AAGA;;;AACA;AAEA;;;;;AACA;AAAA;;AAAA;AACA;AACA;AAAA;;AAAA;AACA;AACA;;;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AAGA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAcA;;;;;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;;AAAA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AAIA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AACA;;AAAA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AAmBA;;;;;AACA;;AAAA;AACA;;;AACA;AAMA;;;;;AAKA;AACA;;;;;AACA;AACA;AAKA;AAGA;AACA;AACA;;AAAA;AACA;AACA;AACA;;AAEA;;;AACA;AAEA;;;;AAIA;AACA;;;;;AACA;;AAAA;AACA;;;AACA;AApWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AAsIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiIA;;;;;;AACA;AACA;AACA;;;;AAEA;AACA;AAAA;AAEA;AAAA;;;;AAGA;AACA;AACA;;;;;AAEA;AAOA;AACA;AACA;AAqCA;AAAA;;;;;;;;;;;;;;AChbA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACpJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClBA;AAIA;;AAEA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;;AACA;AAEA;AACA;AACA;AAMA;AACA;AAAA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AAAA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}