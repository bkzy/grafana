{"version":3,"file":"stackdriverPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/stackdriver/StackdriverMetricFindQuery.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/annotations_query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/components/VariableQueryEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/config_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/module.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/stackdriver/types.ts"],"sourcesContent":["import isString from 'lodash/isString';\r\nimport { alignmentPeriods } from './constants';\r\nimport { MetricFindQueryTypes } from './types';\r\nimport {\r\n  getMetricTypesByService,\r\n  getAlignmentOptionsByMetric,\r\n  getAggregationOptionsByMetric,\r\n  extractServicesFromMetricDescriptors,\r\n  getLabelKeys,\r\n} from './functions';\r\n\r\nexport default class StackdriverMetricFindQuery {\r\n  constructor(private datasource: any) {}\r\n\r\n  async execute(query: any) {\r\n    try {\r\n      switch (query.selectedQueryType) {\r\n        case MetricFindQueryTypes.Services:\r\n          return this.handleServiceQuery();\r\n        case MetricFindQueryTypes.MetricTypes:\r\n          return this.handleMetricTypesQuery(query);\r\n        case MetricFindQueryTypes.LabelKeys:\r\n          return this.handleLabelKeysQuery(query);\r\n        case MetricFindQueryTypes.LabelValues:\r\n          return this.handleLabelValuesQuery(query);\r\n        case MetricFindQueryTypes.ResourceTypes:\r\n          return this.handleResourceTypeQuery(query);\r\n        case MetricFindQueryTypes.Aligners:\r\n          return this.handleAlignersQuery(query);\r\n        case MetricFindQueryTypes.AlignmentPeriods:\r\n          return this.handleAlignmentPeriodQuery();\r\n        case MetricFindQueryTypes.Aggregations:\r\n          return this.handleAggregationQuery(query);\r\n        default:\r\n          return [];\r\n      }\r\n    } catch (error) {\r\n      console.error(`Could not run StackdriverMetricFindQuery ${query}`, error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async handleServiceQuery() {\r\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\r\n    const services: any[] = extractServicesFromMetricDescriptors(metricDescriptors);\r\n    return services.map(s => ({\r\n      text: s.serviceShortName,\r\n      value: s.service,\r\n      expandable: true,\r\n    }));\r\n  }\r\n\r\n  async handleMetricTypesQuery({ selectedService }: any) {\r\n    if (!selectedService) {\r\n      return [];\r\n    }\r\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\r\n    return getMetricTypesByService(metricDescriptors, this.datasource.templateSrv.replace(selectedService)).map(\r\n      (s: any) => ({\r\n        text: s.displayName,\r\n        value: s.type,\r\n        expandable: true,\r\n      })\r\n    );\r\n  }\r\n\r\n  async handleLabelKeysQuery({ selectedMetricType }: any) {\r\n    if (!selectedMetricType) {\r\n      return [];\r\n    }\r\n    const labelKeys = await getLabelKeys(this.datasource, selectedMetricType);\r\n    return labelKeys.map(this.toFindQueryResult);\r\n  }\r\n\r\n  async handleLabelValuesQuery({ selectedMetricType, labelKey }: any) {\r\n    if (!selectedMetricType) {\r\n      return [];\r\n    }\r\n    const refId = 'handleLabelValuesQuery';\r\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, [labelKey]);\r\n    const interpolatedKey = this.datasource.templateSrv.replace(labelKey);\r\n    const values = labels.hasOwnProperty(interpolatedKey) ? labels[interpolatedKey] : [];\r\n    return values.map(this.toFindQueryResult);\r\n  }\r\n\r\n  async handleResourceTypeQuery({ selectedMetricType }: any) {\r\n    if (!selectedMetricType) {\r\n      return [];\r\n    }\r\n    const refId = 'handleResourceTypeQueryQueryType';\r\n    const labels = await this.datasource.getLabels(selectedMetricType, refId);\r\n    return labels['resource.type'].map(this.toFindQueryResult);\r\n  }\r\n\r\n  async handleAlignersQuery({ selectedMetricType }: any) {\r\n    if (!selectedMetricType) {\r\n      return [];\r\n    }\r\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\r\n    const { valueType, metricKind } = metricDescriptors.find(\r\n      (m: any) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\r\n    );\r\n    return getAlignmentOptionsByMetric(valueType, metricKind).map(this.toFindQueryResult);\r\n  }\r\n\r\n  async handleAggregationQuery({ selectedMetricType }: any) {\r\n    if (!selectedMetricType) {\r\n      return [];\r\n    }\r\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\r\n    const { valueType, metricKind } = metricDescriptors.find(\r\n      (m: any) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\r\n    );\r\n    return getAggregationOptionsByMetric(valueType, metricKind).map(this.toFindQueryResult);\r\n  }\r\n\r\n  handleAlignmentPeriodQuery() {\r\n    return alignmentPeriods.map(this.toFindQueryResult);\r\n  }\r\n\r\n  toFindQueryResult(x: any) {\r\n    return isString(x) ? { text: x, expandable: true } : { ...x, expandable: true };\r\n  }\r\n}\r\n","import { TemplateSrv } from 'app/features/templating/template_srv';\r\n\r\nexport class StackdriverAnnotationsQueryCtrl {\r\n  static templateUrl = 'partials/annotations.editor.html';\r\n  annotation: any;\r\n  templateSrv: TemplateSrv;\r\n\r\n  /** @ngInject */\r\n  constructor() {\r\n    this.annotation.target = this.annotation.target || {};\r\n    this.onQueryChange = this.onQueryChange.bind(this);\r\n  }\r\n\r\n  onQueryChange(target: any) {\r\n    Object.assign(this.annotation.target, target);\r\n  }\r\n}\r\n","import React, { ChangeEvent, PureComponent } from 'react';\r\nimport { VariableQueryProps } from 'app/types/plugins';\r\nimport { SimpleSelect } from './';\r\nimport { getMetricTypes, getLabelKeys, extractServicesFromMetricDescriptors } from '../functions';\r\nimport { MetricFindQueryTypes, VariableQueryData } from '../types';\r\n\r\nexport class StackdriverVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\r\n  queryTypes: Array<{ value: string; name: string }> = [\r\n    { value: MetricFindQueryTypes.Services, name: 'Services' },\r\n    { value: MetricFindQueryTypes.MetricTypes, name: 'Metric Types' },\r\n    { value: MetricFindQueryTypes.LabelKeys, name: 'Label Keys' },\r\n    { value: MetricFindQueryTypes.LabelValues, name: 'Label Values' },\r\n    { value: MetricFindQueryTypes.ResourceTypes, name: 'Resource Types' },\r\n    { value: MetricFindQueryTypes.Aggregations, name: 'Aggregations' },\r\n    { value: MetricFindQueryTypes.Aligners, name: 'Aligners' },\r\n    { value: MetricFindQueryTypes.AlignmentPeriods, name: 'Alignment Periods' },\r\n  ];\r\n\r\n  defaults: VariableQueryData = {\r\n    selectedQueryType: this.queryTypes[0].value,\r\n    metricDescriptors: [],\r\n    selectedService: '',\r\n    selectedMetricType: '',\r\n    labels: [],\r\n    labelKey: '',\r\n    metricTypes: [],\r\n    services: [],\r\n  };\r\n\r\n  constructor(props: VariableQueryProps) {\r\n    super(props);\r\n    this.state = Object.assign(this.defaults, this.props.query);\r\n  }\r\n\r\n  async componentDidMount() {\r\n    const metricDescriptors = await this.props.datasource.getMetricTypes(this.props.datasource.projectName);\r\n    const services = extractServicesFromMetricDescriptors(metricDescriptors).map((m: any) => ({\r\n      value: m.service,\r\n      name: m.serviceShortName,\r\n    }));\r\n\r\n    let selectedService = '';\r\n    if (services.some(s => s.value === this.props.templateSrv.replace(this.state.selectedService))) {\r\n      selectedService = this.state.selectedService;\r\n    } else if (services && services.length > 0) {\r\n      selectedService = services[0].value;\r\n    }\r\n\r\n    const { metricTypes, selectedMetricType } = getMetricTypes(\r\n      metricDescriptors,\r\n      this.state.selectedMetricType,\r\n      this.props.templateSrv.replace(this.state.selectedMetricType),\r\n      this.props.templateSrv.replace(selectedService)\r\n    );\r\n    const state: any = {\r\n      services,\r\n      selectedService,\r\n      metricTypes,\r\n      selectedMetricType,\r\n      metricDescriptors,\r\n      ...(await this.getLabels(selectedMetricType)),\r\n    };\r\n    this.setState(state);\r\n  }\r\n\r\n  async onQueryTypeChange(event: ChangeEvent<HTMLSelectElement>) {\r\n    const state: any = {\r\n      selectedQueryType: event.target.value,\r\n      ...(await this.getLabels(this.state.selectedMetricType, event.target.value)),\r\n    };\r\n    this.setState(state);\r\n  }\r\n\r\n  async onServiceChange(event: ChangeEvent<HTMLSelectElement>) {\r\n    const { metricTypes, selectedMetricType } = getMetricTypes(\r\n      this.state.metricDescriptors,\r\n      this.state.selectedMetricType,\r\n      this.props.templateSrv.replace(this.state.selectedMetricType),\r\n      this.props.templateSrv.replace(event.target.value)\r\n    );\r\n    const state: any = {\r\n      selectedService: event.target.value,\r\n      metricTypes,\r\n      selectedMetricType,\r\n      ...(await this.getLabels(selectedMetricType)),\r\n    };\r\n    this.setState(state);\r\n  }\r\n\r\n  async onMetricTypeChange(event: ChangeEvent<HTMLSelectElement>) {\r\n    const state: any = { selectedMetricType: event.target.value, ...(await this.getLabels(event.target.value)) };\r\n    this.setState(state);\r\n  }\r\n\r\n  onLabelKeyChange(event: ChangeEvent<HTMLSelectElement>) {\r\n    this.setState({ labelKey: event.target.value });\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    const { metricDescriptors, labels, metricTypes, services, ...queryModel } = this.state;\r\n    const query = this.queryTypes.find(q => q.value === this.state.selectedQueryType);\r\n    this.props.onChange(queryModel, `Stackdriver - ${query.name}`);\r\n  }\r\n\r\n  async getLabels(selectedMetricType: string, selectedQueryType = this.state.selectedQueryType) {\r\n    let result = { labels: this.state.labels, labelKey: this.state.labelKey };\r\n    if (selectedMetricType && selectedQueryType === MetricFindQueryTypes.LabelValues) {\r\n      const labels = await getLabelKeys(this.props.datasource, selectedMetricType);\r\n      const labelKey = labels.some(l => l === this.props.templateSrv.replace(this.state.labelKey))\r\n        ? this.state.labelKey\r\n        : labels[0];\r\n      result = { labels, labelKey };\r\n    }\r\n    return result;\r\n  }\r\n\r\n  insertTemplateVariables(options: any) {\r\n    const templateVariables = this.props.templateSrv.variables.map((v: any) => ({\r\n      name: `$${v.name}`,\r\n      value: `$${v.name}`,\r\n    }));\r\n    return [...templateVariables, ...options];\r\n  }\r\n\r\n  renderQueryTypeSwitch(queryType: string) {\r\n    switch (queryType) {\r\n      case MetricFindQueryTypes.MetricTypes:\r\n        return (\r\n          <SimpleSelect\r\n            value={this.state.selectedService}\r\n            options={this.insertTemplateVariables(this.state.services)}\r\n            onValueChange={e => this.onServiceChange(e)}\r\n            label=\"Service\"\r\n          />\r\n        );\r\n      case MetricFindQueryTypes.LabelKeys:\r\n      case MetricFindQueryTypes.LabelValues:\r\n      case MetricFindQueryTypes.ResourceTypes:\r\n        return (\r\n          <>\r\n            <SimpleSelect\r\n              value={this.state.selectedService}\r\n              options={this.insertTemplateVariables(this.state.services)}\r\n              onValueChange={e => this.onServiceChange(e)}\r\n              label=\"Service\"\r\n            />\r\n            <SimpleSelect\r\n              value={this.state.selectedMetricType}\r\n              options={this.insertTemplateVariables(this.state.metricTypes)}\r\n              onValueChange={e => this.onMetricTypeChange(e)}\r\n              label=\"Metric Type\"\r\n            />\r\n            {queryType === MetricFindQueryTypes.LabelValues && (\r\n              <SimpleSelect\r\n                value={this.state.labelKey}\r\n                options={this.insertTemplateVariables(this.state.labels.map(l => ({ value: l, name: l })))}\r\n                onValueChange={e => this.onLabelKeyChange(e)}\r\n                label=\"Label Key\"\r\n              />\r\n            )}\r\n          </>\r\n        );\r\n      case MetricFindQueryTypes.Aligners:\r\n      case MetricFindQueryTypes.Aggregations:\r\n        return (\r\n          <>\r\n            <SimpleSelect\r\n              value={this.state.selectedService}\r\n              options={this.insertTemplateVariables(this.state.services)}\r\n              onValueChange={e => this.onServiceChange(e)}\r\n              label=\"Service\"\r\n            />\r\n            <SimpleSelect\r\n              value={this.state.selectedMetricType}\r\n              options={this.insertTemplateVariables(this.state.metricTypes)}\r\n              onValueChange={e => this.onMetricTypeChange(e)}\r\n              label=\"Metric Type\"\r\n            />\r\n          </>\r\n        );\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <SimpleSelect\r\n          value={this.state.selectedQueryType}\r\n          options={this.queryTypes}\r\n          onValueChange={e => this.onQueryTypeChange(e)}\r\n          label=\"Query Type\"\r\n        />\r\n        {this.renderQueryTypeSwitch(this.state.selectedQueryType)}\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import DatasourceSrv from 'app/features/plugins/datasource_srv';\r\n\r\nexport interface JWT {\r\n  private_key: any;\r\n  token_uri: any;\r\n  client_email: any;\r\n  project_id: any;\r\n}\r\n\r\nexport class StackdriverConfigCtrl {\r\n  static templateUrl = 'public/app/plugins/datasource/stackdriver/partials/config.html';\r\n  datasourceSrv: any;\r\n  current: any;\r\n  jsonText: string;\r\n  validationErrors: string[] = [];\r\n  inputDataValid: boolean;\r\n  authenticationTypes: any[];\r\n  defaultAuthenticationType: string;\r\n\r\n  /** @ngInject */\r\n  constructor(datasourceSrv: DatasourceSrv) {\r\n    this.defaultAuthenticationType = 'jwt';\r\n    this.datasourceSrv = datasourceSrv;\r\n    this.current.jsonData = this.current.jsonData || {};\r\n    this.current.jsonData.authenticationType = this.current.jsonData.authenticationType\r\n      ? this.current.jsonData.authenticationType\r\n      : this.defaultAuthenticationType;\r\n    this.current.secureJsonData = this.current.secureJsonData || {};\r\n    this.current.secureJsonFields = this.current.secureJsonFields || {};\r\n    this.authenticationTypes = [\r\n      { key: this.defaultAuthenticationType, value: 'Google JWT File' },\r\n      { key: 'gce', value: 'GCE Default Service Account' },\r\n    ];\r\n  }\r\n\r\n  save(jwt: JWT) {\r\n    this.current.secureJsonData.privateKey = jwt.private_key;\r\n    this.current.jsonData.tokenUri = jwt.token_uri;\r\n    this.current.jsonData.clientEmail = jwt.client_email;\r\n    this.current.jsonData.defaultProject = jwt.project_id;\r\n  }\r\n\r\n  validateJwt(jwt: JWT) {\r\n    this.resetValidationMessages();\r\n    if (!jwt.private_key || jwt.private_key.length === 0) {\r\n      this.validationErrors.push('Private key field missing in JWT file.');\r\n    }\r\n\r\n    if (!jwt.token_uri || jwt.token_uri.length === 0) {\r\n      this.validationErrors.push('Token URI field missing in JWT file.');\r\n    }\r\n\r\n    if (!jwt.client_email || jwt.client_email.length === 0) {\r\n      this.validationErrors.push('Client Email field missing in JWT file.');\r\n    }\r\n\r\n    if (!jwt.project_id || jwt.project_id.length === 0) {\r\n      this.validationErrors.push('Project Id field missing in JWT file.');\r\n    }\r\n\r\n    if (this.validationErrors.length === 0) {\r\n      this.inputDataValid = true;\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  onUpload(json: JWT) {\r\n    this.jsonText = '';\r\n    if (this.validateJwt(json)) {\r\n      this.save(json);\r\n    }\r\n  }\r\n\r\n  onPasteJwt(e: any) {\r\n    try {\r\n      const json = JSON.parse(e.originalEvent.clipboardData.getData('text/plain') || this.jsonText);\r\n      if (this.validateJwt(json)) {\r\n        this.save(json);\r\n      }\r\n    } catch (error) {\r\n      this.resetValidationMessages();\r\n      this.validationErrors.push(`Invalid json: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  resetValidationMessages() {\r\n    this.validationErrors = [];\r\n    this.inputDataValid = false;\r\n    this.jsonText = '';\r\n\r\n    this.current.jsonData = Object.assign({}, { authenticationType: this.current.jsonData.authenticationType });\r\n    this.current.secureJsonData = {};\r\n    this.current.secureJsonFields = {};\r\n  }\r\n}\r\n","import { stackdriverUnitMappings } from './constants';\r\nimport appEvents from 'app/core/app_events';\r\nimport _ from 'lodash';\r\nimport StackdriverMetricFindQuery from './StackdriverMetricFindQuery';\r\nimport { StackdriverQuery, MetricDescriptor, StackdriverOptions, Filter } from './types';\r\nimport { DataSourceApi, DataQueryRequest, DataSourceInstanceSettings, ScopedVars } from '@grafana/data';\r\nimport { BackendSrv } from 'app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\r\nimport { CoreEvents } from 'app/types';\r\n\r\nexport default class StackdriverDatasource extends DataSourceApi<StackdriverQuery, StackdriverOptions> {\r\n  url: string;\r\n  baseUrl: string;\r\n  projectName: string;\r\n  authenticationType: string;\r\n  queryPromise: Promise<any>;\r\n  metricTypes: any[];\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: DataSourceInstanceSettings<StackdriverOptions>,\r\n    private backendSrv: BackendSrv,\r\n    public templateSrv: TemplateSrv,\r\n    private timeSrv: TimeSrv\r\n  ) {\r\n    super(instanceSettings);\r\n    this.baseUrl = `/stackdriver/`;\r\n    this.url = instanceSettings.url;\r\n    this.projectName = instanceSettings.jsonData.defaultProject || '';\r\n    this.authenticationType = instanceSettings.jsonData.authenticationType || 'jwt';\r\n    this.metricTypes = [];\r\n  }\r\n\r\n  get variables() {\r\n    return this.templateSrv.variables.map(v => `$${v.name}`);\r\n  }\r\n\r\n  async getTimeSeries(options: any) {\r\n    const queries = options.targets\r\n      .filter((target: any) => {\r\n        return !target.hide && target.metricType;\r\n      })\r\n      .map((t: any) => {\r\n        return {\r\n          refId: t.refId,\r\n          intervalMs: options.intervalMs,\r\n          datasourceId: this.id,\r\n          metricType: this.templateSrv.replace(t.metricType, options.scopedVars || {}),\r\n          crossSeriesReducer: this.templateSrv.replace(t.crossSeriesReducer || 'REDUCE_MEAN', options.scopedVars || {}),\r\n          perSeriesAligner: this.templateSrv.replace(t.perSeriesAligner, options.scopedVars || {}),\r\n          alignmentPeriod: this.templateSrv.replace(t.alignmentPeriod, options.scopedVars || {}),\r\n          groupBys: this.interpolateGroupBys(t.groupBys, options.scopedVars),\r\n          view: t.view || 'FULL',\r\n          filters: this.interpolateFilters(t.filters, options.scopedVars),\r\n          aliasBy: this.templateSrv.replace(t.aliasBy, options.scopedVars || {}),\r\n          type: 'timeSeriesQuery',\r\n        };\r\n      });\r\n\r\n    if (queries.length > 0) {\r\n      const { data } = await this.backendSrv.datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          from: options.range.from.valueOf().toString(),\r\n          to: options.range.to.valueOf().toString(),\r\n          queries,\r\n        },\r\n      });\r\n      return data;\r\n    } else {\r\n      return { results: [] };\r\n    }\r\n  }\r\n\r\n  interpolateFilters(filters: string[], scopedVars: ScopedVars) {\r\n    const completeFilter = _.chunk(filters, 4)\r\n      .map(([key, operator, value, condition = 'AND']) => ({\r\n        key,\r\n        operator,\r\n        value,\r\n        condition,\r\n      }))\r\n      .reduce((res, filter) => (filter.value ? [...res, filter] : res), []);\r\n\r\n    const filterArray = _.flatten(\r\n      completeFilter.map(({ key, operator, value, condition }: Filter) => [key, operator, value, condition])\r\n    );\r\n\r\n    return (filterArray || []).map(f => {\r\n      return this.templateSrv.replace(f, scopedVars || {}, 'regex');\r\n    });\r\n  }\r\n\r\n  async getLabels(metricType: string, refId: string, groupBys?: string[]) {\r\n    const response = await this.getTimeSeries({\r\n      targets: [\r\n        {\r\n          refId: refId,\r\n          datasourceId: this.id,\r\n          metricType: this.templateSrv.replace(metricType),\r\n          groupBys: this.interpolateGroupBys(groupBys || [], {}),\r\n          crossSeriesReducer: 'REDUCE_NONE',\r\n          view: 'HEADERS',\r\n        },\r\n      ],\r\n      range: this.timeSrv.timeRange(),\r\n    });\r\n    const result = response.results[refId];\r\n    return result && result.meta ? result.meta.labels : {};\r\n  }\r\n\r\n  interpolateGroupBys(groupBys: string[], scopedVars: {}): string[] {\r\n    let interpolatedGroupBys: any[] = [];\r\n    (groupBys || []).forEach(gb => {\r\n      const interpolated = this.templateSrv.replace(gb, scopedVars || {}, 'csv').split(',');\r\n      if (Array.isArray(interpolated)) {\r\n        interpolatedGroupBys = interpolatedGroupBys.concat(interpolated);\r\n      } else {\r\n        interpolatedGroupBys.push(interpolated);\r\n      }\r\n    });\r\n    return interpolatedGroupBys;\r\n  }\r\n\r\n  resolvePanelUnitFromTargets(targets: any[]) {\r\n    let unit;\r\n    if (targets.length > 0 && targets.every(t => t.unit === targets[0].unit)) {\r\n      if (stackdriverUnitMappings.hasOwnProperty(targets[0].unit)) {\r\n        // @ts-ignore\r\n        unit = stackdriverUnitMappings[targets[0].unit];\r\n      }\r\n    }\r\n    return unit;\r\n  }\r\n\r\n  async query(options: DataQueryRequest<StackdriverQuery>) {\r\n    const result: any[] = [];\r\n    const data = await this.getTimeSeries(options);\r\n    if (data.results) {\r\n      Object['values'](data.results).forEach((queryRes: any) => {\r\n        if (!queryRes.series) {\r\n          return;\r\n        }\r\n        const unit = this.resolvePanelUnitFromTargets(options.targets);\r\n        queryRes.series.forEach((series: any) => {\r\n          let timeSerie: any = {\r\n            target: series.name,\r\n            datapoints: series.points,\r\n            refId: queryRes.refId,\r\n            meta: queryRes.meta,\r\n          };\r\n          if (unit) {\r\n            timeSerie = { ...timeSerie, unit };\r\n          }\r\n          result.push(timeSerie);\r\n        });\r\n      });\r\n      return { data: result };\r\n    } else {\r\n      return { data: [] };\r\n    }\r\n  }\r\n\r\n  async annotationQuery(options: any) {\r\n    const annotation = options.annotation;\r\n    const queries = [\r\n      {\r\n        refId: 'annotationQuery',\r\n        datasourceId: this.id,\r\n        metricType: this.templateSrv.replace(annotation.target.metricType, options.scopedVars || {}),\r\n        crossSeriesReducer: 'REDUCE_NONE',\r\n        perSeriesAligner: 'ALIGN_NONE',\r\n        title: this.templateSrv.replace(annotation.target.title, options.scopedVars || {}),\r\n        text: this.templateSrv.replace(annotation.target.text, options.scopedVars || {}),\r\n        tags: this.templateSrv.replace(annotation.target.tags, options.scopedVars || {}),\r\n        view: 'FULL',\r\n        filters: this.interpolateFilters(annotation.target.filters || [], options.scopedVars),\r\n        type: 'annotationQuery',\r\n      },\r\n    ];\r\n\r\n    const { data } = await this.backendSrv.datasourceRequest({\r\n      url: '/api/tsdb/query',\r\n      method: 'POST',\r\n      data: {\r\n        from: options.range.from.valueOf().toString(),\r\n        to: options.range.to.valueOf().toString(),\r\n        queries,\r\n      },\r\n    });\r\n\r\n    const results = data.results['annotationQuery'].tables[0].rows.map((v: any) => {\r\n      return {\r\n        annotation: annotation,\r\n        time: Date.parse(v[0]),\r\n        title: v[1],\r\n        tags: [],\r\n        text: v[3],\r\n      } as any;\r\n    });\r\n\r\n    return results;\r\n  }\r\n\r\n  async metricFindQuery(query: string) {\r\n    const stackdriverMetricFindQuery = new StackdriverMetricFindQuery(this);\r\n    return stackdriverMetricFindQuery.execute(query);\r\n  }\r\n\r\n  async testDatasource() {\r\n    let status, message;\r\n    const defaultErrorMessage = 'Cannot connect to Stackdriver API';\r\n    try {\r\n      const projectName = await this.getDefaultProject();\r\n      const path = `v3/projects/${projectName}/metricDescriptors`;\r\n      const response = await this.doRequest(`${this.baseUrl}${path}`);\r\n      if (response.status === 200) {\r\n        status = 'success';\r\n        message = 'Successfully queried the Stackdriver API.';\r\n      } else {\r\n        status = 'error';\r\n        message = response.statusText ? response.statusText : defaultErrorMessage;\r\n      }\r\n    } catch (error) {\r\n      status = 'error';\r\n      if (_.isString(error)) {\r\n        message = error;\r\n      } else {\r\n        message = 'Stackdriver: ';\r\n        message += error.statusText ? error.statusText : defaultErrorMessage;\r\n        if (error.data && error.data.error && error.data.error.code) {\r\n          message += ': ' + error.data.error.code + '. ' + error.data.error.message;\r\n        }\r\n      }\r\n    } finally {\r\n      return {\r\n        status,\r\n        message,\r\n      };\r\n    }\r\n  }\r\n\r\n  formatStackdriverError(error: any) {\r\n    let message = 'Stackdriver: ';\r\n    message += error.statusText ? error.statusText + ': ' : '';\r\n    if (error.data && error.data.error) {\r\n      try {\r\n        const res = JSON.parse(error.data.error);\r\n        message += res.error.code + '. ' + res.error.message;\r\n      } catch (err) {\r\n        message += error.data.error;\r\n      }\r\n    } else {\r\n      message += 'Cannot connect to Stackdriver API';\r\n    }\r\n    return message;\r\n  }\r\n\r\n  async getDefaultProject() {\r\n    try {\r\n      if (this.authenticationType === 'gce' || !this.projectName) {\r\n        const { data } = await this.backendSrv.datasourceRequest({\r\n          url: '/api/tsdb/query',\r\n          method: 'POST',\r\n          data: {\r\n            queries: [\r\n              {\r\n                refId: 'ensureDefaultProjectQuery',\r\n                type: 'ensureDefaultProjectQuery',\r\n                datasourceId: this.id,\r\n              },\r\n            ],\r\n          },\r\n        });\r\n        this.projectName = data.results.ensureDefaultProjectQuery.meta.defaultProject;\r\n        return this.projectName;\r\n      } else {\r\n        return this.projectName;\r\n      }\r\n    } catch (error) {\r\n      throw this.formatStackdriverError(error);\r\n    }\r\n  }\r\n\r\n  async getMetricTypes(projectName: string): Promise<MetricDescriptor[]> {\r\n    try {\r\n      if (this.metricTypes.length === 0) {\r\n        const metricsApiPath = `v3/projects/${projectName}/metricDescriptors`;\r\n        const { data } = await this.doRequest(`${this.baseUrl}${metricsApiPath}`);\r\n\r\n        this.metricTypes = data.metricDescriptors.map((m: any) => {\r\n          const [service] = m.type.split('/');\r\n          const [serviceShortName] = service.split('.');\r\n          m.service = service;\r\n          m.serviceShortName = serviceShortName;\r\n          m.displayName = m.displayName || m.type;\r\n\r\n          return m;\r\n        });\r\n      }\r\n\r\n      return this.metricTypes;\r\n    } catch (error) {\r\n      appEvents.emit(CoreEvents.dsRequestError, { error: { data: { error: this.formatStackdriverError(error) } } });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async doRequest(url: string, maxRetries = 1) {\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: this.url + url,\r\n        method: 'GET',\r\n      })\r\n      .catch((error: any) => {\r\n        if (maxRetries > 0) {\r\n          return this.doRequest(url, maxRetries - 1);\r\n        }\r\n\r\n        throw error;\r\n      });\r\n  }\r\n}\r\n","import StackdriverDatasource from './datasource';\r\nimport { StackdriverQueryCtrl } from './query_ctrl';\r\nimport { StackdriverConfigCtrl } from './config_ctrl';\r\nimport { StackdriverAnnotationsQueryCtrl } from './annotations_query_ctrl';\r\nimport { StackdriverVariableQueryEditor } from './components/VariableQueryEditor';\r\n\r\nexport {\r\n  StackdriverDatasource as Datasource,\r\n  StackdriverQueryCtrl as QueryCtrl,\r\n  StackdriverConfigCtrl as ConfigCtrl,\r\n  StackdriverAnnotationsQueryCtrl as AnnotationsQueryCtrl,\r\n  StackdriverVariableQueryEditor as VariableQueryEditor,\r\n};\r\n","import { QueryCtrl } from 'app/plugins/sdk';\r\nimport { StackdriverQuery } from './types';\r\nimport { TemplateSrv } from 'app/features/templating/template_srv';\r\nimport { auto } from 'angular';\r\n\r\nexport class StackdriverQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n  templateSrv: TemplateSrv;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any, $injector: auto.IInjectorService, templateSrv: TemplateSrv) {\r\n    super($scope, $injector);\r\n    this.templateSrv = templateSrv;\r\n    this.onQueryChange = this.onQueryChange.bind(this);\r\n    this.onExecuteQuery = this.onExecuteQuery.bind(this);\r\n  }\r\n\r\n  onQueryChange(target: StackdriverQuery) {\r\n    Object.assign(this.target, target);\r\n  }\r\n\r\n  onExecuteQuery() {\r\n    this.$scope.ctrl.refresh();\r\n  }\r\n}\r\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\r\n\r\nexport enum MetricFindQueryTypes {\r\n  Services = 'services',\r\n  MetricTypes = 'metricTypes',\r\n  LabelKeys = 'labelKeys',\r\n  LabelValues = 'labelValues',\r\n  ResourceTypes = 'resourceTypes',\r\n  Aggregations = 'aggregations',\r\n  Aligners = 'aligners',\r\n  AlignmentPeriods = 'alignmentPeriods',\r\n}\r\n\r\nexport interface VariableQueryData {\r\n  selectedQueryType: string;\r\n  metricDescriptors: any[];\r\n  selectedService: string;\r\n  selectedMetricType: string;\r\n  labels: string[];\r\n  labelKey: string;\r\n  metricTypes: Array<{ value: string; name: string }>;\r\n  services: Array<{ value: string; name: string }>;\r\n}\r\n\r\nexport interface StackdriverQuery extends DataQuery {\r\n  defaultProject?: string;\r\n  unit?: string;\r\n  metricType: string;\r\n  service?: string;\r\n  refId: string;\r\n  crossSeriesReducer: string;\r\n  alignmentPeriod?: string;\r\n  perSeriesAligner: string;\r\n  groupBys?: string[];\r\n  filters?: string[];\r\n  aliasBy?: string;\r\n  metricKind: string;\r\n  valueType: string;\r\n  datasourceId?: number;\r\n  view?: string;\r\n}\r\n\r\nexport interface StackdriverOptions extends DataSourceJsonData {\r\n  defaultProject?: string;\r\n  authenticationType?: string;\r\n}\r\n\r\nexport interface AnnotationTarget {\r\n  defaultProject: string;\r\n  metricType: string;\r\n  refId: string;\r\n  filters: string[];\r\n  metricKind: string;\r\n  valueType: string;\r\n  title: string;\r\n  text: string;\r\n}\r\n\r\nexport interface QueryMeta {\r\n  alignmentPeriod: string;\r\n  rawQuery: string;\r\n  rawQueryString: string;\r\n  metricLabels: { [key: string]: string[] };\r\n  resourceLabels: { [key: string]: string[] };\r\n  resourceTypes: string[];\r\n}\r\n\r\nexport interface MetricDescriptor {\r\n  valueType: string;\r\n  metricKind: string;\r\n  type: string;\r\n  unit: string;\r\n  service: string;\r\n  serviceShortName: string;\r\n  displayName: string;\r\n  description: string;\r\n}\r\n\r\nexport interface Segment {\r\n  type: string;\r\n  value: string;\r\n}\r\n\r\nexport interface Filter {\r\n  key: string;\r\n  operator: string;\r\n  value: string;\r\n  condition: string;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAQA;AACA;AAAA;AAAA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AACA;AAEA;;;;;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;AAEA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAGA;;;;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAGA;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACzHA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAZA;AAaA;AAAA;AAdA;;;;;;;;;;;;;;;;;;;;;;ACFA;AAEA;AACA;AACA;AAEA;AAAA;AAuBA;AAAA;AAtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AACA;AAEA;;;;;;AACA;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;;AANA;AAQA;;;;;AACA;AAEA;;;;;;AAEA;AACA;;AAFA;AAIA;;;;;AACA;AAEA;;;;;;AACA;AAOA;AAEA;AACA;;AAJA;AAMA;;;;;AACA;AAEA;;;;;;AACA;AAAA;;AAAA;AACA;;;;;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;;AAEA;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AAMA;AAMA;AAUA;AACA;AACA;AAEA;AAMA;AAQA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAMA;AAGA;AACA;AAAA;;;;;;;;;;;;;;AC7LA;AAAA;AAAA;AAUA;AACA;AANA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArFA;AAsFA;AAAA;AAvFA;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAAA;AAQA;AACA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AASA;AAEA;;;;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAZA;AAaA;AACA;;;;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AAEA;;;;AACA;AACA;;;AACA;AAEA;;;;;;AAEA;;;;AAEA;;AAAA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAZA;AAaA;AACA;AAEA;;;;AAGA;;;;;AAEA;AAEA;AAAA;;;;;;AAEA;AACA;AACA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;;;AAEA;AACA;;;;;AAEA;AAEA;AAAA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AACA;AACA;AAAA;;;;;;;;;;;;;;ACpUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACNA;AAKA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAjBA;AAkBA;AAAA;AAnBA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}