{"version":3,"file":"testDataDSPlugin.6310f9af5345c722b930.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/testdata/ConfigEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/testdata/LogIpsum.ts","webpack:///webpack:///./public/app/plugins/datasource/testdata/TestInfoTab.tsx","webpack:///webpack:///./public/app/plugins/datasource/testdata/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/testdata/metricTree.ts","webpack:///webpack:///./public/app/plugins/datasource/testdata/module.tsx","webpack:///webpack:///./public/app/plugins/datasource/testdata/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/testdata/runStreams.ts"],"sourcesContent":["// Libraries\nimport React, { PureComponent } from 'react';\n\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\n\ntype Props = DataSourcePluginOptionsEditorProps<any>;\n\n/**\n * Empty Config Editor -- settings to save\n */\nexport class ConfigEditor extends PureComponent<Props> {\n  render() {\n    return <div />;\n  }\n}\n","import { LogLevel } from '@grafana/data';\n\nlet index = 0;\n\nexport function getRandomLogLevel(): LogLevel {\n  const v = Math.random();\n  if (v > 0.9) {\n    return LogLevel.critical;\n  }\n  if (v > 0.8) {\n    return LogLevel.error;\n  }\n  if (v > 0.7) {\n    return LogLevel.warning;\n  }\n  if (v > 0.4) {\n    return LogLevel.info;\n  }\n  if (v > 0.3) {\n    return LogLevel.debug;\n  }\n  if (v > 0.1) {\n    return LogLevel.trace;\n  }\n  return LogLevel.unknown;\n}\n\nexport function getNextWord() {\n  index = (index + Math.floor(Math.random() * 5)) % words.length;\n  return words[index];\n}\n\nexport function getRandomLine(length = 60) {\n  let line = getNextWord();\n  while (line.length < length) {\n    line += ' ' + getNextWord();\n  }\n  return line;\n}\n\nconst words = [\n  'At',\n  'vero',\n  'eos',\n  'et',\n  'accusamus',\n  'et',\n  'iusto',\n  'odio',\n  'dignissimos',\n  'ducimus',\n  'qui',\n  'blanditiis',\n  'praesentium',\n  'voluptatum',\n  'deleniti',\n  'atque',\n  'corrupti',\n  'quos',\n  'dolores',\n  'et',\n  'quas',\n  'molestias',\n  'excepturi',\n  'sint',\n  'occaecati',\n  'cupiditate',\n  'non',\n  'provident',\n  'similique',\n  'sunt',\n  'in',\n  'culpa',\n  'qui',\n  'officia',\n  'deserunt',\n  'mollitia',\n  'animi',\n  'id',\n  'est',\n  'laborum',\n  'et',\n  'dolorum',\n  'fuga',\n  'Et',\n  'harum',\n  'quidem',\n  'rerum',\n  'facilis',\n  'est',\n  'et',\n  'expedita',\n  'distinctio',\n  'Nam',\n  'libero',\n  'tempore',\n  'cum',\n  'soluta',\n  'nobis',\n  'est',\n  'eligendi',\n  'optio',\n  'cumque',\n  'nihil',\n  'impedit',\n  'quo',\n  'minus',\n  'id',\n  'quod',\n  'maxime',\n  'placeat',\n  'facere',\n  'possimus',\n  'omnis',\n  'voluptas',\n  'assumenda',\n  'est',\n  'omnis',\n  'dolor',\n  'repellendus',\n  'Temporibus',\n  'autem',\n  'quibusdam',\n  'et',\n  'aut',\n  'officiis',\n  'debitis',\n  'aut',\n  'rerum',\n  'necessitatibus',\n  'saepe',\n  'eveniet',\n  'ut',\n  'et',\n  'voluptates',\n  'repudiandae',\n  'sint',\n  'et',\n  'molestiae',\n  'non',\n  'recusandae',\n  'Itaque',\n  'earum',\n  'rerum',\n  'hic',\n  'tenetur',\n  'a',\n  'sapiente',\n  'delectus',\n  'ut',\n  'aut',\n  'reiciendis',\n  'voluptatibus',\n  'maiores',\n  'alias',\n  'consequatur',\n  'aut',\n  'perferendis',\n  'doloribus',\n  'asperiores',\n  'repellat',\n];\n","// Libraries\r\nimport React, { PureComponent } from 'react';\r\n\r\n// Types\r\nimport { PluginConfigPageProps, DataSourcePluginMeta, DataSourceJsonData } from '@grafana/data';\r\n\r\ninterface Props extends PluginConfigPageProps<DataSourcePluginMeta<DataSourceJsonData>> {}\r\n\r\nexport class TestInfoTab extends PureComponent<Props> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        See github for more information about setting up a reproducable test environment.\r\n        <br />\r\n        <br />\r\n        <a\r\n          className=\"btn btn-inverse\"\r\n          href=\"https://github.com/grafana/grafana/tree/master/devenv\"\r\n          target=\"_blank\"\r\n          rel=\"noopener\"\r\n        >\r\n          Github\r\n        </a>\r\n        <br />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import {\r\n  DataQueryRequest,\r\n  DataQueryResponse,\r\n  DataSourceApi,\r\n  DataSourceInstanceSettings,\r\n  MetricFindValue,\r\n  TableData,\r\n  TimeSeries,\r\n  DataQueryError,\r\n} from '@grafana/data';\r\nimport { Scenario, TestDataQuery } from './types';\r\nimport { getBackendSrv } from 'app/core/services/backend_srv';\r\nimport { queryMetricTree } from './metricTree';\r\nimport { from, merge, Observable } from 'rxjs';\r\nimport { runStream } from './runStreams';\r\nimport templateSrv from 'app/features/templating/template_srv';\r\nimport { getSearchFilterScopedVar } from '../../../features/templating/variable';\r\n\r\ntype TestData = TimeSeries | TableData;\r\n\r\nexport class TestDataDataSource extends DataSourceApi<TestDataQuery> {\r\n  constructor(instanceSettings: DataSourceInstanceSettings) {\r\n    super(instanceSettings);\r\n  }\r\n\r\n  query(options: DataQueryRequest<TestDataQuery>): Observable<DataQueryResponse> {\r\n    const queries: any[] = [];\r\n    const streams: Array<Observable<DataQueryResponse>> = [];\r\n\r\n    // Start streams and prepare queries\r\n    for (const target of options.targets) {\r\n      if (target.hide) {\r\n        continue;\r\n      }\r\n      if (target.scenarioId === 'streaming_client') {\r\n        streams.push(runStream(target, options));\r\n      } else {\r\n        queries.push({\r\n          ...target,\r\n          intervalMs: options.intervalMs,\r\n          maxDataPoints: options.maxDataPoints,\r\n          datasourceId: this.id,\r\n          alias: templateSrv.replace(target.alias || ''),\r\n        });\r\n      }\r\n    }\r\n\r\n    if (queries.length) {\r\n      const req: Promise<DataQueryResponse> = getBackendSrv()\r\n        .datasourceRequest({\r\n          method: 'POST',\r\n          url: '/api/tsdb/query',\r\n          data: {\r\n            from: options.range.from.valueOf().toString(),\r\n            to: options.range.to.valueOf().toString(),\r\n            queries: queries,\r\n          },\r\n          // This sets up a cancel token\r\n          requestId: options.requestId,\r\n        })\r\n        .then((res: any) => this.processQueryResult(queries, res));\r\n\r\n      streams.push(from(req));\r\n    }\r\n\r\n    return merge(...streams);\r\n  }\r\n\r\n  processQueryResult(queries: any, res: any): DataQueryResponse {\r\n    const data: TestData[] = [];\r\n    let error: DataQueryError | undefined = undefined;\r\n\r\n    for (const query of queries) {\r\n      const results = res.data.results[query.refId];\r\n\r\n      for (const t of results.tables || []) {\r\n        const table = t as TableData;\r\n        table.refId = query.refId;\r\n        table.name = query.alias;\r\n        data.push(table);\r\n      }\r\n\r\n      for (const series of results.series || []) {\r\n        data.push({ target: series.name, datapoints: series.points, refId: query.refId, tags: series.tags });\r\n      }\r\n\r\n      if (results.error) {\r\n        error = {\r\n          message: results.error,\r\n        };\r\n      }\r\n    }\r\n\r\n    return { data, error };\r\n  }\r\n\r\n  annotationQuery(options: any) {\r\n    let timeWalker = options.range.from.valueOf();\r\n    const to = options.range.to.valueOf();\r\n    const events = [];\r\n    const eventCount = 10;\r\n    const step = (to - timeWalker) / eventCount;\r\n\r\n    for (let i = 0; i < eventCount; i++) {\r\n      events.push({\r\n        annotation: options.annotation,\r\n        time: timeWalker,\r\n        text: 'This is the text, <a href=\"https://grafana.com\">Grafana.com</a>',\r\n        tags: ['text', 'server'],\r\n      });\r\n      timeWalker += step;\r\n    }\r\n    return Promise.resolve(events);\r\n  }\r\n\r\n  getQueryDisplayText(query: TestDataQuery) {\r\n    if (query.alias) {\r\n      return query.scenarioId + ' as ' + query.alias;\r\n    }\r\n    return query.scenarioId;\r\n  }\r\n\r\n  testDatasource() {\r\n    return Promise.resolve({\r\n      status: 'success',\r\n      message: 'Data source is working',\r\n    });\r\n  }\r\n\r\n  getScenarios(): Promise<Scenario[]> {\r\n    return getBackendSrv().get('/api/tsdb/testdata/scenarios');\r\n  }\r\n\r\n  metricFindQuery(query: string, options: any) {\r\n    return new Promise<MetricFindValue[]>((resolve, reject) => {\r\n      setTimeout(() => {\r\n        const interpolatedQuery = templateSrv.replace(\r\n          query,\r\n          getSearchFilterScopedVar({ query, wildcardChar: '*', options })\r\n        );\r\n        const children = queryMetricTree(interpolatedQuery);\r\n        const items = children.map(item => ({ value: item.name, text: item.name }));\r\n        resolve(items);\r\n      }, 100);\r\n    });\r\n  }\r\n}\r\n","export interface TreeNode {\r\n  name: string;\r\n  children: TreeNode[];\r\n}\r\n\r\n/*\r\n *  Builds a nested tree like\r\n *  [\r\n *    {\r\n *      name: 'A',\r\n *      children: [\r\n *        { name: 'AA', children: [] },\r\n *        { name: 'AB', children: [] },\r\n *      ]\r\n *    }\r\n *  ]\r\n */\r\nfunction buildMetricTree(parent: string, depth: number): TreeNode[] {\r\n  const chars = ['A', 'B', 'C'];\r\n  const children: TreeNode[] = [];\r\n\r\n  if (depth > 3) {\r\n    return [];\r\n  }\r\n\r\n  for (const letter of chars) {\r\n    const nodeName = `${parent}${letter}`;\r\n    children.push({\r\n      name: nodeName,\r\n      children: buildMetricTree(nodeName, depth + 1),\r\n    });\r\n  }\r\n\r\n  return children;\r\n}\r\n\r\nfunction queryTree(children: TreeNode[], query: string[], queryIndex: number): TreeNode[] {\r\n  if (queryIndex >= query.length) {\r\n    return children;\r\n  }\r\n\r\n  if (query[queryIndex] === '*') {\r\n    return children;\r\n  }\r\n\r\n  const nodeQuery = query[queryIndex];\r\n  let result: TreeNode[] = [];\r\n  let namesToMatch = [nodeQuery];\r\n\r\n  // handle glob queries\r\n  if (nodeQuery.startsWith('{')) {\r\n    namesToMatch = nodeQuery.replace(/\\{|\\}/g, '').split(',');\r\n  }\r\n\r\n  for (const node of children) {\r\n    for (const nameToMatch of namesToMatch) {\r\n      if (nameToMatch.indexOf('*') !== -1) {\r\n        const pattern = nameToMatch.replace('*', '');\r\n        const regex = new RegExp(`^${pattern}.*`, 'gi');\r\n        if (regex.test(node.name)) {\r\n          result = result.concat(queryTree([node], query, queryIndex + 1));\r\n        }\r\n      } else if (node.name === nameToMatch) {\r\n        result = result.concat(queryTree(node.children, query, queryIndex + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function queryMetricTree(query: string): TreeNode[] {\r\n  const children = buildMetricTree('', 0);\r\n  return queryTree(children, query.split('.'), 0);\r\n}\r\n","import { DataSourcePlugin } from '@grafana/data';\r\nimport { TestDataDataSource } from './datasource';\r\nimport { TestDataQueryCtrl } from './query_ctrl';\r\nimport { TestInfoTab } from './TestInfoTab';\r\nimport { ConfigEditor } from './ConfigEditor';\r\n\r\nclass TestDataAnnotationsQueryCtrl {\r\n  annotation: any;\r\n  constructor() {}\r\n  static template = '<h2>Annotation scenario</h2>';\r\n}\r\n\r\nexport const plugin = new DataSourcePlugin(TestDataDataSource)\r\n  .setConfigEditor(ConfigEditor)\r\n  .setQueryCtrl(TestDataQueryCtrl)\r\n  .setAnnotationQueryCtrl(TestDataAnnotationsQueryCtrl)\r\n  .addConfigPage({\r\n    title: 'Setup',\r\n    icon: 'fa fa-list-alt',\r\n    body: TestInfoTab,\r\n    id: 'setup',\r\n  });\r\n","import _ from 'lodash';\r\nimport { dateMath, dateTime } from '@grafana/data';\r\nimport { e2e } from '@grafana/e2e';\r\n\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport { defaultQuery } from './runStreams';\r\nimport { getBackendSrv } from 'app/core/services/backend_srv';\r\n\r\nexport const defaultPulse: any = {\r\n  timeStep: 60,\r\n  onCount: 3,\r\n  onValue: 2,\r\n  offCount: 3,\r\n  offValue: 1,\r\n};\r\n\r\nexport const defaultCSVWave: any = {\r\n  timeStep: 60,\r\n  valuesCSV: '0,0,2,2,1,1',\r\n};\r\n\r\nconst showLabelsFor = ['random_walk', 'predictable_pulse', 'predictable_csv_wave'];\r\n\r\nexport class TestDataQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  scenarioList: any;\r\n  scenario: any;\r\n  newPointValue: number;\r\n  newPointTime: any;\r\n  selectedPoint: any;\r\n\r\n  showLabels = false;\r\n  selectors: typeof e2e.pages.Dashboard.Panels.DataSource.TestData.QueryTab.selectors;\r\n\r\n  /** @ngInject */\r\n  constructor($scope: any, $injector: any) {\r\n    super($scope, $injector);\r\n\r\n    this.target.scenarioId = this.target.scenarioId || 'random_walk';\r\n    this.scenarioList = [];\r\n    this.newPointTime = dateTime();\r\n    this.selectedPoint = { text: 'Select point', value: null };\r\n    this.showLabels = showLabelsFor.includes(this.target.scenarioId);\r\n    this.selectors = e2e.pages.Dashboard.Panels.DataSource.TestData.QueryTab.selectors;\r\n  }\r\n\r\n  getPoints() {\r\n    return _.map(this.target.points, (point, index) => {\r\n      return {\r\n        text: dateTime(point[1]).format('MMMM Do YYYY, H:mm:ss') + ' : ' + point[0],\r\n        value: index,\r\n      };\r\n    });\r\n  }\r\n\r\n  pointSelected(option: any) {\r\n    this.selectedPoint = option;\r\n  }\r\n\r\n  deletePoint() {\r\n    this.target.points.splice(this.selectedPoint.value, 1);\r\n    this.selectedPoint = { text: 'Select point', value: null };\r\n    this.refresh();\r\n  }\r\n\r\n  addPoint() {\r\n    this.target.points = this.target.points || [];\r\n    this.newPointTime = dateMath.parse(this.newPointTime);\r\n    this.target.points.push([this.newPointValue, this.newPointTime.valueOf()]);\r\n    this.target.points = _.sortBy(this.target.points, p => p[1]);\r\n    this.refresh();\r\n  }\r\n\r\n  $onInit() {\r\n    return getBackendSrv()\r\n      .get('/api/tsdb/testdata/scenarios')\r\n      .then((res: any) => {\r\n        this.scenarioList = res;\r\n        this.scenario = _.find(this.scenarioList, { id: this.target.scenarioId });\r\n      });\r\n  }\r\n\r\n  scenarioChanged() {\r\n    this.scenario = _.find(this.scenarioList, { id: this.target.scenarioId });\r\n    this.target.stringInput = this.scenario.stringInput;\r\n    this.showLabels = showLabelsFor.includes(this.target.scenarioId);\r\n\r\n    if (this.target.scenarioId === 'manual_entry') {\r\n      this.target.points = this.target.points || [];\r\n    } else {\r\n      delete this.target.points;\r\n    }\r\n\r\n    if (this.target.scenarioId === 'streaming_client') {\r\n      this.target.stream = _.defaults(this.target.stream || {}, defaultQuery);\r\n    } else {\r\n      delete this.target.stream;\r\n    }\r\n\r\n    if (this.target.scenarioId === 'predictable_pulse') {\r\n      this.target.pulseWave = _.defaults(this.target.pulseWave || {}, defaultPulse);\r\n    } else {\r\n      delete this.target.pulseWave;\r\n    }\r\n\r\n    if (this.target.scenarioId === 'predictable_csv_wave') {\r\n      this.target.csvWave = _.defaults(this.target.csvWave || {}, defaultCSVWave);\r\n    } else {\r\n      delete this.target.csvWave;\r\n    }\r\n\r\n    this.refresh();\r\n  }\r\n\r\n  streamChanged() {\r\n    this.refresh();\r\n  }\r\n}\r\n","import { defaults } from 'lodash';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport {\r\n  DataQueryRequest,\r\n  DataQueryResponse,\r\n  FieldType,\r\n  CircularDataFrame,\r\n  CSVReader,\r\n  Field,\r\n  LoadingState,\r\n} from '@grafana/data';\r\n\r\nimport { TestDataQuery, StreamingQuery } from './types';\r\nimport { getRandomLine } from './LogIpsum';\r\n\r\nexport const defaultQuery: StreamingQuery = {\r\n  type: 'signal',\r\n  speed: 250, // ms\r\n  spread: 3.5,\r\n  noise: 2.2,\r\n  bands: 1,\r\n};\r\n\r\nexport function runStream(target: TestDataQuery, req: DataQueryRequest<TestDataQuery>): Observable<DataQueryResponse> {\r\n  const query = defaults(target.stream, defaultQuery);\r\n  if ('signal' === query.type) {\r\n    return runSignalStream(target, query, req);\r\n  }\r\n  if ('logs' === query.type) {\r\n    return runLogsStream(target, query, req);\r\n  }\r\n  if ('fetch' === query.type) {\r\n    return runFetchStream(target, query, req);\r\n  }\r\n  throw new Error(`Unknown Stream Type: ${query.type}`);\r\n}\r\n\r\nexport function runSignalStream(\r\n  target: TestDataQuery,\r\n  query: StreamingQuery,\r\n  req: DataQueryRequest<TestDataQuery>\r\n): Observable<DataQueryResponse> {\r\n  return new Observable<DataQueryResponse>(subscriber => {\r\n    const streamId = `signal-${req.panelId}-${target.refId}`;\r\n    const maxDataPoints = req.maxDataPoints || 1000;\r\n\r\n    const data = new CircularDataFrame({\r\n      append: 'tail',\r\n      capacity: maxDataPoints,\r\n    });\r\n    data.refId = target.refId;\r\n    data.name = target.alias || 'Signal ' + target.refId;\r\n    data.addField({ name: 'time', type: FieldType.time });\r\n    data.addField({ name: 'value', type: FieldType.number });\r\n\r\n    const { spread, speed, bands, noise } = query;\r\n\r\n    for (let i = 0; i < bands; i++) {\r\n      const suffix = bands > 1 ? ` ${i + 1}` : '';\r\n      data.addField({ name: 'Min' + suffix, type: FieldType.number });\r\n      data.addField({ name: 'Max' + suffix, type: FieldType.number });\r\n    }\r\n\r\n    let value = Math.random() * 100;\r\n    let timeoutId: any = null;\r\n\r\n    const addNextRow = (time: number) => {\r\n      value += (Math.random() - 0.5) * spread;\r\n\r\n      let idx = 0;\r\n      data.fields[idx++].values.add(time);\r\n      data.fields[idx++].values.add(value);\r\n\r\n      let min = value;\r\n      let max = value;\r\n\r\n      for (let i = 0; i < bands; i++) {\r\n        min = min - Math.random() * noise;\r\n        max = max + Math.random() * noise;\r\n\r\n        data.fields[idx++].values.add(min);\r\n        data.fields[idx++].values.add(max);\r\n      }\r\n    };\r\n\r\n    // Fill the buffer on init\r\n    if (true) {\r\n      let time = Date.now() - maxDataPoints * speed;\r\n      for (let i = 0; i < maxDataPoints; i++) {\r\n        addNextRow(time);\r\n        time += speed;\r\n      }\r\n    }\r\n\r\n    const pushNextEvent = () => {\r\n      addNextRow(Date.now());\r\n      subscriber.next({\r\n        data: [data],\r\n        key: streamId,\r\n      });\r\n\r\n      timeoutId = setTimeout(pushNextEvent, speed);\r\n    };\r\n\r\n    // Send first event in 5ms\r\n    setTimeout(pushNextEvent, 5);\r\n\r\n    return () => {\r\n      console.log('unsubscribing to stream ' + streamId);\r\n      clearTimeout(timeoutId);\r\n    };\r\n  });\r\n}\r\n\r\nexport function runLogsStream(\r\n  target: TestDataQuery,\r\n  query: StreamingQuery,\r\n  req: DataQueryRequest<TestDataQuery>\r\n): Observable<DataQueryResponse> {\r\n  return new Observable<DataQueryResponse>(subscriber => {\r\n    const streamId = `logs-${req.panelId}-${target.refId}`;\r\n    const maxDataPoints = req.maxDataPoints || 1000;\r\n\r\n    const data = new CircularDataFrame({\r\n      append: 'tail',\r\n      capacity: maxDataPoints,\r\n    });\r\n    data.refId = target.refId;\r\n    data.name = target.alias || 'Logs ' + target.refId;\r\n    data.addField({ name: 'time', type: FieldType.time });\r\n    data.addField({ name: 'line', type: FieldType.string });\r\n\r\n    const { speed } = query;\r\n\r\n    let timeoutId: any = null;\r\n\r\n    const pushNextEvent = () => {\r\n      data.values.time.add(Date.now());\r\n      data.values.line.add(getRandomLine());\r\n\r\n      subscriber.next({\r\n        data: [data],\r\n        key: streamId,\r\n      });\r\n\r\n      timeoutId = setTimeout(pushNextEvent, speed);\r\n    };\r\n\r\n    // Send first event in 5ms\r\n    setTimeout(pushNextEvent, 5);\r\n\r\n    return () => {\r\n      console.log('unsubscribing to stream ' + streamId);\r\n      clearTimeout(timeoutId);\r\n    };\r\n  });\r\n}\r\n\r\nexport function runFetchStream(\r\n  target: TestDataQuery,\r\n  query: StreamingQuery,\r\n  req: DataQueryRequest<TestDataQuery>\r\n): Observable<DataQueryResponse> {\r\n  return new Observable<DataQueryResponse>(subscriber => {\r\n    const streamId = `fetch-${req.panelId}-${target.refId}`;\r\n    const maxDataPoints = req.maxDataPoints || 1000;\r\n\r\n    let data = new CircularDataFrame({\r\n      append: 'tail',\r\n      capacity: maxDataPoints,\r\n    });\r\n    data.refId = target.refId;\r\n    data.name = target.alias || 'Fetch ' + target.refId;\r\n\r\n    let reader: ReadableStreamReader<Uint8Array>;\r\n    const csv = new CSVReader({\r\n      callback: {\r\n        onHeader: (fields: Field[]) => {\r\n          // Clear any existing fields\r\n          if (data.fields.length) {\r\n            data = new CircularDataFrame({\r\n              append: 'tail',\r\n              capacity: maxDataPoints,\r\n            });\r\n            data.refId = target.refId;\r\n            data.name = 'Fetch ' + target.refId;\r\n          }\r\n          for (const field of fields) {\r\n            data.addField(field);\r\n          }\r\n        },\r\n        onRow: (row: any[]) => {\r\n          data.add(row);\r\n        },\r\n      },\r\n    });\r\n\r\n    const processChunk = (value: ReadableStreamReadResult<Uint8Array>): any => {\r\n      if (value.value) {\r\n        const text = new TextDecoder().decode(value.value);\r\n        csv.readCSV(text);\r\n      }\r\n\r\n      subscriber.next({\r\n        data: [data],\r\n        key: streamId,\r\n        state: value.done ? LoadingState.Done : LoadingState.Streaming,\r\n      });\r\n\r\n      if (value.done) {\r\n        console.log('Finished stream');\r\n        subscriber.complete(); // necessary?\r\n        return;\r\n      }\r\n\r\n      return reader.read().then(processChunk);\r\n    };\r\n\r\n    fetch(new Request(query.url)).then(response => {\r\n      reader = response.body.getReader();\r\n      reader.read().then(processChunk);\r\n    });\r\n\r\n    return () => {\r\n      // Cancel fetch?\r\n      console.log('unsubscribing to stream ' + streamId);\r\n    };\r\n  });\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAMA;;AAEA;AACA;AAAA;AAAA;;AAIA;AAHA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjKA;AACA;AAOA;AAAA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AAQA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AAWA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAOA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;;AAEA;AAAA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;AAAA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;AC7IA;;;;;;;;;;;AAWA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAYA;AACA;AAAA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AA7FA;AA8FA;AAAA;AA/FA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAEA;AAWA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}